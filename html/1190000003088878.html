<h2>前言</h2>

<p>前几天整理了CSS一些技术关键字，但是因为自己的知识过于单薄，觉得考虑的不充分有欠缺，随后便在sf.gg提出了这个问题《<a rel="nofollow" href="http://segmentfault.com/u/alsiso/questions">关于CSS核心技术关键字都有哪些？</a>》，也是为了让厉害的人一起参与进来，用他们的经验告知我们CSS中哪一块的知识点是重要，或者说是不可欠缺的，也或者说是应该打好基础的。</p>

<p>在整理这份CSS技术关键字的开始，首先想到的是选择器，它作为最常用的的一个特性，几乎天天都在使用，但是如果让你说出20种CSS选择器，是不是可以脱口而出呢？ 哎，或许我们被浏览器逼的还停留在CSS2.1那些选择器把？CSS4规范都要问世了，我们还在玩那个？</p>

<p><img data-src="/img/bVm2Al" src="/img/bVm2Al.png"></p>

<p>带着这些疑问，决定梳理一下之前用到的知识点，最终以系列文章的方式说一说我对选择器的理解，具体包含的内容如下：</p>

<ul>
<li>选择器的基础使用，主要是CSS3，也会介绍新增CSS4选择器，包括各浏览器对选择器的支持情况</li>
<li>选择器的使用技巧，使用时常出现的一些问题，扒一扒解决方案，再说一说效率和优化的部分</li>
<li>选择器的优先级，理一理比较头疼的权重问题，如何更轻松的理解它</li>
</ul>
<h2>导图与源码</h2>

<p>我在写这篇文章的时候会梳理一份思维导图，用于更加直观的查阅所有的CSS选择器，并且也有编写示例代码，更方便理解文章中的示例。</p>

<p>关于思维导图和示例代码，会上传至Github，当然也会随着时间的允许，不定义补充和更新<br>
仓库地址：<a rel="nofollow" href="https://github.com/Alsiso/everyday"></a><a rel="nofollow" href="https://github.com/Alsiso/everyday">https://github.com/Alsiso/everyday</a><br>
思维导图：<a rel="nofollow" href="https://github.com/Alsiso/everyday/blob/master/codes/css-selectors/css-selectors.png">https://github.com/Alsiso/everyday/blob/master/codes/css-selectors/css...</a><br>
示例代码：<a rel="nofollow" href="https://github.com/Alsiso/everyday/tree/master/codes/css-selectors">https://github.com/Alsiso/everyday/tree/master/codes/css-selectors</a></p>

<p>关于<code>everyday</code>是我每天记录和总结的地方，这里有代码，布局方案，移动端适配方案等等，后续会不断的补充和更新，欢迎一起聊代码，玩前端。</p>

<p><img data-src="/img/bVm7IJ" src="/img/bVm7IJ.png"></p>

<h2>基本选择器</h2>

<h3>通配符选择器 <code>*</code>
</h3>

<p>通配符选择器用来选择所有的元素</p>

<pre><code>* {
    marigin: 0;
    padding: 0;
}
</code></pre>

<p>在我之的文章中讨论过<a rel="nofollow" href="http://segmentfault.com/a/1190000003021766">CSS RESET</a>，其中里面的核心代码就是使用通配符选择器定义的，来重置浏览器所有元素的内边距和外边距。</p>

<p>其实，通配符选择器还可以选择某一个元素下的所有元素</p>

<pre><code>#demo *{
    margin:0;
}
</code></pre>

<p>不过使用通配符要<strong>谨慎</strong>，并不是因为<a rel="nofollow" href="http://shawphy.com/2010/09/no-css-reset.html">通配符会带来性能问题</a>，而是滥用通配符会造成<a rel="nofollow" href="http://segmentfault.com/q/1010000002997970">“继承失效”或“继承短路”</a>的问题，这种情况会对开发造成一定程度的影响。</p>

<h3>元素选择器 <code>E</code>
</h3>

<p>元素选择器使用也很简单，它用于指定HTML文档中元素的样式</p>

<pre><code>ul{
    list-style:none;
}
</code></pre>

<p>▲ 这里使用<strong>元素选择器</strong>选择<code>ul</code>元素并去除列表前面的默认圆点</p>

<h3>类选择器<code>.className</code>
</h3>

<p>类选择器是最常用的一种选择器，使用时需要在HTML文档元素上定义类名，然后与样式中的<code>.className</code>相匹配，它一次定义后，在HTML文档元素中是可以<strong>多次复用</strong>的。</p>

<p><strong>CSS</strong></p>

<pre><code>.menu {
    margin:0 auto;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div class="menu"&gt;&lt;/div&gt;
</code></pre>

<p>类选择器还可以<strong>结合元素选择器</strong>来使用，假设文档中有两个元素都使用了<code>.menu</code>类名，但是你只想选择<code>div</code>元素上类名为<code>.menu</code>的元素</p>

<p><strong>CSS</strong></p>

<pre><code>div.menu {
    margin:0 auto;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div class="menu"&gt;&lt;/div&gt;
&lt;ul class="menu"&gt;&lt;/ul&gt;
</code></pre>

<p><strong>类选择器支持多类名使用</strong>，比如<code>.menu.active</code>这个选择器只对元素中同时包含了<code>menu</code>和<code>active</code>两个类才会起作用</p>

<p><strong>CSS</strong></p>

<pre><code>.menu {
    margin:0 auto;
}
.menu.active {
    font-weight:bold;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div class="menu active"&gt;&lt;/div&gt;
</code></pre>

<p>不过<strong>多类选择器</strong><code>.className1.className2</code>在 <strong>IE6+</strong>以上才支持，关于浏览器对CSS选择器的支持会下面的内容统一整理列出表格。</p>

<h3>id选择器<code>#id</code>
</h3>

<p>id选择器与上面的类选择器使用很相似，通过在HTML文档中添加ID名称，然后与样式中的<code>#id</code>相匹配，<strong>不过两者的最大的区别在于</strong>，ID选择器是一个页面中唯一的值，不可多次使用，而class选择器是可以多次复用的。</p>

<p><strong>CSS</strong></p>

<pre><code>#menu{
    margin:0 auto;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div id="menu"&gt;&lt;/div&gt;
</code></pre>

<h3>群组选择器<code>s1,s2,...,sN</code>
</h3>

<p>群组选择器在开发中也是很常用的，它用于将相同样式的元素分组在一起，然后用逗号进行分割。</p>

<p><strong>CSS</strong></p>

<pre><code>a:active,a:hover {
  outline: 0;
}
</code></pre>

<p>▲ 这里统一去掉了<code>a</code>链接在点击和浮动时的虚线焦点框。</p>

<h3>后代选择器<code>E F</code>
</h3>

<p>后代选择器是<strong>最常使用的选择器</strong>之一，它也被称作包含选择器，用于匹配所有被<code>E</code>元素包含的<code>F</code>元素，这里<code>F</code>元素不管是<code>E</code>元素的子元素或者是孙元素或者是更深层次的关系，都将被选中。</p>

<p><strong>CSS</strong></p>

<pre><code>.menu li{
    padding:0 ;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;ul id="menu"&gt;
    &lt;li&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>▲ 这里<code>.menu</code>下的<code>li</code>元素和嵌套的<code>ul</code>元素下的<code>li</code>的元素都会被选择，进行清楚内边距。</p>

<h3>子元素选择器<code>E &gt; F</code>
</h3>

<p>子元素选择器只能选择某元素的子元素，这里的<code>F</code>元素仅仅是<code>E</code>元素的子元素才可以被选中</p>

<p><strong>CSS</strong></p>

<pre><code>.menu &gt; li{
    padding:0 ;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;ul id="menu"&gt;
    &lt;li&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>▲ 将会对<code>.menu</code>下的<code>li</code>子元素选中，但会忽视内部嵌套的<code>li</code>元素</p>

<h3>相邻兄弟元素选择器<code>E + F</code>
</h3>

<p>相邻兄弟选择器可以选择紧接在另一元素后的元素，但是他们必须有一个相同的父元素。比如<code>E</code>元素和<code>F</code>元素具有一个相同的父元素，而且<code>F</code>元素在<code>E</code>元素后面，这样我们就可以使用相邻兄弟元素选择器来选择<code>F</code>元素。</p>

<p><strong>CSS</strong></p>

<pre><code>h1 + p {
    margin-top:5px;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div&gt;
    &lt;h1&gt;标题&lt;/h1&gt;
    &lt;p&gt;内容&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>▲ 将会选择<code>h1</code>元素后面的兄弟元素<code>p</code></p>

<h3>通用兄弟选择器<code>E ~ F</code>
</h3>

<p>通用兄弟元素选择器是<strong>CSS3</strong>新增加一种选择器，用于选择某元素后面的所有兄弟元素。它和相邻兄弟元素选择器用法相似，但不同于前者只是选择相邻的后一个元素，而通用兄弟元素选择器是选择<strong>所有元素</strong>。</p>

<p><strong>CSS</strong></p>

<pre><code>h1 ~ p {
    margin-top:5px;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div&gt;
    &lt;h1&gt;标题&lt;/h1&gt;
    &lt;p&gt;内容&lt;/p&gt;
    &lt;p&gt;内容&lt;/p&gt;
    &lt;p&gt;内容&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>▲ 将会选择<code>h1</code>元素后面的所有的兄弟元素<code>p</code></p>

<h2>属性选择器</h2>

<table>
<thead><tr>
<th>选择器</th>
            <th>描述</th>
            <th>CSS版本</th>
        </tr></thead>
<tbody>
<tr>
<td>E[attr]</td>
  <td>匹配所有具有attr属性的E元素</td>
  <td>2.1</td>
</tr>
<tr>
<td>E[attr=value]</td>
  <td>匹配所有attr属性等于“value”的E元素</td>
  <td>2.1</td>
</tr>
<tr>
<td>E[attr~=value]</td>
  <td>匹配所有attr属性具有多个空格分隔的值、其中一个值等于“value”的E元素</td>
  <td>2.1</td>
</tr>
<tr>
<td>E[attr^=value]</td>
  <td>匹配所有attr属性值是以val开头的E元素</td>
  <td>2.1</td>
</tr>
<tr>
<td>E[attr$=value]</td>
  <td>匹配所有attr属性值是以val结束的E元素</td>
  <td>3</td>
</tr>
<tr>
<td>E[attr*=value]</td>
  <td>匹配所有attr属性值包含有“value”的E元素</td>
  <td>3</td>
</tr>
</tbody>
</table>
<h3>E[attr]</h3>

<p><code>E[attr]</code>属性选择器是CSS3属性选择器最简单的一种，用于选择具有<code>att</code>属性的<code>E</code>元素。</p>

<p><strong>CSS</strong></p>

<pre><code>img[alt] {
    margin: 10px;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;img src="url" alt="" /&gt;
&lt;img src="url" /&gt;
</code></pre>

<p>▲ 将会选择到第一张图片，因为匹配到了alt属性，你也可以使用多属性的方式选择元素</p>

<pre><code>img[src][alt] {
    margin: 10px;
}
</code></pre>

<h3>E[attr=value]</h3>

<p><code>E[attr="value"]</code>是指定了属性值<code>value</code>，从而缩小了范围可以更为精确的查找到自己想要的元素。</p>

<p><strong>CSS</strong></p>

<pre><code>input[type="text"] {
    border: 2px solid #000;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;input type="text" /&gt;
&lt;input type="submit" /&gt;
</code></pre>

<p>▲ 将会选择到<code>type="text"</code>表单元素。</p>

<h3>E[attr~=value]</h3>

<p>如果你要根据属性值中的词列表的某个词来进行选择元素，那么就需要使用这种属性选择器：<code>E[attr~="value"]</code>，你会发现它和<code>E[attr="value"]</code>极为的相似，但是两者的区别是，属性选择器中有波浪（<code>~</code>）时属性值有<code>value</code>时就相匹配，没有波浪（<code>~</code>）时属性值要完全是<code>value</code>时才匹配。</p>

<p><strong>CSS</strong></p>

<pre><code>div[class~="a"] {
    border: 2px solid #000;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div class="a"&gt;1&lt;/div&gt;
&lt;div class="b"&gt;2&lt;/div&gt;
&lt;div class="a b"&gt;3&lt;/div&gt;
</code></pre>

<p>▲ 将会选择到第1、3个<code>div</code>元素，因为匹配到了<code>class</code>属性，且属性值中有一个值为<code>a</code></p>

<h3>E[attr^=value]</h3>

<p>E[attr^="value"]属性选择器，指的是选择<code>attr</code>属性值以<code>“value”</code>开头的所有元素</p>

<p><strong>CSS</strong></p>

<pre><code>div[class^="a"] {
    border: 2px solid #000;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div class="abc"&gt;1&lt;/div&gt;
&lt;div class="acb"&gt;2&lt;/div&gt;
&lt;div class="bac"&gt;3&lt;/div&gt;
</code></pre>

<p>▲ 将会选择到第1、2个<code>div</code>元素，因为匹配到了<code>class</code>属性，且属性值以<code>a</code>开头</p>

<h3>E[attr$=value]</h3>

<p><code>E[attr$="value"]</code>属性选择器刚好与<code>E[attr^="value"]</code>选择器相反，这里是选择<code>attr</code>属性值以"value"结尾的所有元素。</p>

<p><strong>CSS</strong></p>

<pre><code>div[class$="c"] {
    border: 2px solid #000;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div class="abc"&gt;1&lt;/div&gt;
&lt;div class="acb"&gt;2&lt;/div&gt;
&lt;div class="bac"&gt;3&lt;/div&gt;
</code></pre>

<p>▲ 将会选择到第1、3个<code>div</code>元素，因为匹配到了<code>class</code>属性，且属性值以<code>c</code>结尾</p>

<h3>E[attr*=value]</h3>

<p><code>E[attr*="value"]</code>属性选择器表示的是选择<code>attr</code>属性值中包含<code>"value"</code>字符串的所有元素。</p>

<p><strong>CSS</strong></p>

<pre><code>div[class*="b"] {
    border: 2px solid #000;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div class="abc"&gt;1&lt;/div&gt;
&lt;div class="acb"&gt;2&lt;/div&gt;
&lt;div class="bac"&gt;3&lt;/div&gt;
</code></pre>

<p>▲ 将会选择到所有的元素，因为匹配到了<code>class</code>属性，且属性值都包含了<code>b</code></p>

<h3>E[attr|="val"]</h3>

<p><code>E[attr|="val"]</code>是属性选择器中的最后一种，它被称作为特定属性选择器，这个选择器会选择<code>attr</code>属性值等于<code>value</code>或以<code>value-</code>开头的所有元素。</p>

<p><strong>CSS</strong></p>

<pre><code>div[class|="a"] {
    border: 2px solid #000;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div class="a-test"&gt;1&lt;/div&gt;
&lt;div class="b-test"&gt;2&lt;/div&gt;
&lt;div class="c-test"&gt;3&lt;/div&gt;
</code></pre>

<p>▲  将会选择第1个<code>div</code>元素，因为匹配到了<code>class</code>属性，且属性值以紧跟着<code>"a-"</code>的开头</p>

<h2>伪类选择器</h2>

<h3>动态伪类</h3>

<p>一般动态伪类是在用户操作体验时触发的，最常见的就是超链接，它拥有访问前，鼠标悬停，被点击，已访问4种伪类效果。</p>

<ul>
<li>
<code>E:link</code> 设置超链接a在未被访问前的样式</li>
<li>
<code>E:visited</code> 设置超链接a已被访问过时的样式</li>
<li>
<code>E:hover</code> 设置元素在其鼠标悬停时的样式</li>
<li>
<code>E:active</code> 设置元素在被用户激活时的样式</li>
</ul>
<p>不过在使用时的时候，一定要注意书写的顺序，不然在不同的浏览器中会带来一些意想不到的错误。</p>

<pre><code>a:link {}
a:visited {}
a:hover {}
a:active {}
</code></pre>

<p>最可靠的记忆顺序就是遵循爱恨原则：<strong>l</strong>(link)<strong>ov</strong>(visited)<strong>e</strong> <strong>h</strong>(hover)<strong>a</strong>(active)<strong>te</strong>, 即用喜欢(<strong>love</strong>)和讨厌(<strong>hate</strong>)两个词来概括。</p>

<p>还有一个用户行为的动态伪类<code>:focus</code>，常用于表单元素（触发onfocus事件发生）时的样式。</p>

<pre><code>input[type="text"]:focus{
    border: 2px solid #000;
}
</code></pre>

<p>▲ 当用户聚焦到输入框内，会给输入框添加一个边框颜色。</p>

<h3>表单状态伪类</h3>

<p>我们把以下3种状态称作表单状态伪类，你会发现这些关键字就是HTML表单元素的属性，<code>checked</code>用于<code>type="radio"</code>和<code>type="checkbox"</code>够选中状态，<code>disabled</code>用于<code>type="text"</code>禁用的状态，而<code>enabled</code>这里表示<code>type="text"</code>可用的状态。</p>

<ul>
<li>
<code>E:checked</code> 匹配用户界面上处于<strong>选中</strong>状态的元素E</li>
<li>
<code>E:enabled</code> 匹配用户界面上处于<strong>可用</strong>状态的元素E</li>
<li>
<code>E:disabled</code> 匹配用户界面上处于<strong>禁用</strong>状态的元素E</li>
</ul>
<p><strong>CSS</strong></p>

<pre><code>input[type="text"]:enabled {
    background: #fff;
}
input[type="text"]:disabled{
    background: #eee;
}
input:checked + span {
    background: red;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;input type="text" value="可用状态" /&gt;
&lt;input type="text" value="可用状态" /&gt;
&lt;input type="text" value="禁用状态" disabled="disabled" /&gt;
&lt;input type="text" value="禁用状态" disabled="disabled" /&gt;
&lt;label&gt;&lt;input type="radio" name="radio" /&gt;&lt;span&gt;黑色&lt;/span&gt;&lt;/label&gt;
</code></pre>

<p>▲ 将会给可用状态的文本框设置为白色(<code>#fff</code>)背景，禁用状态设置为灰色(<code>#eee</code>)背景，如果你选中了<code>radio</code>，它兄弟元素<code>span</code>的文本会变成红色</p>

<h3>结构伪类</h3>

<ul>
<li>
<code>E:first-child</code> 匹配父元素的第一个子元素E</li>
<li>
<code>E:last-child</code> 匹配父元素的最后一个子元素E</li>
<li>
<code>E:nth-child(n)</code> 匹配父元素的第n个子元素E，假设该子元素不是E，则选择符无效</li>
<li>
<code>E:nth-last-child(n)</code> 匹配父元素的倒数第n个子元素E，假设该子元素不是E，则选择符无效</li>
<li>
<code>E:first-of-type</code> 匹配同类型中的第一个同级兄弟元素E</li>
<li>
<code>E:last-of-type</code> 匹配同类型中的最后一个同级兄弟元素E</li>
<li>
<code>E:nth-of-type(n)</code> 匹配同类型中的第n个同级兄弟元素E</li>
<li>
<code>E:nth-last-of-type(n)</code> 匹配同类型中的倒数第n个同级兄弟元素E</li>
<li>
<code>E:only-child</code> 匹配父元素仅有的一个子元素E</li>
<li>
<code>E:only-of-type</code> 匹配同类型中的唯一的一个同级兄弟元素E</li>
<li>
<code>E:empty</code> 匹配没有任何子元素（包括text节点）的元素E</li>
</ul>
<p><strong>E:first-child 和 E:last-child</strong><br><code>E:first-child</code>是用来选择父元素的第一个子元素E，但是它必须为父元素的第一个子元素，不然会失效，举例说明</p>

<p><strong>CSS</strong></p>

<pre><code>p:first-child {
    color:red;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div&gt;
    &lt;h1&gt;标题&lt;/h1&gt;
    &lt;p&gt;段落&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>▲ 你会发现<code>p</code>元素的字体并没有变为红色，因为<code>p</code>元素前面还有个<code>h1</code>，它并不是父元素下的第一个子元素。</p>

<pre><code>&lt;div&gt;
    &lt;p&gt;段落&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>▲ 这时需要改变结构，效果才会正常。</p>

<p>而<code>E:last-child</code>与<code>E:first-child</code>选择器的作用类似，不同的是<code>E:last-child</code>选择是的元素的最后一个子元素。</p>

<p><strong>CSS</strong></p>

<pre><code>p:last-child {
    color:red;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div&gt;
    &lt;h1&gt;标题&lt;/h1&gt;
    &lt;p&gt;段落&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>▲ 将<code>p</code>元素的字体设置为红色</p>

<p><strong>E:nth-child(n) 和 E:nth-last-child(n)</strong><br><code>E:nth-child(n)</code>用于匹配父元素的第n个子元素E，假设该子元素不是E，则选择符无效。<br>
该选择符允许使用一个乘法因子(n)来作为换算方式，如下:</p>

<pre><code>li:nth-child(2) { background:#fff}
</code></pre>

<p>▲ 选择第几个标签，“2可以是你想要的数字，最小从0开始”</p>

<pre><code>li:nth-child(n+4) { background:#fff}
</code></pre>

<p>▲ 选择大于等于4标签，“n”表示从整数</p>

<pre><code>li:nth-child(-n+4) { background:#fff}
</code></pre>

<p>▲ 选择小于等于4标签</p>

<pre><code>li:nth-child(2n) { background:#fff}
li:nth-child(even) { background:#fff}
</code></pre>

<p>▲ 选择偶数标签，2n也可以是even</p>

<pre><code>li:nth-child(2n-1) { background:#fff}
li:nth-child(odd) { background:#fff}
</code></pre>

<p>▲ 选择奇数标签，2n-1也可以是odd</p>

<pre><code>li:nth-child(3n+1) { background:#fff}
</code></pre>

<p>▲ 自定义选择标签，3n+1表示“隔二取一”</p>

<p>而<code>E:nth-last-child(n)</code>又要开始反着来了，CSS3选择器有正就有反</p>

<pre><code>li:nth-last-child(3) { background:#fff}
</code></pre>

<p>▲ 选择倒数第3个标签</p>

<p><strong><code>E:first-of-type</code> 和 <code>E:last-of-type</code></strong><br><code>E:first-of-type</code>的使用方法类似于我们上面讲过的<code>E:first-child</code>,不过区别在于该选择器只会选择同类型的第一个元素，而不是父元素的第一个元素，举例说明：</p>

<p><strong>CSS</strong></p>

<pre><code>p:first-of-type {
    color:red;
}
p:last-of-type {
    color:green;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;div&gt;
    &lt;h1&gt;标题&lt;/h1&gt;
    &lt;p&gt;段落&lt;/p&gt;
    &lt;p&gt;段落&lt;/p&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>▲ 你会发现第一个<code>p</code>元素的字体被设置为红色，第二个<code>p</code>元素的字体被设置为绿色，这就是<code>E:first-of-type</code>和<code>E:first-child</code>不同之处。</p>

<p><strong><code>E:nth-of-type(n)</code> 和 <code>E:nth-last-of-type(n)</code></strong><br>
这两个选择器的用法类似于<code>:nth-child(n)</code>和<code>E:nth-last-child(n)</code>，关于区别也是选择器只会选择同类型的兄弟元素，举个栗子</p>

<pre><code>&lt;div&gt;
    &lt;p&gt;第1个p&lt;/p&gt;
    &lt;p&gt;第2个p&lt;/p&gt;
    &lt;span&gt;第1个span&lt;/span&gt;
    &lt;p&gt;第3个p&lt;/p&gt;
    &lt;span&gt;第2个span&lt;/span&gt;
    &lt;p&gt;第4个p&lt;/p&gt;
    &lt;p&gt;第5个p&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<pre><code>p:nth-child(3) {
    color:red;
}
</code></pre>

<p>▲ 如果使用<code>:nth-child(3)</code>你会发现第3个<code>p</code>元素文本并没有变成红色。就像我们之前说的，如果第n个子元素不是E，则是无效选择符，但n会递增。</p>

<pre><code>p:nth-of-type(3) {
    color:red;
}
</code></pre>

<p>▲ 但是使用<code>:nth-of-type(3)</code>后会发现第3个<code>p</code>元素文本被设置为红色。</p>

<p><strong><code>E:only-child</code> 和 <code>E:only-of-type</code></strong><br><code>E:only-child</code>用来匹配父元素仅有的一个子元素E，而<code>E:only-of-type</code>是表示一个元素它有很多个子元素，但是只会匹配其中只有一个子元素的元素，说起来有点绕口，来个栗子</p>

<p><strong>HTML</strong></p>

<pre><code>&lt;div&gt;
    &lt;p&gt;段落&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;div&gt;容器&lt;/div&gt;
    &lt;p&gt;段落&lt;/p&gt;
    &lt;div&gt;容器&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<pre><code>p:only-child {
    color: red;
}
</code></pre>

<p>▲ 将会对第1个<code>div</code>元素下的<code>p</code>元素文本设置成红色。</p>

<pre><code>p:only-of-type {
    color: red;
}
</code></pre>

<p>▲ 不仅会第1个<code>div</code>元素下的<code>p</code>元素文本设置成红色，也会对第2个<code>div</code>元素下的<code>p</code>元素文本设置成红色，因为它是p元素中唯一的一个同级兄弟元素。</p>

&lt;iframe width="100%" height="300" src="//jsfiddle.net/Alsiso/15h4ozee/embedded/" allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;

<p><strong><code>E:empty</code></strong><br><code>E:empty</code>是用来选择没有任何内容的元素，包括text节点，也就是意味着连一个空格都不能有</p>

<p><strong>HTML</strong></p>

<pre><code>&lt;div&gt;
    &lt;p&gt; &lt;/p&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p><strong>CSS</strong></p>

<pre><code>p:empty {
    height: 100px;
}
</code></pre>

<p>▲ 将会对第2个空元素<code>p</code>设置一个高度，为什么第一个会失效呢，因为该容器里面有一个空格。</p>

<h3>否定类</h3>

<p><code>E:not(s)</code>用于匹配不含有s选择符的元素E，说起来不好理解，那么说一个最常用的开发场景，假如我们要对<code>ul</code>元素下的所有<code>li</code>都加上一个下边框用于内容分割，但是最后一个不需要，如下：</p>

<p><strong>HTML</strong></p>

<pre><code>&lt;ul&gt;
    &lt;li&gt;列表1&lt;/li&gt;
    &lt;li&gt;列表2&lt;/li&gt;
    &lt;li&gt;列表3&lt;/li&gt;
    &lt;li&gt;列表4&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p><strong>CSS</strong></p>

<pre><code>ul li:not(:last-child) {
    border-bottom: 1px solid #ddd;
}
</code></pre>

<p>▲ 将会对列表中除最后一项外的所有列表项添加一条下边框</p>

<h2>伪元素选择器</h2>

<ul>
<li>
<code>E:first-letter</code> 选择文本块的第一个字母</li>
<li>
<code>E:first-line</code> 选择元素的第一行</li>
<li>
<code>E:before</code> 在元素前面插入内容，配合"content"使用</li>
<li>
<code>E:after</code> 在元素后面插入内容，配合"content"使用</li>
</ul>
<p>以上四个伪元素选择器在CSS2.1都已经被支持，但在CSS3中将伪元素选择符前面的单个冒号(:)修改为双冒号(::)，如<code>E::first-letter</code>、<code>E::first-line</code>、<code>E::before</code>、<code>E::after</code>，不过之前的单冒号写法也是有效的。</p>

<h3>E::first-letter 和 E::first-line</h3>

<pre><code>p::first-letter {
    font-weight:bold;    
}
</code></pre>

<p>▲ 将会对文本块的第一个字母进行加粗</p>

<pre><code>p::first-line {
    font-weight:bold;    
}
</code></pre>

<p>▲ 将会对段落的第一行文本进行加粗</p>

<h3>E::before 和 E::after</h3>

<p><code>E::before</code>和<code>E::after</code>是用来给元素的前面和后面差入内容，配合"content"使用，但它必须有值才能生效。</p>

<p><strong>HTML</strong></p>

<pre><code>&lt;div&gt;me&lt;/div&gt;
</code></pre>

<p><strong>CSS</strong></p>

<pre><code>div:before{
    content:'you before'; 
    color:red;
}
div:after{
    content:'you after'; 
    color:green;
}
</code></pre>

<p>▲ 将会在<code>div</code>容器中的文本<code>me</code>加上添加后的内容并设置其颜色</p>

<h3>E::placeholder和 E::selection</h3>

<ul>
<li>
<code>E::placeholder</code> 选择文本块的第一个字母</li>
<li>
<code>E::selection</code> 选择文本块的第一个字母</li>
</ul>
<p><code>E::placeholder</code>用于设置对象文字占位符的样式，但是每个浏览器的CSS选择器都有所差异，需要针对每个浏览器做单独的设定，举个例子看代码</p>

<pre><code>::-webkit-input-placeholder { /* WebKit browsers */
    color:    #999;
}
:-moz-placeholder { /* Mozilla Firefox 4 to 18 */
    color:    #999;
}
::-moz-placeholder { /* Mozilla Firefox 19+ */
    color:    #999;
}
:-ms-input-placeholder { /* Internet Explorer 10+ */
    color:    #999;
}
</code></pre>

<p><code>E::selection</code>用于设置文本被选择时的样式，被定义的样式属性有3个，而且使用时需要对火狐浏览器单独设置。</p>

<pre><code>p::-moz-selection{
    background:#000;
    color:#f00;
    text-shadow:1px 1px rgba(0,0,0,.3);
}
p::selection{
    background:#000;
    color:#f00;
    text-shadow:1px 1px rgba(0,0,0,.3);
}
</code></pre>

<h2>第四代选择器</h2>

<h3>发展历史</h3>

<p>自从<strong>哈坤·利</strong>提出CSS建议到1996年CSS1.0问世，距离今天已经有20个年头。<br>
不过CSS的发展一直在持续，1997年组织了专门管CSS的工作组，并在1998年发布了CSS2.0，之后发布了修订版本的CSS2.1。</p>

<p><strong>CSS2.1</strong> 是我们一直再用的，也是浏览器支持较为完整的一个版本。</p>

<p>CSS3 的开发工作早在2001年以前就启动了，不过发展到今天，大多数的现代浏览器对CSS3属性和选择器支持良好，除了一些微软IE浏览器的较老版本。</p>

<p>历史前进的步伐并不会停止的，新的CSS4也正由W3C编辑团队研发中。在CSS4中引进了许多的新变化，不过基本选择器是不会有变化的，更多的还是添加一些伪类，那么接下来一起看看增加的内容。</p>

<p>提醒：<strong>目前这些代码功能可能还在实验规范阶段，浏览器并没有得到支持，所以并不能投入使用</strong> ！</p>

<h3>升级内容</h3>

<p><strong>否定类</strong> <code>E:not(s,s,s..)</code><br><code>E:not</code>其实在选择器已经出现在CSS3了，它用于匹配不含有s选择符的元素E，上面我们讲过它的使用方法，但是它只能用于简单选择器，伪类，标签，id，类和类选择器参数。不过在CSS4中得到了升级，具体区别</p>

<pre><code>p:not(.header) { 
    font-weight: normal; 
}  
</code></pre>

<p>▲ <strong>CSS3</strong>将会对除了<code>.header</code>类以外的文本加粗</p>

<pre><code>p:not(.header, .footer) { 
    font-weight: normal; 
}  
</code></pre>

<p>▲ <strong>CSS4</strong>通过传入一个用逗号，将会对除了<code>.header</code>和<code>.footer</code>类以外的文本加粗</p>

<p><strong>关联类</strong> <code>E:has(s)</code><br>
这个选择器通过一个参数（选择符），去匹配与某一元素对应的任意选择器，举个例子</p>

<pre><code>a:has(&gt;img) {  
    border: 1px solid #000; 
}  
</code></pre>

<p>▲ 将会对所有带有<code>img</code>元素的<code>a</code>元素加个黑色的边框</p>

<p><strong>匹配任何伪类<code>E:matches</code></strong><br>
这个伪类选择器可以规则运用在所有的选择器组中，它能帮我们简写多组选择器的规则，例子说明，</p>

<pre><code>&lt;section&gt;
    &lt;h1&gt;标题&lt;/h1&gt;
&lt;/section&gt;
&lt;nav&gt;
    &lt;h1&gt;标题&lt;/h1&gt;
&lt;/nav&gt;
</code></pre>

<p>▲ 上面的两个容器都有一个<code>h1标题元素，如何对容器下的</code>h1`字体进行字体颜色设置呢</p>

<pre><code>section h1,nav h1{
    color:red;
}

:matches(section, nav) h1 {
    color: red;
}
</code></pre>

<p>▲ 这一种是传统的方法，第二种就是<code>:matches</code>方法。</p>

<p><strong>位置伪类<code>E:local-link</code>和<code>E:local-link(n)</code></strong></p>

<p>位置伪类是访问者在你网站上的位置</p>

<ul>
<li>
<code>:local-link(0)</code> 代表一个超连接元素，其target和文档的URL是在同一个源中。 </li>
<li>
<code>:local-link(1)</code> 代表一个超连接元素，其target和文档的URL是在同一个源中。</li>
<li>
<code>:local-link(2)</code> 代表一个超连接元素，其target和文档的URL是在同一个源中。</li>
</ul>
<pre><code>/* 将会匹配 http://example.com/ link(s) */
:local-link(0) {
    color: red;
}

/* 将会匹配 http://example.com/year/ link(s) */
:local-link(1) {
    color: red;
}

/* 将会匹配 http://example.com/year/month/ link(s) */
:local-link(2) {
    color: red;
}
</code></pre>

<p><strong>表单状态伪类 <code>E:indeterminate</code></strong><br><code>checkbox</code>中的<code>indeterminate</code>属性用于展示半选择状态，这个属性只是改变<code>checkbox</code>的外观，不对它的<code>checked</code>属性产生影响，CSS4选择器中也增加了半选择状态的伪类。</p>

<pre><code>:indeterminate {
    opacity: 0.6;
}
</code></pre>

<p><strong>表单状态伪类 <code>E:required</code></strong>和 <code>E:optional</code><br><code>required</code>属性是HTML5新添加的，用于规定必需在提交之前填写输入字段</p>

<pre><code>:required {
    border: 1px solid red;
}
:optional {
    border: 1px solid gray;
}
</code></pre>

<pre><code>&lt;input type="text" required="required" /&gt;
&lt;input type="text" /&gt;
</code></pre>

<p>▲ 第一个设置了<code>required</code>属性的表单元素将会设置一个红色边框，而第二个没有设置该属性的，将会设置一个灰色边框。</p>

<p><strong>范围限制伪类<code>E:in-range</code>和<code>E:out-of-range</code></strong><br>
用于表单字段值范围的限制，取决于表单的<code>min</code>和<code>max</code>属性</p>

<pre><code>:in-range {
    background-color:green;
}

:out-of-range {
    background-color:red;
}
</code></pre>

<pre><code>&lt;input type="number" value="5" max="10" min="1"  /&gt;
</code></pre>

<p>▲ 如果你输入的值在设置的最小和最大值范围内，那么表单背景会呈现为绿色，如果超出了限制，那么会呈现为红色。</p>

<p>关于更多的CSS4选择器，可参考这里的 <a rel="nofollow" href="http://css4-selectors.com/selectors/">示例介绍</a>。</p>