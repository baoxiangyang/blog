<blockquote><p>原文链接：<a href="http://ipestov.com/22-essential-css-recipes/">22 Essential CSS Recipes</a><br>更多译文将陆续推出，欢迎点赞+收藏+关注<a href="https://segmentfault.com/blog/jrain">我的专栏</a>，未完待续……</p></blockquote>
<hr>
<p>大家好，今天我们将会介绍一些非常实用的CSS小技巧，让我们开始吧！</p>
<h2>混合模式</h2>
<p><img data-src="/img/bVyLrB" src="/img/bVyLrB.jpeg"><br>不久之前Firefox和Safari浏览器已经开始支持类似Photoshop的混合模式，但是在Chrome和Opera浏览器中需要添加前缀。举个栗子：</p>
<pre><code>// 你也可以尝试不同的样式

.blend {
    background: #fff;
}
.blend img {
    mix-blend-mode: darken; 
}</code></pre>
<p><a href="http://ilyashubin.github.io/FilterBlend/">在线体验地址</a></p>
<h2>渐变边框</h2>
<p><img data-src="/img/bVyLsh" src="/img/bVyLsh.jpeg"><br>现在，你甚至可以在边框中使用渐变。<br>要使用渐变边框非常简单，只需要设置一个更低<code>z-index</code>的伪元素即可：</p>
<pre><code>.box {
  margin: 80px 30px;
  width: 200px;
  height: 200px;
  position: relative;
  background: #fff;
  float: left;
}
.box:before {
      content: '';
      z-index: -1;
      position: absolute;
      width: 220px;
      height: 220px;
      top: -10px;
      left: -10px;
      background-image: linear-gradient(90deg, yellow, gold);
}</code></pre>
<p>具体的例子可以看<a href="https://jsfiddle.net/4qypuono/">这里</a>，或者看<a href="http://codepen.io/anon/pen/jEOGJe">这里</a>使用的是<code>background-clip</code>和<code>background-origin</code>属性。在不久的将来，也许所有浏览器都将支持<code>border-image</code>属性，最终的代码会和下面一样：</p>
<pre><code>.box {
    border-image: linear-gradient(to bottom, #000000 0%, #FFFFFF 100%); 
    border-image-slice: 1; /* set internal offset */
}</code></pre>
<h2>z-index的过渡</h2>
<p><img data-src="/img/bVyLs1" src="/img/bVyLs1.gif"><br>也许你不知道<code>z-index</code>同样支持过渡！在过渡的每一步中，它的值都不发生改变，所以你以为它不支持过渡——但其实它支持。<br><a href="http://zomigi.com/demo/z-index_transition.html">举个栗子</a></p>
<h2>currentColor</h2>
<p>我们可以使用这个方法来侦测当前的颜色，以避免经常地重复定义它。<br>这个方法在使用SVG图标的时候非常有用，因为它们的颜色由其父元素决定。通常我们是这么做的：</p>
<pre><code>.button {
  color: black;
}
.button:hover {
  color: red;
}
.button:active {
  color: green;
}

.button svg {
  fill: black;
}
.button:hover svg {
  fill: red;
}
.button:active svg {
  fill: green;
}</code></pre>
<p>但我们可以使用<code>currentColor</code>这么做：</p>
<pre><code>svg {  
  fill: currentColor;
}

.button {
  color: black;
  border: 1px solid currentColor;
}
.button:hover {
  color: red;
}
.button:active {
  color: green;
}</code></pre>
<p>附上其它带有伪元素的例子：</p>
<pre><code>a {  
  color: #000;
}
a:hover {  
  color: #333;
}
a:active {  
  color: #666;
}

a:after,  
a:hover:after,  
a:active:after {  
  background: currentColor;
  ...
}</code></pre>
<h2>Object Fit</h2>
<p>你是否还记得为了解决一些问题而给一幅背景图设置<code>background-size</code>属性的时刻呢？现在你可以使用<code>object-fit</code>属性啦，webkit浏览器都支持它，Firefox也将在近期予以支持。</p>
<pre><code>.image__contain {
  object-fit: contain; 
} 
.image__fill {
  object-fit: fill; 
}
.image__cover {
  object-fit: cover; 
}
.image__scale-down {
  object-fit: scale-down;
}</code></pre>
<p><img data-src="/img/bVyLvK" src="/img/bVyLvK.jpeg"><br><a href="http://codepen.io/CSSKing/pen/XJEZeG">举个栗子</a></p>
<h2>单选框和复选框的样式</h2>
<p>让我们一起不使用图片来设置复选框的样式：</p>
<pre><code>&lt;!-- html --&gt;
&lt;input type="checkbox" id="check" name="check" /&gt;
&lt;label for="check"&gt;Checkbox&lt;/label&gt;</code></pre>
<pre><code>&lt;!-- css --&gt;
input[type=checkbox] {display: none;}

input[type=checkbox] + label:before {  
    content: "";
    border: 1px solid #000;
    font-size: 11px;    
    line-height: 10px;
    margin: 0 5px 0 0;
    height: 10px;
    width: 10px;
    text-align: center;
    vertical-align: middle;
}

input[type=checkbox]:checked + label:before {  
    content: "\2713";
}</code></pre>
<p><img data-src="/img/bVyLvZ" src="/img/bVyLvZ.jpeg"><br>正如你所看见的，我们隐藏了原有的复选框，改为使用伪元素和伪类<code>:checked</code>（IE9+）来表现它。当它被选中时，一个设置在<code>content</code>里的Unicode编码的字符将会显示出来。</p>
<blockquote><p>值得注意的是，Unicode编码在CSS和HTML中的写法是不一样的。在CSS中它是一个以反斜杠为开始的十六进制数，而在HTML中它是十进制的，比如<code>&amp;#10003;</code>。<br>接着为我们的复选框添加一些动画效果：</p></blockquote>
<pre><code>&lt;!-- checkbox --&gt;
input[type=checkbox] + label:before {  
    content: "\2713";
    color: transparent;
    transition: color ease .3s;
}
input[type=checkbox]:checked + label:before {  
    color: #000;
}

&lt;!-- radio --&gt;
input[type=radio] + label:before {  
    content: "\26AB";
    border: 1px solid #000;
    border-radius: 50%;
    font-size: 0;    
    transition: font-size ease .3s;
}
input[type=radio]:checked + label:before {  
    font-size: 10px;    
}</code></pre>
<p><img data-src="/img/bVyLwH" src="/img/bVyLwH.gif"><br><a href="http://unicode-table.com/en/">这里</a>是所有的Unicode编码，以及可以在<a href="http://codepen.io/anon/pen/CdzwB">这里</a>进行体验。</p>
<h2>CSS中的计数器</h2>
<p>总所周知CSS中是可以使用计数器的：</p>
<pre><code>&lt;!-- html --&gt;
&lt;ol class="list"&gt;  
    &lt;li&gt;a&lt;/li&gt;
    &lt;li&gt;b&lt;/li&gt;
    &lt;li&gt;c&lt;/li&gt;
&lt;/ol&gt;  </code></pre>
<pre><code>&lt;!-- css --&gt;
.list {
    counter-reset: i; //reset conunter
}
.list &gt; li {
    counter-increment: i; //counter ID
}
.list li:after {
    content: "[" counter(i) "]"; //print the result
}</code></pre>
<p>我们定义了一个ID在<code>counter-reset</code>属性中作为初始值（默认为0）。你可以设置另一个值在<code>counter-increment</code>属性中作为每一步的递增值。</p>
<h2>高级CSS计数器</h2>
<p>你可以计算出有多少个复选框被用户勾选了：</p>
<pre><code>&lt;!-- html --&gt;
&lt;div class="languages"&gt;  
  &lt;input id="c" type="checkbox"&gt;&lt;label for="c"&gt;C&lt;/label&gt;
  &lt;input id="C++" type="checkbox"&gt;&lt;label for="C++"&gt;C++&lt;/label&gt;
  &lt;input id="C#" type="checkbox"&gt;&lt;label for="C#"&gt;C#&lt;/label&gt;
  &lt;input id="Java" type="checkbox"&gt;&lt;label for="Java"&gt;Java&lt;/label&gt;
  &lt;input id="JavaScript" type="checkbox"&gt;&lt;label for="JavaScript"&gt;JavaScript&lt;/label&gt;
  &lt;input id="PHP" type="checkbox"&gt;&lt;label for="PHP"&gt;PHP&lt;/label&gt;
  &lt;input id="Python" type="checkbox"&gt;&lt;label for="Python"&gt;Python&lt;/label&gt;
  &lt;input id="Ruby" type="checkbox"&gt;&lt;label for="Ruby"&gt;Ruby&lt;/label&gt;
&lt;/div&gt;  
&lt;p class="total"&gt;  
  Total selected:
&lt;/p&gt;  </code></pre>
<pre><code>&lt;!-- css --&gt;
.languages {
  counter-reset: characters;
}
input:checked {  
  counter-increment: characters;
}
.total:after {
  content: counter(characters);
} </code></pre>
<p><img data-src="/img/bVyLxr" src="/img/bVyLxr.gif"></p>
<p>你也可以制作一个简单的计算器：</p>
<pre><code>&lt;!-- html --&gt;
&lt;div class="numbers"&gt;  
  &lt;input id="one" type="checkbox"&gt;&lt;label for="one"&gt;1&lt;/label&gt;
  &lt;input id="two" type="checkbox"&gt;&lt;label for="two"&gt;2&lt;/label&gt;
  &lt;input id="three" type="checkbox"&gt;&lt;label for="three"&gt;3&lt;/label&gt;
  &lt;input id="four" type="checkbox"&gt;&lt;label for="four"&gt;4&lt;/label&gt;
  &lt;input id="five" type="checkbox"&gt;&lt;label for="five"&gt;5&lt;/label&gt;
  &lt;input id="one-hundred" type="checkbox"&gt;&lt;label for="one-hundred"&gt;100&lt;/label&gt;
&lt;/div&gt;  
&lt;p class="sum"&gt;  
  Sum 
&lt;/p&gt;  </code></pre>
<pre><code>&lt;!-- css --&gt;
.numbers {
  counter-reset: sum;
}

#one:checked { counter-increment: sum 1; }
#two:checked { counter-increment: sum 2; }
#three:checked { counter-increment: sum 3; }
#four:checked { counter-increment: sum 4; }
#five:checked { counter-increment: sum 5; }
#one-hundred:checked { counter-increment: sum 100; }

.sum::after {
  content: '= ' counter(sum);
} </code></pre>
<p><img data-src="/img/bVyLxD" src="/img/bVyLxD.gif"><br>它同样得以运行，请看具体的<a href="http://codepen.io/CSSKing/pen/vEeMey">DEMO</a>和<a href="http://codersblock.com/blog/fun-times-with-css-counters/">文章</a>。</p>
<h2>不使用图片的菜单图标</h2>
<p>你记得你有多么经常被迫需要一个“汉堡”图标吗？<br><img data-src="/img/bVyLxP" src="/img/bVyLxP.jpeg"><br>这里有至少3个方式去实现它：<br>1、 Shadows</p>
<pre><code>.shadow-icon {
  position: relative;
}
.shadow-icon:after {
  content: "";
  position: absolute;
  left: 0;
  top: -50px;
  height: 100%;
  width: 100%;
  box-shadow: 0 5px 0 #000, 0 15px 0 #fff, 0 25px 0 #000, 0 35px 0 #fff, 0 45px 0 #000;
}</code></pre>
<p>2、 Gradient</p>
<pre><code>.gradient-icon {
    background: linear-gradient(to bottom, #000 0%, #000 20%, transparent 20%, transparent 40%, #000 40%, #000 60%, transparent 60%, transparent 80%, #000 80%, #000 100%);
}</code></pre>
<p>3、 UTF-8<br>你可以直接使用标准符号：☰ (Unicode: U+2630, HTML: ☰)。你也可以像其他元素那样灵活设置它的颜色或大小。看<a href="http://codepen.io/CSSKing/pen/cozBq">例子</a>。<br>你也可以使用SVG，字体图标，或者通过伪元素设置的<code>border</code>边框。</p>
<h2>@Supports</h2>
<p>这是一个新的叫做<code>supports</code>的CSS表达式。顾名思义，它可以检测某些设定是否被浏览器所支持，并非所有的浏览器都支持它，但是你仍然可以使用它作为基本的检测手段：</p>
<pre><code>@supports (display: flex) {
    div { display: flex; }
}

/*You can check prefixes*/
@supports (display: -webkit-flex) or (display: -moz-flex) or (display: flex) {
    section {
        display: -webkit-flex;
        display: -moz-flex;
        display: flex;
        float: none;
    }
}</code></pre>
<h2>visibility: visible</h2>
<p>依你估计，把一个设置为<code>visibility: visible</code>的元素放在一个设置为<code>visibility: hidden</code>的元素里面，会发生什么？</p>
<pre><code>.hidden {
  visibility: hidden;
}
.hidden .visible {
  visibility: visible;
}</code></pre>
<p>你可能会认为两个元素都不显示——然而事实上整个父元素都被隐藏了，而子元素不会。请看<a href="http://codepen.io/CSSKing/pen/lxBfk">DEMO</a>。</p>
<h2>position: sticky</h2>
<p><img data-src="/img/bVyLyJ" src="/img/bVyLyJ.gif"><br>我们发现了一个新的特性，你可以新建一个<code>sticky</code>属性的元素。它的运行效果和<code>fixed</code>相同，但不会挡住任何元素。你最好看看<a href="http://codepen.io/CSSKing/pen/yyMGPJ">例子</a><br>只有Mozilla和Safari浏览器支持这一属性，但你也可以像下面那样使用它：</p>
<pre><code>.sticky {
  position: static;
  position: sticky;
  top: 0px;
}</code></pre>
<p>我们将会在支持的浏览器中得到一个<code>sticky</code>属性的元素，而在不支持的浏览器中它将会是一个普通的元素。这在你需要建立一个不可替代的，可以移动的元素的移动端页面的时候非常实用。</p>
<h2>新的尺寸单位</h2>
<p>不久之前，一些新的用以描述不同元素大小的尺寸单位问世了，它们是：</p>
<ul>
<li><p>vw (viewport width) - 浏览器窗口宽度的1%。</p></li>
<li><p>vh (viewport height) - 同上，只不过用来描述高度。</p></li>
<li><p>vmin and vmax 设置介于vh和vw之间的最大最小值。</p></li>
</ul>
<p>有趣的是，几乎所有的现代浏览器都能很好地支持它们，所以你可以放心地使用。<br>为什么我们需要这些新的单位？因为它们可以让不同的尺寸更容易被定义，你不要为父元素指定任何的百分比或者别的什么，请看例子：</p>
<pre><code>.some-text {
    font-size: 100vh;
    line-height: 100vh;
}</code></pre>
<p><img data-src="https://imgly.net/img/G6l.gif" src="/img/G6l.gif"></p>
<p>或者你可以设置一个漂亮的弹出框在屏幕中间：</p>
<pre><code>.blackSquare {
    background: black;
    position: fixed;
    height: 50vh;
    width: 50vw;
    left: 25vw;
    top: 25vh;
}</code></pre>
<p>这看起来酷毙了，看看在codepen的<a href="http://codepen.io/CrocoDillon/pen/fBJxu">例子</a>吧~<br>但是目前仍然有一些关于这些新单位的不足之处：</p>
<ul>
<li><p>IE9应该用vm而不是vmin。</p></li>
<li><p>iOS7在使用vh的时候可能会有bug。</p></li>
<li><p>vmax至今并未得到全面的支持。</p></li>
</ul>
<h2>文字修饰</h2>
<p>我们可以通过几行代码修改文字被选中时的效果：</p>
<pre><code>*::selection {
    color: #fff;
    background: #000;
}
*::-moz-selection {    
    /*Only Firefox still needs a prefix*/
    color: #fff;
    background: #000;
}</code></pre>
<p>你不仅可以定义文字被选中时的颜色，还能定义阴影或者背景颜色。</p>
<h2>触摸屏当中的元素滚动</h2>
<p>如果你需要在触摸屏当中为一些元素设置内滚动，那么你不仅需要<code>overflow: scroll / auto </code>，还需要<code>-webkit-overflow-scrolling: touch;</code><br>实际上，移动端浏览器在某些时候并不能正确执行<code>overflow: scroll / auto </code>，它可能会滚动整个页面而不是你想要的那部分。<code>-webkit-overflow-scrolling</code>解决了这个问题，你可以在你的实际项目中体验一下。</p>
<h2>使用硬件加速</h2>
<p>有时候动画可能会导致用户的电脑卡顿，你可以在特定元素中使用硬件加速来避免这个问题：</p>
<pre><code>.block {
    transform: translateZ(0);
}</code></pre>
<p>你并不会察觉有什么不同，但浏览器会为这个元素进行3D硬件加速，在<code>will-change</code>这个特殊属性未被全面支持之前，这个方法还是很有用的。</p>
<h2>Unicode Classes</h2>
<p>你可以用Unicode符号明名class：</p>
<pre><code>.❤ {
    ...
}
.☢ {
    ...
}
.☭ {
    ...
}
.★ {
    ...
}
.☯ {
    ...
}</code></pre>
<p>但这其实是用来搞笑的，千万不要在大型项目中使用，因为不是所有的电脑都支持Unicode符号。</p>
<h2>垂直方向的百分比边距</h2>
<p>实际上垂直方向的排列计算是基于父元素的宽度而不是高度。定义两个元素：</p>
<pre><code>&lt;!-- html --&gt;

&lt;div class="parent"&gt;  
    &lt;div class="child"&gt;&lt;/div&gt;
&lt;/div&gt; </code></pre>
<pre><code>&lt;!-- css --&gt;

.parent {
    height: 400px;
    width: 200px;
}
.child {
    height: 50%;
    padding-top: 25%;
    padding-bottom: 25%;
    width: 100%;
}</code></pre>
<p>理论上，子元素的高会是父元素高的一半，但是看看我们实际得到的情况：<br><img data-src="/img/bVyLCw" src="/img/bVyLCw.jpeg"></p>
<p>记住，子元素的百分比是相对于父元素的宽度。</p>
<h2>火狐浏览器的按钮边距</h2>
<p>Firefox用它自己的方式去计算按钮的边距。这听起来有点奇怪，但它会自动地添加一些边距进去：<br><img data-src="/img/bVyLC0" src="/img/bVyLC0.jpeg"></p>
<p>可以用以下方法来修复这个问题：</p>
<pre><code>button::-moz-focus-inner,  
input[type="reset"]::-moz-focus-inner,  
input[type="button"]::-moz-focus-inner,  
input[type="submit"]::-moz-focus-inner {  
    border: none;
    padding:0;
}</code></pre>
<h2>Color + Border = <code>Border-Color</code>
</h2>
<p>很少人知道，定义了一个元素的文字颜色，意味着这个元素的边框颜色也被定义了：</p>
<pre><code>input[type="text"] {  
    color: red;
    border: 1px solid;
}</code></pre>
<p><img data-src="/img/bVyLDm" src="/img/bVyLDm.gif"></p>
<h2>古老浏览器的彩蛋</h2>
<p>如果你仍需要适配IE7或者类似的古老浏览器，你可以在定义hack的时候使用笑脸符号，像这样：</p>
<pre><code>body {  
    :) background: pink;
}</code></pre>
<p>是不是很有趣？</p>
<hr>
<blockquote><p>如果你觉得我翻译得不错，请点赞收藏并关注<a href="https://segmentfault.com/blog/jrain">我的专栏</a>，我会陆续推出更多精彩的内容。如发现任何的错漏欢迎指正，我们下次见！</p></blockquote>