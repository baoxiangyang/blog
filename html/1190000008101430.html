>
<p>不知道各位旁友在<code>webpack</code>的使用中，有没有碰到下面的问题情景：</p>
<ol><li><p>在使用了<code>css Module</code>的情况下，同时又希望用一些<code>global</code>的布局，其实在<code>css Module</code>中直接用</p></li></ol>
<pre><code>:global(.title) {
    color: green;
}</code></pre>
<p>也是可以实现的，但是如果需要引入第三方css，如<code>Animate.css</code>，如果对每一个<code>classname</code>都进行手动的全局定义，工作量可不小。</p>
<ol><li><p>关于<code>css</code>的打包问题，对于一些组件的样式，可以将<code>css</code>打包在<code>js</code>文件中，但是一些全局的<code>css</code>，或者一些需要第一时间加载的<code>css</code> (如<code>pace.css</code>，在页面加载过程中就需要第一时间解析出样式)，就需要使用<code>ExtractTextPlugin</code>打包成为单独的<code>css</code>文件了。</p></li></ol>
<p>以上都是需要对于同一类型文件的不同处理。在<code>webpack</code>中就体现成用正则表达式进行文件名匹配。</p>
<p>为了更优雅的命名，第一种情景来举例，我将全局的样式文件命名成<code>foo.global.less</code>，其他需要进行<code>css module</code>处理的则正常命名，如<code>bar.less</code>。</p>
<h2>思路</h2>
<p>在进入主题之前，我先分享一个实用的在线正则网站<a href="http://refiddle.com/">refiddle</a>，包含了不仅仅<code>Javascript</code>的正则</p>
<p>下面的重头戏便是  <br><strong>如何正则匹配<code>*.global.less</code>和<code>*.less</code>(不包括<code>*.global.less</code>)？</strong></p>
<p>众所周知，<code>webpack</code>中是不存在多次正则匹配的，所以需要分别使用2个正则表达式来解决上面两种字符串的匹配。</p>
<p><code>*.global.less</code>字符串匹配？恩, so easy，<code>/\.global\.less$/</code>, 那么<code>*.less</code>(不包括<code>*.global.less</code>)呢？</p>
<p>显然，这就需要用到正则的位置匹配了(<code>(^\.global)</code>和<code>[^\.global]</code>都是不正确的)，匹配前面不是<code>.global</code>的的位置。</p>
<table>
<thead><tr>
<th>分类</th>
<th>语法</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>捕获</td>
<td><code>(exp)</code></td>
<td>匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td>捕获</td>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)</td>
</tr>
<tr>
<td>捕获</td>
<td><code>(?:exp)</code></td>
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td>位置匹配</td>
<td><code>(?=exp)</code></td>
<td>匹配exp前面的位置</td>
</tr>
<tr>
<td>位置匹配</td>
<td><code>(?&lt;=exp)</code></td>
<td>匹配exp后面的位置</td>
</tr>
<tr>
<td>位置匹配</td>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td>位置匹配</td>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是exp的位置</td>
</tr>
<tr>
<td>注释</td>
<td><code>(?#comment)</code></td>
<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody>
</table>
<p>如上表，很显然需要使用<code>(?&lt;!exp)</code>，所以正则表达式是<code>/(?&lt;!global)\.less$/</code>，完结撒花！</p>
<p>但是！真的就这样可以了吗？？很不幸的是在js中并没有实现<code>(?&lt;=exp)</code>和<code>(?&lt;!exp)</code>的位置匹配。（可能是大家伙都没想到Js能走到今天这个地步，以为只是在浏览器上耍耍，数据验证没必要太复杂吧, 😆 ）  <br>参看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>.</p>
<p>经过一番查找和头脑风暴，最终得到了Js中不包含某子串的正则匹配  <br><strong><code>/^(.(?!\.global))+\.less$/</code></strong></p>
<p><code>(?!\.global)</code>匹配的是后面不是<code>.global</code>的位置  <br><code>(.(?!\.global))+</code>匹配的就是若干个后面跟着不是<code>.global</code>的字符  <br><code>^</code>字符串首位置不能丢！，如果丢了，<code>/(.(?!\.global))+\.less$/</code>也能够匹配<code>foo.global.less</code>，因为从<code>foo</code>后面的<code>.</code>开始，后面跟着的就不是<code>.global</code>了。</p>
<p>但是对于<code>.global.less</code>字符串，该正则也无能为力了。</p>
<h2>参考</h2>
<ol>
<li><p><a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></p></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">JavaScript RegExp</a></p></li>
<li><p><a href="http://www.cnblogs.com/bvbook/archive/2010/11/03/1867775.html">正则表达式匹配“不包含某个字符串” (通俗易懂还有图！)</a><