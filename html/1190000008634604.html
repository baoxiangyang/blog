脚本？</h2>
<p>在package.json文件里面，使用scripts字段定义的脚本命令</p>
<pre><code>{
  // ...
  "scripts": {
    "build": "node build.js"
  }
}</code></pre>
<h2>如何执行是 npm 脚本？</h2>
<pre><code>$ npm run build
# 等同于执行
$ node build.js</code></pre>
<h2>不知道有什么 npm 脚本？？</h2>
<pre><code>#查看当前项目的所有 npm 脚本命令
#(其实也可以在package.json的看scripts对象里有什么属性)
npm run</code></pre>
<h2>npm的原理？？</h2>
<blockquote>
<p>每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。<br>因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>
<p>比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。</p>
<p>由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。</p>
</blockquote>
<h2>通配符&amp;转义</h2>
<p>同shell</p>
<pre><code>// *表示任意文件名，**表示任意一层子目录
"lint": "jshint *.js"
"lint": "jshint **/*.js"
// 将通配符传入原始命令，防止被 Shell 转义，要将星号转义
"test": "tap test/\*.js"</code></pre>
<h2>传参</h2>
<p>向 npm 脚本传入参数，要使用--标明</p>
<pre><code># package.json
"deploy": "gulp deploy",
# 命令行
$ npm run deploy -- --test</code></pre>
<h2>一个命令执行多个任务？？</h2>
<pre><code>#并行执行（即同时的平行执行），使用&amp;符号
$ npm run serve &amp; npm run dev
#继发执行（即只有前一个任务成功，才执行下一个任务），使用&amp;&amp;符号
$ npm run build &amp;&amp; npm run deploy</code></pre>
<h2>默认脚本</h2>
<p>不用定义，就可以直接使用(前提是项目根目录下有server.js脚本和rebuild文件)</p>
<pre><code>"start": "node server.js"，
"install": "node-gyp rebuild"</code></pre>
<h2>钩子</h2>
<p>npm 脚本有pre和post两个钩子</p>
<p><strong>例子</strong></p>
<pre><code># package.json
"prebuild": "echo I run before the build script",
"build": "cross-env NODE_ENV=production webpack",
"postbuild": "echo I run after the build script",
# 命令行
$ npm run build
# 等同于执行
$ npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild</code></pre>
<blockquote><p>自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。</p></blockquote>
<p><strong>默认的钩子</strong></p>
<pre><code>prepublish，postpublish
preinstall，postinstall
preuninstall，postuninstall
preversion，postversion
pretest，posttest
prestop，poststop
prestart，poststart
prerestart，postrestart</code></pre>
<p><strong>npm_lifecycle_event变量</strong> (返回当前正在运行的脚本名称,pretest、test、posttest)</p>
<pre><code>#利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码
const TARGET = process.env.npm_lifecycle_event;

if (TARGET === 'test') {
  console.log(`Running the test task!`);
}

if (TARGET === 'pretest') {
  console.log(`Running the pretest task!`);
}

if (TARGET === 'posttest') {
  console.log(`Running the posttest task!`);
}</code></pre>
<blockquote><p>注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。</p></blockquote>
<h2>简写</h2>
<ul>
<li><p>npm start是npm run start的简写</p></li>
<li><p>npm stop是npm run stop的简写</p></li>
<li><p>npm test是npm run test的简写</p></li>
<li><p>npm restart是npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写</p></li>
</ul>
<p>执行顺序<br>1 prerestart<br>2 prestop<br>3 stop<br>4 poststop<br>5 restart<br>6 prestart<br>7 start<br>8 poststart<br>9 postrestart</p>
<h2>npm 的内部变量</h2>
<p>通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段<br>(如果是 Bash 脚本，可以用$npm_package_前缀取值)</p>
<pre><code>// package.json
{
  "name": "foo", 
  "version": "1.2.5",
  "config" : { "port" : "8080" },
  "scripts": {
    "view": "node view.js",
    "start" : "node server.js"
  }
}

// view.js
console.log(process.env.npm_package_name); // foo
console.log(process.env.npm_package_version_view); // node view.js</code></pre>
<p>npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。<br>比如，当前模块的发行标签，可以通过npm_config_tag取到。</p>
<pre><code>"view": "echo $npm_config_tag",</code></pre>
<p><strong>注意</strong> package.json里面的config对象，可以被环境变量覆盖。</p>
<pre><code>$ npm config set foo:port 80</code></pre>
<h2>列出所有环境变量</h2>
<pre><code>"env": "env"</code></pre>
<h2>常用脚本示例</h2>
<pre><code>// 删除目录
"clean": "rimraf dist/*",

// 本地搭建一个 HTTP 服务
"serve": "http-server -p 9090 dist/",

// 打开浏览器
"open:dev": "opener http://localhost:9090",

// 实时刷新
 "livereload": "live-reload --port 9091 dist/",

// 构建 HTML 文件
"build:html": "jade index.jade &gt; dist/index.html",

// 只要 CSS 文件有变动，就重新执行构建
"watch:css": "watch 'npm run build:css' assets/styles/",

// 只要 HTML 文件有变动，就重新执行构建
"watch:html": "watch 'npm run build:html' assets/html",

// 部署到 Amazon S3
"deploy:prod": "s3-cli sync ./dist/ s3://example-com/prod-site/",

// 构建 favicon
"build:favicon": "node scripts/favicon.js"