>
<p>最近几年，前端发展越来越迅速，各种萌新加入了前端这个大家庭，大有赶IOS、超Android的趋势呀！同时，萌新们提出了各种前端工作问题，除了最基础的html、css、js三板斧之外，最让人头疼的应该是关于环境的配置问题，所以以环境作为切入点，开始一系列的前端开发环境配置文章。</p>
<p>主要会涉及到打包、构建、编程工具、debug等等前端环境，以及前后端分离、Nodejs中间层使用伸展面。</p>
<h2>工欲善其事必先利其器</h2>
<p>以编程工具而言WebStorm、sublime、Atom、VS Code、Brackets等等一大推，这方面我个人是觉得无所谓，萝卜青菜各有所爱，优缺点基本很明显，就看个人的接受情况了，举点例子说下吧：</p>
<ul>
<li><p>WebStorm 很全面，无论是纯前端还是Nodejs，包括git、svn、命令行、格式化工具都有，使用顺手之后各种方便，而且还直接支持nodejs的debug，作为前端的全能重量级IDE非常不错，唯一不好的就是太重，体现在内存占有，启动时间上。</p></li>
<li><p>sublime 轻量级文本编辑器，3比较2来说有很大提升，小巧灵活是最大的特点，麻烦的是各种插件的配置，需要自己来组合，不熟悉的人用起来远远不想WebStorm方便，快捷。而且每次新的电脑都要配置一次，比较繁琐。（现在有可以导出配置文件来适用新电脑的方法）</p></li>
<li><p>Atom类似sublime，比较轻量级，内核主要是Nodejs写出来的，前端各种爱，因为比较适合前端的技术栈，但是大文件的性能问题一直受人诟病，不是很流畅，还有就是插件比起sublime来说还是少了不少，整个生态不如sublime，但是因为是github出的，还是受人青睐不少。<a href="https://atom.io/packages/vue-format">我贡献的一个vue格式化插件</a></p></li>
<li><p>VS Code 和 Brackets这两个比较小众，使用的很少，我用过VS，感觉还挺不错，就是生态更差，而且很多插件的说明写的很糟糕，让人看不懂。各方面的资料也比较少。Brackets 一个同事使用过，提示比较好，个人感觉入门很不错。貌似还能及时浏览web效果。</p></li>
</ul>
<p>个人建议使用入门的时候使用sublime或者Atom就可以，配置一下自己喜欢的插件，基本就可以开始干活了，当然如果是用eclipse已经很习惯的人，我觉得WebStorm这种重型机枪，可能更适合你。不要对工具的提示产生依赖太过于严重，否则很多东西自己会慢慢遗忘的哦！！！</p>
<p>PS：如果要提升自己的逼格怎么办？请使用VIM或者Emacs这种高逼格的编辑方法。</p>
<h2>木牛流马</h2>
<p>粮草生产的快，也要有好的运输工具才能上到前线，对于前端而言，属于我们的运输工具是打包构建工具。</p>
<p>打包构建工具经历了各种不同的时代，从服务端主宰的打包构建，到现在前端自己主宰的构建工具，不同的需求产生了各种不同的构建工具，这些工具其实也算前端的工作能力之一，因为每一种新的工具都有优缺点，熟悉的使用也并非特别简单的事情。</p>
<p>先来说说都有哪些不同的种类吧：</p>
<ul>
<li><p>后端为主要的整体打包工具，这个以FIS作为代表，大家或多或少都应该知道百度出的这个开源打包构建工具链，从整体上解决了前端工程的问题，包括优化、资源加载、模块打包、自动化、部署一系列问题，从功能上看非常全面，FIS3的升级让人也感觉很是不错，不再依赖PHP和java之类的服务端语言，基于Nodejs来做，更加贴近前端社区。那么缺点是什么呢： 生态环境不够丰富，主要插件应该还是百度自己人提供的，参与进来的社区人数不够多。我觉得这方面的原因是fis2当时对PHP和JAVA的依赖，导致大家对fis的兴趣不弄，错过了最佳时机，这个其实跟百度自己的web的技术栈有很大关系。同时带来的好处是，FIS可以结合PHP做整体网站的部署和构建。以上主要是看文档的一些分析，本人并没有用过FIS，有说错请拍砖。这类的打包构建工具还有很多，大部分都是大公司的内部使用，例如京东、马蜂窝之类，都是PHP为主，加上前端的整体构建工具。</p></li>
<li><p>Grunt派系，这个应该是比较早的Nodejs打包构建工具，一度很是流行，Grunt的好处是提供了一个核心的构建规范，基于文件，来使用各种Grunt的插件组合整个构建行为，当时我记得比较清楚的是我前面文章提到过的Yeoman这个构建工具，核心就是Grunt，自动生成了各种插件配置。但是这个有很大的缺点：一是构建的配置文件写的很长很啰嗦，二是效率不是很高，原因是它构建的方式基于文件的，每次都会产生新的临时文件，这样无形中就会有磁盘的I/O读写，所以会降低整体的构建速度。</p></li>
<li><p>Gulp新体系，因为以上的Grunt的缺点，Gulp应运而生，借鉴了Unix的管道概念，用Nodejs的stream特性，来组织整个构建链条，在官方的核心只提供几个方法，大家基于官方API来编写自己需要的处理插件，再组合起来，完成构建功能。和Grunt的基本理念很像，但是很多又有区分，例如：配置和运行分离，插件单一职责，规定大于配置等等。关于这两个的比较有很多，大家可以搜搜Grunt Gulp 就知道了。不多说</p></li>
<li><p>新的王者Webpack，个人感觉应该是15年上半年到16年初，Webpack横空出世，大有一举统一整个前端构建生态的趋势，貌似现在FE们不会点Webpack相关的，都不好意思说自己是前端了。最初Webpack应该只是和requirejs、browserify之类模块化工具比对，但是其灵活的API和丰富的loader，致使它可以连带完成Gulp之类的构建事件，目前其生态环境巨好，各种插件层出不穷，比较火的React，vuejs等都有相关的针对性loader来优化构建方式，可以说是目前最流行的工具。不过缺点也特别的明显，就是难懂，主要是过于灵活，各种方式都能接受，导致没有一个统一的标准，配置起来特别难受，在群里，一般对于Webpack的配置问题的是最多的。很多新手对于Webpack的各种配置错误，感觉都欲哭无泪，想死的心都有了。相关的文章也很多，推荐题叶的入门指南。</p></li>
<li><p>逼格提升的NPM构建方式。这个阮一峰对于前端构建的变化吐槽过，说新的构建工具就是ES6的构建工具。推荐看贺师俊的答案<a href="https://www.zhihu.com/question/34449620/answer/79028575">如何评价阮一峰关于前端工具变化快的言论？</a></p></li>
</ul>
<p>就我个人而言，目前主要还是使用的Webpack来构建，当然一些比较老的系统代码，由于历史原因，还是使用的Gulp来构建，也有正在切换之中的，Gulp+Webpack。比较丰富多彩（其实有点混乱）。</p>
<h2>三只松鼠--干货</h2>
<pre><code>
var gulp = require('gulp');
var less = require('gulp-less');
var plugins = require('gulp-load-plugins')();
var pngquant = require('imagemin-pngquant');


gulp.task('default', function(){
    gulp.src('less/zhanzhao.less').pipe(less()).pipe(gulp.dest('css/'));
    gulp.src('less/liuqian.less').pipe(less()).pipe(gulp.dest('css/'));
    gulp.src('less/student.less').pipe(less()).pipe(gulp.dest('css/'));
    return gulp.src('less/company.less').pipe(less()).pipe(gulp.dest('css/'));
});

gulp.task('clean',function(){
    return gulp.src('publish/').pipe(plugins.clean());
});


gulp.task('bulid', ['clean'],function(){
  gulp.src('favicon.ico').pipe(gulp.dest('publish/'));
    gulp.src('download/**/*').pipe(gulp.dest('publish/download/'));
    gulp.src('mail/**/*').pipe(gulp.dest('publish/mail/'));
    gulp.src('statement/**/*').pipe(gulp.dest('publish/statement/'));
    gulp.src('template/**/*').pipe(gulp.dest('publish/template/'));
  gulp.src('css/**/*.css').pipe(plugins.minifyCss()).pipe(gulp.dest('publish/css/'));
    gulp.src('scripts/**/*.js').pipe(plugins.uglify()).pipe(gulp.dest('publish/scripts/'));
  return gulp.src('images/**/*').pipe(plugins.cache(plugins.imagemin({
            optimizationLevel: 5,
            progressive: true,
            svgoPlugins: [{removeViewBox: false}],
            use: [pngquant()]
        }))).pipe(gulp.dest('publish/images/'));
});

gulp.task("revision",['bulid'],function(){
  gulp.src(['template/head-js.html', 'template/baidu.html']).pipe(plugins.concat('head-js.html')).pipe(gulp.dest('publish/template/'));

  return gulp.src(['publish/css/*.css','publish/scripts/config.js','publish/images/**/*'],{base: 'publish'})
        .pipe(plugins.rev())
        .pipe(gulp.dest('publish/'))
        .pipe(plugins.rev.manifest({
          merge: true
        }))
        .pipe(gulp.dest('publish/'));
});


gulp.task("publish", ["revision"],function(){
  var manifestCss = gulp.src("publish/rev-manifest.json"),
      manifestDownload = gulp.src("publish/rev-manifest.json"),
      manifest = gulp.src("publish/rev-manifest.json");

  gulp.src('publish/css/*.css')
    .pipe(plugins.revReplace({manifest: manifest}))
    .pipe(gulp.dest('publish/css/'));
 
  gulp.src('*.html')
    .pipe(plugins.revReplace({manifest: manifestCss}))
    .pipe(gulp.dest('publish/'));

  gulp.src('publish/download/*.html')
    .pipe(plugins.revReplace({manifest: manifestDownload}))
    .pipe(gulp.dest('publish/download/'));
});
</code></pre>
<p>上面是我曾经自己配置的一个打包构建gulpfile，里面做了上述我提到的所有事情，除了js模块化打包之外，这个大家可以自己研究下，比较简单。我来解释下各个任务的作用。</p>
<ul>
<li><p>default， 主要是监听less变化生成css。</p></li>
<li><p>clean， 清除掉publish文件夹的内容</p></li>
<li><p>bulid，把源码移动到publish文件夹下面，对于一些类型的文件做处理，例如css的压缩，js的压缩，图片的压缩缓存等等。</p></li>
<li><p>revision，md5文件，根据html，css的引用来给相关的文件添加md5戳，生成新的md5戳文件，来保持文件更新。</p></li>
<li><p>publish，根据上面 revision生成的新的md5文件来做一次文件替换，替换里面js，css，image的引用路径。</p></li>
</ul>
<p>其实有些地方可以优化的，这个大家有时间可以自己去试试。</p>
<p>以上就是这个系列的第一篇文章，欢迎吐槽和讨论各种问题，第二篇文章会以Webpack为主，