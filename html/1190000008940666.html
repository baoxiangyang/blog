个有意思的东西，它可以改变函数调用时this的值。而我们知道，在函数里，this指向了调用这个函数的环境对象，比如一道经典面试题：</p>
<pre><code>var obj = {
  num: 1,
  show: function () {
    console.log(this.num)
  }
};
var foo = obj.show;
obj.show();/* show是被obj调用的，所以this指向obj */
foo();/* 相当于global.foo(),所以this指向global，如果在浏览器里global就是window */</code></pre>
<p><strong>换句话说，如果一个对象obj上有方法foo，你可以通过<code>obj.foo()</code>调用；如果没有，<code>obj.foo()</code>是会报错的，但是，使用<code>foo.call(obj)</code>，可以强行达到<code>obj.foo()</code>的效果。</strong></p>
<p><code>Array.prototype.slice.call</code>的用处就是这样，可以在array-like（类数组，就是长得像数组，但不是数组）的对象上强行使用slice方法，比如：<code>Array.prototype.slice.call(arguments)</code>就是把<code>arguments</code>对象转化为数组。当然，除了<code>arguments</code>，我们还能在<code>HTMLCollection</code>或<code>NodeList</code>身上使用。那么到底什么算是类数组呢？</p>
<p><strong>有length属性的对象。</strong></p>
<p>比如：</p>
<pre><code>var obj1 = {
  0: 'Tom',
  1: 'Jack',
  2: 'Jason',
  length: 3
}
var arr = [].slice.call(obj1);
console.log('arr: ', arr);/* [ 'Tom', 'Jack', 'Jason' ] */</code></pre>
<p>那如果没有length呢？</p>
<pre><code>var obj1 = {
  0: 'Tom',
  1: 'Jack',
  2: 'Jason'
}
var arr = [].slice.call(obj1);//* [] */</code></pre>
<p>原来没有length属性的对象也会被转为数组，只不过认为它length=0而已。</p>
<p>那如果对象的属性没有按照0-n顺序乖乖排好呢？</p>
<pre><code>var obj1 = {
  1: 'Tom',
  3: 'Jack',
  5: 'Jason',
  7: 'Dave',
  foo: 'bar',
  length: 6
}
var arr = [].slice.call(obj1);/* [ , 'Tom', , 'Jack', , 'Jason' ] */</code></pre>
<p>原来转化的时候，会以<code>length</code>为基础，生成一个长度为<code>length</code>的数组，<code>obj</code>的属性是数组的有效<code>index</code>的话，就会把对应值填入到对应位置，其他的位置找不到值，就会填入<code>undefined</code>。</p>
<p>所以前面的说法其实不对，所有的对象都可以被视为类数组，有<code>length</code>的视为长度为<code>length</code>的数组，没有的，视为长度为0的数组。</p>
<p><strong>以<code>length</code>属性为基础</strong></p>
<p>这句话很重要。</p>
<p>另外，<code>call</code>方法的参数如果是<code>原始值类型</code>，会传入它的<code>自动包装对象</code>：</p>
<pre><code>var arr = [].slice.call('hello');
</code></pre>
<p>等价于：</p>
<pre><code>var arr = [].slice.call(new String('hello'));/* [ 'h', 'e', 'l', 'l', 'o' ] */    
</code></pre>
<p>以上就是<code>Array.prototype.slice.call</code>的一些细节，那么除了<code>slice</code>之外，<code>Array</code>对象还有很多其他的方法，这些方法是不是也能用到对象身上呢？</p>
<h2>Array.prototype.join</h2>
<p>join方法是把数组转化为字符串的方法，具体表现不再赘述，看两个例子：</p>
<pre><code>var obj1 = {
  0: 'Tom',
  1: 'Jack',
  2: 'Jason',
  length: 6
}
var arr = [].join.call(obj1, '-');// Tom-Jack-Jason---

var obj1 = {
  0: 'Tom',
  1: 'Jack',
  2: 'Jason',
}
var arr = [].join.call(obj1, '-'); // ''</code></pre>
<p>还是那句话，<strong>以<code>length</code>为基础</strong>,没有<code>length</code>属性的，视为长度为0的数组。</p>
<h2>Array.prototype.push</h2>
<p>这个方法比较好玩：</p>
<pre><code>var obj1 = {
  0: 'Tom',
  1: 'Jack',
  2: 'Jason',
  length: 6
}
var arr = [].push.call(obj1, 'Dave');
console.log('arr: ', arr);// 7，因为push方法返回的是push之后array的操作数
console.log('obj: ', obj1);// { '0': 'Tom', '1': 'Jack', '2': 'Jason', '6': 'Dave', length: 7 }</code></pre>
<p>可以看到<code>obj1</code>里新增属性<code>6</code>，值为<code>'Dave'</code>，并且<code>length</code>也更新为<code>7</code>，这说明调用<code>push</code>时会对原有对象进行修改。<br>我们可以利用这个特性，比如当我们需要一个<code>obj1</code>的类数组副本时：</p>
<pre><code>var obj = {
  foo: 'foo',
  bar: 'bar',
  cei: 'cei'
};
var copy = {};
for (var i in obj) {
  [].push.call(copy, obj[i])
}
console.log(copy);// { '0': 'foo', '1': 'bar', '2': 'cei', length: 3 }</code></pre>
<p>如果，没有传入<code>length</code>呢？</p>
<pre><code>var obj1 = {
  0: 'Tom',
  1: 'Jack',
  2: 'Jason'
}
var arr = [].push.call(obj1, 'Dave');
console.log('arr: ', arr);// 1
console.log('obj: ', obj1);// { '0': 'Dave', '1': 'Jack', '2': 'Jason', length: 1 }</code></pre>
<p>这里的行为有些诡异，不过也更好地解释了<strong>以length为基础</strong>这句话：<br>没有<code>length</code>的时候，认为数组长度为<code>0</code>，并且会对<code>obj</code>进行修改，把属性0的值改为<code>Dave</code>.</p>
<p>那么，会举一反三的话，对于<code>pop</code>, <code>shift</code>和<code>unshift</code>这三个方法的行为应该能想象得出来，就不再赘述了。</p>
<h2>Array.prototype.reverse</h2>
<pre><code>var obj1 = {
  0: 'Tom',
  1: 'Jack',
  2: 'Jason',
  length: 6
}
var arr = [].reverse.call(obj1);
console.log('arr: ', arr);// { '3': 'Jason', '4': 'Jack', '5': 'Tom', length: 6 }
console.log('obj: ', obj1);// { '3': 'Jason', '4': 'Jack', '5': 'Tom', length: 6 }</code></pre>
<p><code>reverse</code>的话，<code>arr === obj1</code></p>
<h2>Array.prototype.sort</h2>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].sort.call(obj1);
console.log('arr: ', arr);// { '0': 'a', '1': 'b', '2': 'c', length: 6 }
console.log('obj: ', obj1);// { '0': 'a', '1': 'b', '2': 'c', length: 6 }</code></pre>
<p><code>sort</code>也一样，<code>arr === obj1</code></p>
<h2>Array.prototype.concat</h2>
<p><code>concat</code>的表现就不是我们意料之中的了：</p>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}

var add = {
  foo: 'foo',
  bar: 'bar'
}
var arr = [].concat.call(obj1, add);
console.log('arr: ', arr);// [ { '0': 'c', '1': 'b', '2': 'a', length: 6 }, 'foo', 'bar' ]
console.log('obj: ', obj1);// { '0': 'c', '1': 'b', '2': 'a', length: 6 }</code></pre>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].concat.call(obj1, 'foo', 'bar');
console.log('arr: ', arr);// [ { '0': 'c', '1': 'b', '2': 'a', length: 6 }, 'foo', 'bar' ]
console.log('obj: ', obj1);// { '0': 'c', '1': 'b', '2': 'a', length: 6 }</code></pre>
<p>可以看到<code>obj1</code>并不会改变，不会像<code>push</code>一样会接着形成一个类数组的对象.</p>
<h2>Array.prototype.splice</h2>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].splice.call(obj1, 0, 1);
console.log('arr: ', arr);// [ 'c' ]
console.log('obj: ', obj1);// { '0': 'b', '1': 'a', length: 5 }</code></pre>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].splice.call(obj1, 1, 0, 'foo','bar');
console.log('arr: ', arr);// []
console.log('obj: ', obj1);// { '0': 'c', '1': 'foo', '2': 'bar', '3': 'b', '4': 'a', length: 8 }</code></pre>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].splice.call(obj1, 1, 1, 'foo','bar');
console.log('arr: ', arr);// [ 'b' ]
console.log('obj: ', obj1);// { '0': 'c', '1': 'foo', '2': 'bar', '3': 'a', length: 7 }</code></pre>
<p><code>splice</code>的行为回归了，它现在对<code>obj1</code>产生影响，并且是我们预计的样子</p>
<h2>Array.prototype.every</h2>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].every.call(obj1, function (val) {
  return val === 'a' || val === 'c'
});
console.log('arr: ', arr);// false
console.log('obj: ', obj1);// { '0': 'c', '1': 'b', '2': 'a', length: 6 }</code></pre>
<h2>Array.prototype.filter</h2>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].filter.call(obj1, function (val) {
  return val === 'a' || val === 'c'
});
console.log('arr: ', arr);// [ 'c', 'a' ]
console.log('obj: ', obj1);// { '0': 'c', '1': 'b', '2': 'a', length: 6 }</code></pre>
<h2>Array.prototype.forEach</h2>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].forEach.call(obj1, function (val) {
  return val + ' add';
});
console.log('arr: ', arr);// undefined
console.log('obj: ', obj1);// { '0': 'c', '1': 'b', '2': 'a', length: 6 }</code></pre>
<h2>Array.prototype.map</h2>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].map.call(obj1, function (val) {
  return val + ' add';
});
console.log('arr: ', arr);// [ 'c add', 'b add', 'a add', , ,  ]
console.log('obj: ', obj1);// { '0': 'c', '1': 'b', '2': 'a', length: 6 }</code></pre>
<h2>Array.prototype.reduce</h2>
<pre><code>var obj1 = {
  0: 'c',
  1: 'b',
  2: 'a',
  length: 6
}
var arr = [].reduce.call(obj1, function (pre, cur) {
  return pre + ' ' + cur
});
console.log('arr: ', arr);// 'c b a'
console.log('obj: ', obj1);// { '0': 'c', '1': 'b', '2': 'a', length: 6