<p>【注】本文原发自<a href="https://segmentfault.com/a/1190000007429897">此处</a>，转载请注明出处。</p>
<p><em>本文译自【Webpack-The Confusing Parts】<a href="https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9#.m63u83at2">原文</a></em></p>
<h2>前言</h2>
<p><code>webpack</code>是当前最受欢迎的模块管理器（<code>module bundler</code>），对于使用<code>React</code>开发的项目来说堪称神器。当然，对于使用其他框架，比如<code>Angular</code>或者<code>Backbone</code>等的开发者来说，<code>webpack</code>也是种很好的工具。</p>
<p>第一次配置<code>webpack.config.js</code>时，有很多地方使我很困惑。在使用了<code>webpack</code>一段时间后，我认识到正是这些地方让<code>webpack</code>如此强大和迷人。</p>
<h2>
<code>webpack</code>核心理念</h2>
<ul>
<li><p>一切都是模块。—— 在<code>webpack</code>中，不仅<code>js</code>文件可以作为一个模块，其他文件（<code>css</code>，<code>images</code>，<code>html</code>）都可以作为模块。这就是说，你可以在其他文件中加载这些模块，<code>require('myJSfile.js')</code>，或者<code>require('myCSSfile.css')</code>。这意味着我们将任意文件拆分成便于管理的小文件，然后通过在其他文件中加载这些小文件来达到重复利用的目的。</p></li>
<li><p>按需加载（<code>Load only "what" you need and "when" you need</code>）—— 一般情况下打包工具会将我们所有的模块打包生成一个最终的文件<code>bundle.js</code>。但是在实际应用中，<code>bundle.js</code>通常会很大（10M~15M），需要很长时间才能加载完成。<code>webpack</code>提供了多种<code>code splitting</code>的方法，会生成过个打包后的文件，且支持按需加载。这样我们只有在需要用到某个模块的时候才会异步加载该模块。</p></li>
</ul>
<p>现在我们来看下这些令人困惑的部分。</p>
<h2>开发环境和生产环境（Development Vs Production）</h2>
<p>首先要明确的一点是，<code>webpack</code>有很多特性，有些只在开发环境使用，还有些只在生产环境使用，当然还有在生产环境和开发环境都可以使用的。如下图所示：<br><img data-src="/img/bVFkeE?w=1600&amp;h=898" src="/img/bVFkeE?w=1600&amp;h=898.png"></p>
<blockquote><p>所以通常我们会有两个<code>config</code>文件，以针对开发环境和生产环境作不同配置。</p></blockquote>
<p>在<code>package.json</code>做如下配置：</p>
<pre><code>"scripts": {
  //npm run build to build production bundles
  "build": "webpack --config webpack.config.prod.js",
  //npm run dev to generate development bundles and run dev. server
  "dev": "webpack-dev-server"
 }</code></pre>
<h2>
<code>webpack CLI</code> Vs <code>webpack-dev-server</code>
</h2>
<p>需要知道<code>webpack</code>提供了两个接口</p>
<ol>
<li><p><code>webpack</code>命令行工具(<code>webpack CLI tool</code>) —— 默认使用这种方式，无需单独安装，被集成在<code>webpack</code>中。</p></li>
<li><p><code>webpack-dev-server</code> —— <code>node.js</code> 服务器，需要单独安装</p></li>
</ol>
<h3>Webpack CLI (适用于生产环境构建）</h3>
<p>可以通过命令行添加参数，也可以通过配置文件（默认为<code>webpack.config.js</code>），<code>webpack</code>打包时会读取这些配置。</p>
<blockquote><p>最初学习<code>webpack</code>时你可能用的就是命令行方式，之后大部分使用命令行的场景为生产环境打包。</p></blockquote>
<p><strong>使用方法</strong></p>
<pre><code>方法 1: 
//全局安装
npm install webpack --g
//在命令行使用
$ webpack //&lt;--Generates bundle using webpack.config.js

方法 2 :
//本地安装并保存在package.json中
npm install webpack --save
//在scripts中添加
"scripts": {
 "build": "webpack --config webpack.config.prod.js -p",
 ...
 }
//按以下方式运行
"npm run build"</code></pre>
<h3>
<code>webpack-dev-server</code>（适用于开发环境构建）</h3>
<p><code>webpack-dev-server</code>是一个基于<code>Express</code>的<code>node</code>服务器，默认使用<code>8080</code>端口。这个方式的优点是它提供了浏览器热加载（<code>Hot Module Replacement</code>）。<br><strong>使用方法</strong></p>
<pre><code>方法一：
//全局安装
npm install webpack-dev-server -g
//在命令行使用
$ webpack-dev-server --inline --hot

方法二：
//添加到package.json中
"script": {
     "start": "webpack-dev-server --inline --hot",
     ...
}
//在命令行使用
$ npm start

在浏览器中打开
http://localhost:8080/</code></pre>
<h3>
<code>webpack</code>和<code>webpack-dev-server</code>选项</h3>
<p>需要注意的一点是，像<code>inline</code>和<code>hot</code>这些选项，只有<code>webpack-dev-server</code>有；而另一些比如<code>hide-modules</code>是单独为<code>webpack</code>命令行方式提供的选项。</p>
<h3>
<code>webpack-dev-server</code>参数</h3>
<p>为<code>webpack-dev-server</code>提供参数有两种方式。</p>
<ol>
<li><p>通过<code>webpack.config.js</code>中的<code>devServer</code></p></li>
<li><p>通过<code>CLI</code>选项</p></li>
</ol>
<p><strong>使用方法</strong></p>
<pre><code>//通过CLI
$ webpack-dev-server --hot --inline

//通过webpack.config.js
devServer: {
    inline: true,
    hot: true
}</code></pre>
<blockquote><p>我发现通过<code>devServer</code>设置的配置项（<code>hot: true, inline: true</code>）有时不起作用。所以我更喜欢使用<code>CLI</code>的方式，在<code>package.json</code>中添加如下代码：</p></blockquote>
<pre><code>package.json
{
    "script": {
        "start": "webpack-dev-server --hot --inline"
    }
}</code></pre>
<blockquote><p>注意<code>不要</code>同时设置<code>devServer</code>中<code>hot: true</code>和<code>CLI</code>中<code>--hot</code></p></blockquote>
<h3>
<code>"hot"</code> Vs <code>"inline"</code>
</h3>
<p><code>inline</code>模式会触发页面的动态重载（<code>live reloading</code>）；<code>hot</code>模式会触发页面的热加载（<code>hot Module Replacement</code>）,这种模式只重载页面中变化了的部分。如果同时设置了<code>inline</code>和<code>hot</code>，<code>webpack-dev-server</code>会先尝试<code>HMR</code>，如果<code>HMR</code>失败了，则重载整个页面。</p>
<pre><code>//当代码发生变化时，以下3种方式都会重新打包，但是：

//1. 不会重载页面
$ webpack-dev-server

//2. 会重载整个页面
$ webpack-dev-server --inline

//3. HMR, 若失败则加载整个页面
$ webpack-dev-server --inline --hot</code></pre>
<h2>
<code>entry</code>(<code>String</code> Vs <code>Array</code> Vs <code>Object</code>)</h2>
<p><code>entry</code>指出了打包入口文件，支持<code>字符串</code>,<code>数组</code>和<code>对象</code>三种形式。这三种形式有何区别呢？</p>
<blockquote><p>如果为单一入口文件，也就是说入口文件只有一个，那这三种方式会得到相同的结果。</p></blockquote>
<h3>
<code>entry</code> — <code>Array</code>
</h3>
<p>若有多个入口文件，且彼此独立，那么可以使用数组方式。比如入口文件为<code>a.js</code>，<code>b.js</code>，使用数组方式会将<code>b.js</code>的内容追加到<code>bundle.js</code>的内容后。<br>一个很常见的场景就是在<code>html</code>文件加入统计代码，比如<code>googleAnalytics.js</code>，就可以用数组的方式告知<code>webpack</code>将其打包到<code>bundle.js</code>末尾，如下：<br><img data-src="/img/bVFkiF?w=1200&amp;h=410" src="/img/bVFkiF?w=1200&amp;h=410.png"></p>
<h3>
<code>entry</code> — <code>Object</code>
</h3>
<p>这种方式主要针对多页面应用（指包含多个<code>html</code>文件）。这种方式可以使<code>webpack</code>根据这个对象一次就打包出多个文件。<br>如下这种配置可以打包出两个<code>js</code>文件：<code>indexEntry.js</code>和<code>profileEntry.js</code>，可以分别在<code>index.html</code>和<code>profile.html</code>中引入。</p>
<pre><code>{
    entry: {
        "indexEntry": "./public/src/index.js",
        "profileEntry": "./public/src/profile.js"
    },
    output: {
        path: "/dist",
        filename: "[name].js"  //indexEntry.js &amp; profileEntry.js
    }
}</code></pre>
<p><strong> 使用方法 </strong></p>
<pre><code>//profile.html
&lt;script src="dist/profileEntry.js"&gt;&lt;/script&gt;

//index.html
&lt;script src="dist/indexEntry.js"&gt;&lt;/script&gt;</code></pre>
<p><strong> 注： </strong> <code>output</code>中<code>name</code>对应的是<code>entry</code>中的属性名。</p>
<h3>
<code>entry</code> — 结合使用<code>array</code>和<code>object</code>
</h3>
<p>可以在<code>object</code>内部再使用<code>array</code>方式。比如如下配置：</p>
<pre><code>{
    entry: {
        "vendor": ['jquery', 'analytics.js', 'optimizely.js'],
        "index": "./public/src/index.js",
        "profile": "./public/src/profile.js"
    },
    
    output: {
        path: "/dist",
        filename: "[name].js"  //vendor.js, index.js &amp; profile.js
    }
}</code></pre>
<h2>
<code>output</code> — <code>path</code>和<code>publicPath</code>
</h2>
<p><code>output</code>设定了打包生成文件的路径。它有两个属性<code>path</code>和<code>publicPath</code>。<br><code>path</code>告知<code>webpack</code>将打包生成后的文件存储于什么路径，比如我们希望将文件打包到<code>dist</code>文件夹下，只需设置<code>path</code>为<code>/dist</code>即可；<code>publicPath</code>用于在生产环境打包时更新文件（包括<code>css</code>、<code>html</code>）中的<code>url</code>。<br>如下配置：</p>
<pre><code>//开发环境config
entry: __dirname + "/app/main.js",

output: {
    path: __dirname + "/public",
    
    //开发环境中不需要使用publicPath, 除非你的静态资源比如图片等没有存储在本地开发环境。
    //publicPath: "http://mycdn.com",
    filename: "bundle.js"
}

//生产环境config
entry: __dirname + "/app/main.js",

output: {
    path: __dirname + "/public",
    
    //publicPath: 一些插件（url-loader, file-loader, HtmlWebpackPlugin等)
    //在生成图片，样式表等的url路径时会用到该配置
    //比如：
    //.image {
    //    background-image: url('./test/png');
    //}
    //按如下配置打包后会变成：
    //.image {
    //    background-image: url('http://mycdn.com/test.png');
    //}
    publicPath: "http://mycdn.com/",
    filename: "bundle.js"
}</code></pre>
<p>举个例子，在你的<code>css</code>文件中，用到了<code>./test.png</code>这个<code>url</code>去加载本地的图片。但是在生产环境中，这张图片<code>test.png</code>会存储在<code>cdn</code>服务器上。这样如果还是用<code>./test.png</code>就会访问不到该图片，必须把文件中所有的<code>url</code>手动改成<code>cdn</code>的路径才能在生产环境使用。</p>
<p><code>webpack</code>为我们提供的<code>publicPath</code>这个属性使我们可以很方便地处理这类问题。只需要将<code>publicPath</code>设置为生产环境的路径，这些识别<code>publicPath</code>的插件，比如<code>url-loader</code>,就会自动为我们处理好<code>url</code>。如下图所示：</p>
<p><img data-src="/img/bVFkvF?w=1200&amp;h=856" src="/img/bVFkvF?w=1200&amp;h=856.png"></p>
<pre><code>//开发环境，server和image都在本地
.image {
    background-image: url('./test.png');
}

//生产环境, server在HeroKu服务器上，而image在cdn上
.image {
    background-image: url('https://someCDN/test.png');
}</code></pre>
<p>（<code>译者注：</code> <code>publicPath</code>还用于指定在使用<code>webpack-dev-server</code>时，如何访问其暂存于内存中的打包后的文件。）</p>
<h2>加载器和链式加载器（<code>Loaders And Chaining Loaders</code>）</h2>
<p>加载器是一些<code>node</code>模块，可以加载（<code>load</code>）或者引入（<code>import</code>）各种类型的文件使其转化成浏览器支持的文件格式，包括<code>js</code>,<code>css</code>等等。<br>比如：可以使用<code>babel-loader</code>将使用<code>ES6</code>写的<code>js</code>文件转换为浏览器支持的<code>ES5</code>格式。如下：</p>
<pre><code>module {
    loaders: [
        {
            test: /\.js$/,  //检测js文件，如果是，则对其使用loader处理
            exclude: /node_modules/,  //不对node_modules下文件处理
            loader: 'babel'   //使用babel (对babel-loader的简写)
        }
    ]
}</code></pre>
<h3>链式加载（从右至左）</h3>
<p>对同一种类型的文件可以链式运用多个加载器。链式调用为从右向左，通过<code>!</code>分割加载器。<br>举例：我们有一个<code>css</code>文件<code>myCSSFile.css</code>，我们想将这个文件中的内容转换成<code>&lt;style&gt;CSS content&lt;/style&gt;</code>的形式插入到我们的<code>html</code>页面中。可以使用两个加载器<code>css-loader</code>和<code>style-loader</code>来达成以上目的：</p>
<pre><code>modules: {
    loaders: [
        {
            test: /\.css$/,
            loader: 'style!css'  //style-loader!css-loader的简写
        }
    ]
}</code></pre>
<p>如下展示了其原理：<br><img data-src="/img/remote/1460000007429900" src="/img/remote/1460000007429900.png"><br>1、<code>webpack</code>查找模块中依赖的<code>css</code>文件。也就是说，<code>webpack</code>会检查<code>js</code>文件中是否引用了<code>myCSSFile.css</code>。如果找到了依赖，<code>webpack</code>会先用<code>css-loader</code>对其进行处理。<br>2、<code>css-loader</code>会加载所有的<code>css</code>和这个<code>css</code>的依赖（比如<code>@import otherCSS</code>），并将<code>css</code>的内容处理为<code>JSON</code>数据格式。然后将结果传给<code>style-loader</code>进行处理。<br>3、<code>style-loader</code>会对接收到的<code>json</code>数据进行处理，并将其处理为<code>style</code>标签——<code>&lt;style&gt;CSS contents&lt;/style&gt;</code>，然后插入到<code>html</code>页面中。</p>
<h2>加载器可配置</h2>
<p>可以向<code>loaders</code>传递各种参数进行配置。<br>在以下这个例子中，我们对<code>url-loader</code>进行了配置：小于1024字节的图片将会被转为为<code>base64</code>格式，而大于1024字节的图片还是使用图片<code>url</code>。有两种方式进行配置：</p>
<pre><code>//方式1 使用'?'
{
    test: /\.png$/,
    loader: "url-loader?limit=1024"
}

//方式2 使用'query'属性
{
    test: /\.png$/,
    loader: "url-loader",
    query: {limit: 1024}
}</code></pre>
<h2>
<code>.babelrc</code>文件</h2>
<p>使用<code>babel-loader</code>的话，需要配置<code>presets</code>才能正确转化，包括将<code>es6</code>转换为<code>es5</code>，将<code>JSX</code>转为<code>js</code>。可以通过如下方式设置参数</p>
<pre><code>module: {
    loaders: [
        {
            test: /\.jsx?$/,
            exclude: /(node_modules|bower_components)/,
            loader: 'babel',
            query: {
                presets: ['react', 'es2015']
            }
        }
    ]
}</code></pre>
<p>但是在很多项目中<code>babel</code>的配置可能会比较大，所以可以单独在<code>babel</code>的配置文件<code>.babelrc</code>中配置。如果有<code>.babelrc</code>，<code>babel-loader</code>会自动加载该文件。<br>如下：</p>
<pre><code>//webpack.config.js
module: {
    loaders: [
        {
            test: /\.jsx?$/,
            exclude: /(node_modules|bower_components)/,
            loader: 'babel'
        }
    ]
}

//.babelrc
{
    "presets": ["react", "es2015"]
}</code></pre>
<h2>插件（<code>Plugins</code>）</h2>
<p>插件是一些<code>node</code>模块，可以对生成的打包文件进行处理。<br>比如，<code>uglifyJSPlugin</code>插件可以对打包后得到的<code>bundle.js</code>进行压缩处理，减小文件体积。<br><code>extract-text-webpack-plugin</code>运用了<code>css-loader</code>和<code>style-loader</code>将所有的<code>css</code>统一处理并根据结果生成一个单独的<code>css</code>文件（<code>style.css</code>），将文件链接插入到<code>html</code>文件中。</p>
<pre><code>//webpack.config.js
//获取所有的css文件，并将其内容整合，生成一个单独的css文件'style.css'
var ETP = require('extract-text-webpack-plugin');

module: {
    loaders: [
        {
            test: /\.css$/,
            loader: ETP.extract('style-loader', 'css-loader')
        }
    ]
},

plugins: [
    new ExtractTextPlugin("style.css")
]</code></pre>
<p><strong> 注： </strong> <br>如果你只是想使用内联<code>css</code>样式，在<code>html</code>页面中加入<code>style</code>标签，可以只用<code>css</code>和<code>style</code>加载器。如下：</p>
<pre><code>module: {
    loaders: [
        {
            test: /\.css$/,
            loader: 'style!css'
        }
    ]
}</code></pre>
<h2>加载器和插件(<code>Loaders Vs Plugins</code>)</h2>
<p>可以看到，加载器作用于单独的文件，在<code>bundle</code>生成之前完成；<br>插件作用于<code>bundle</code>或<code>chunk</code>，通常是在<code>bundle</code>生成过程的最后进行。一些插件比如<code>commonsChunksPlugins</code>甚至会影响<code>bundle</code>如何生成。（<code>译者注</code>:该插件用于提取出各个模块中引用的相同模块，下篇文章<code>code splitting</code>中会详细说明）</p>
<h2>文件后缀处理(<code>Resolving File Extensions</code>)</h2>
<p>很多<code>webpack</code>配置文件中都包含一个<code>resolve extensions</code>的属性，其中包含一个空字符串。这个空字符串就是用于正确加载不含后缀的文件的。比如：<code>require('./myJSFile')</code> 或 <code>import myJSFile from  './myJSFile' </code>。</p>
<pre><code>{
    resolve: {
        extensions: ['', '.js', '.jsx']
    }
}</code></pre>
<p><strong> 注： </strong> 翻译水平有限，如有问题还希望大家能不吝赐教，希望和大家共同进步。</p>
<p>(本文完）</p>