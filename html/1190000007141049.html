<blockquote><p>注：本文使用的 react-router 版本为 2.8.1</p></blockquote>
<p>React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆" — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。</p>
<p>官方示例在 <a href="https://github.com/ReactTraining/react-router/tree/master/examples/huge-apps">这里</a>。</p>
<p>所得到的效果是：</p>
<p>以前是这样（23333，我真不是故意的。。）</p>
<p><img data-src="/img/remote/1460000007141052?w=2500&amp;h=50" src="/img/remote/1460000007141052?w=2500&amp;h=50.png"></p>
<p>现在是这样：</p>
<p><img data-src="/img/remote/1460000007141053?w=2496&amp;h=214" src="/img/remote/1460000007141053?w=2496&amp;h=214.png"></p>
<p>实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。</p>
<p>下面是改造过程</p>
<h2>Webpack 配置</h2>
<p>首先在 <code>webpack.config.js</code> 的 <code>output</code> 内加上 <code>chunkFilename</code></p>
<pre><code class="javascript">output: {
    path: path.join(__dirname, '/../dist/assets'),
    filename: 'app.js',
    publicPath: defaultSettings.publicPath,
    // 添加 chunkFilename
    chunkFilename: '[name].[chunkhash:5].chunk.js',
},</code></pre>
<p><code>name</code> 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。</p>
<p><code>chunkhash</code> 是文件的 hash 码，这里只使用前五位。</p>
<h2>添加首页</h2>
<p>以前你的路由大概应该是这样的：（作为需要按需加载的大型应用，路由肯定是相当复杂，这里只列举部分路由举例）</p>
<pre><code class="jsx">ReactDOM.render(
  (
    &lt;Router history={browserHistory}&gt;
      {/* 主页 */}
      &lt;Route path="/" component={App}&gt;
        {/* 默认 */}
        &lt;IndexRoute component={HomePage} /&gt;

        {/* baidu */}
        &lt;Route path="/baidu" component={BaiduPage}&gt;
          &lt;Route path="result" component={BaiduResultPage} /&gt;
          &lt;Route path="frequency" component={BaiduFrequencyPage} /&gt;
        &lt;/Route&gt;

        {/* 404 */}
        &lt;Route path='/404' component={NotFoundPage} /&gt;
        
        {/* 其他重定向到 404 */}
        &lt;Redirect from='*' to='/404' /&gt;
      &lt;/Route&gt;
    &lt;/Router&gt;
  ), document.getElementById('app')
);</code></pre>
<p>按需加载之后，我们需要让路由动态加载组件，需要将 <code>component</code> 换成 <code>getComponent</code>。首先将路由拆出来（因为路由庞大之后全部写在一起会很难看），创建一个根路由 rootRoute：</p>
<pre><code class="jsx">const rootRoute = {
  path: '/',
  indexRoute: {
    getComponent(nextState, cb) {
      require.ensure([], (require) =&gt; {
        cb(null, require('components/layer/HomePage'))
      }, 'HomePage')
    },
  },
  getComponent(nextState, cb) {
    require.ensure([], (require) =&gt; {
      cb(null, require('components/Main'))
    }, 'Main')
  },
  childRoutes: [
    require('./routes/baidu'),
    require('./routes/404'),
    require('./routes/redirect')
  ]
}

ReactDOM.render(
  (
    &lt;Router
      history={browserHistory}
      routes={rootRoute}
      /&gt;
  ), document.getElementById('app')
);</code></pre>
<p>history 不变，在 Router 中添加 routes 属性，将创建的路由传递进去。</p>
<p>这里有四个属性：</p>
<h3>path</h3>
<p>将匹配的路由，也就是以前的 path。</p>
<h3>getComponent</h3>
<p>对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。</p>
<p>这里面有个 <strong>require.ensure</strong> 方法</p>
<pre><code class="javascript">require.ensure(dependencies, callback, chunkName)</code></pre>
<p>这是 webpack 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 chunkName，用来指定这个 chunk file 的 name。</p>
<p>如果需要返回多个子组件，则使用 <code>getComponents</code> 方法，将多个组件作为一个对象的属性通过 <code>cb</code> 返回出去即可。这个在官方示例也有，但是我们这里并不需要，而且根组件是不能返回多个子组件的，所以使用 <code>getComponent</code>。</p>
<h3>indexRoute</h3>
<p>用来设置主页，对应于以前的 <code>&lt;IndexRoute&gt;</code>。</p>
<p>注意这里的 indexRoute 写法， <strong>这是个对象，在对象里面使用 getComponent</strong>。</p>
<h3>childRoutes</h3>
<p>这里面放置的就是子路由的配置，对应于以前的子路由们。我们将以前的 <code>/baidu</code>、<code>/404</code> 和 <code>*</code> 都拆了出来，接下来将分别为他们创建路由配置。</p>
<h2>路由控制</h2>
<p>上面的<code>childRoutes</code> 里面，我们 require 了三个子路由，在目录下创建 <code>routes</code> 目录，将这三个路由放置进去。</p>
<pre><code>routes/
├── 404
│   └── index.js
├── baidu
│   ├── index.js
│   └── routes
│       ├── frequency
│       │   └── index.js
│       └── result
│           └── index.js
└── redirect
    └── index.js</code></pre>
<p>和 rootRoute 类似，里面的每个 index.js 都是一个路由对象：</p>
<h3>/404/index.js</h3>
<pre><code class="javascript">module.exports = {
  path: '404',

  getComponent(nextState, cb) {
    require.ensure([], (require) =&gt; {
      cb(null, require('components/layer/NotFoundPage'))
    }, 'NotFoundPage')
  }
}
</code></pre>
<h3>/baidu/index.js</h3>
<pre><code class="javascript">module.exports = {
  path: 'baidu',

  getChildRoutes(partialNextState, cb) {
    require.ensure([], (require) =&gt; {
      cb(null, [
        require('./routes/result'),
        require('./routes/frequency')
      ])
    })
  },

  getComponent(nextState, cb) {
    require.ensure([], (require) =&gt; {
      cb(null, require('components/layer/BaiduPage'))
    }, 'BaiduPage')
  }
}
</code></pre>
<h3>/baidu/routes/frequency/index.js</h3>
<pre><code class="javascript">module.exports = {
  path: 'frequency',

  getComponent(nextState, cb) {
    require.ensure([], (require) =&gt; {
      cb(null, require('components/layer/BaiduFrequencyPage'))
    }, 'BaiduFrequencyPage')
  }
}
</code></pre>
<p>举这几个例子应该就差不多了，其他都是一样的，稍微有点特别的是 redirect。</p>
<h2>设置 Redirect</h2>
<p>之前我们在根路由下是这么设置重定向的：</p>
<pre><code class="jsx">&lt;Router history={browserHistory}&gt;
      &lt;Route path="/" component={App}&gt;
        {/* home */}
        &lt;IndexRoute component={HomePage} /&gt;

        &lt;Route path="/baidu" component={BaiduPage}&gt;
          &lt;Route path="result" component={BaiduResultPage} /&gt;
          &lt;Route path="frequency" component={BaiduFrequencyPage} /&gt;
        &lt;/Route&gt;

        &lt;Route path='/404' component={NotFoundPage} /&gt;
        {/* 如果都不匹配，重定向到 404 */}
        &lt;Redirect from='*' to='/404' /&gt;
      &lt;/Route&gt;
    &lt;/Router&gt;</code></pre>
<p>当改写之后，我们需要把这个重定向的路由单独拆出来，也就是  <code>*</code> 这个路由，我们上面已经为他创建了一个 <code>redirect</code> 目录。这里使用到 onEnter 方法，然后在这个方法里改变路由状态，调到另外的路由，实现 redirect ：</p>
<h3>/redirect/index.js</h3>
<pre><code class="javascript">module.exports = {
  path: '*',
  onEnter: (_, replaceState) =&gt; replaceState(null, "/404")
}</code></pre>
<h2>The root route must render a single element</h2>
<p>跟着官方示例和上面码出来之后，可能页面并没有渲染出来，而是报 <strong>The root route must render a single element</strong> 这个异常，这是因为 <code>module.exports</code> 和 ES6 里的 <code>export default</code> 有区别。</p>
<p>如果你是使用 es6 的写法，也就是你的组件都是通过 <code>export default</code> 导出的，那么在 <code>getComponent</code> 方法里面需要加入 <code>.default</code>。</p>
<pre><code class="javascript">getComponent(nextState, cb) {
    require.ensure([], (require) =&gt; {
      // 在后面加 .default
      cb(null, require('components/layer/ReportPage')).default
    }, 'ReportPage')
}</code></pre>
<p>如果你是使用 CommonJS 的写法，也就是通过 <code>module.exports</code> 导出的，那就无须加 <code>.default</code> 了。</p>