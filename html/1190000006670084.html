<p>记录下<code>webpack-dev-server</code>的用法.</p>
<p>首先，我们来看看基本的<code>webpack.config.js</code>的写法</p>
<pre><code class="javascript">    module.exports = {
        entry: './src/js/index.js',
        output: {
            path: './dist/js',
            filename: 'bundle.js'
        }
    }</code></pre>
<p>配置文件提供一个入口和一个出口，<code>webpack</code>根据这个来进行<code>js的打包和编译</code>工作。虽然<code>webpack</code>提供了<code>webpack --watch</code>的命令来动态监听文件的改变并实时打包，输出新<code>bundle.js</code>文件，这样文件多了之后打包速度会很慢，此外这样的打包的方式不能做到<code>hot replace</code>，即每次<code>webpack</code>编译之后，你还需要手动刷新浏览器。</p>
<p><code>webpack-dev-server</code>其中部分功能就能克服上面的2个问题。<code>webpack-dev-server</code>主要是启动了一个使用<code>express</code>的<code>Http服务器</code>。它的作用<strong>主要是用来伺服资源文件</strong>。此外这个<code>Http服务器</code>和<code>client</code>使用了<code>websocket</code>通讯协议，原始文件作出改动后，<code>webpack-dev-server</code>会实时的编译，但是最后的编译的文件并没有输出到目标文件夹，即上面配置的:</p>
<pre><code class="javascript">    output: {
        path: './dist/js',
        filename: 'bundle.js'
    }</code></pre>
<p><strong>注意：你启动webpack-dev-server后，你在目标文件夹中是看不到编译后的文件的,实时编译后的文件都保存到了内存当中。因此很多同学使用webpack-dev-server进行开发的时候都看不到编译后的文件</strong></p>
<p>下面来结合<code>webpack</code>的文档和<code>webpack-dev-server</code>里部分源码来说明下如何使用：</p>
<h2>启动</h2>
<p>启动<code>webpack-dev-server</code>有2种方式：</p>
<ol>
<li><p>通过<code>cmd line</code></p></li>
<li><p>通过<code>Node.js API</code></p></li>
</ol>
<h2>配置</h2>
<p>我主要讲解下<code>cmd line</code>的形式,<code>Node.js API</code>形式大家去看下官方文档。可通过<code>npm script</code>进行启动。我的目录结构是:</p>
<pre><code>    app
    |__dist
    |   |__styles
    |   |__js
    |       |__bundle.js
    |   |__index.html
    |__src
    |   |__styles
    |   |__js
    |       |__index.js
    |__node_modules
    |__package.json
    |__webpack.config.js</code></pre>
<h3>content-base</h3>
<p>设定<code>webpack-dev-server</code>伺服的<code>directory</code>。如果不进行设定的话，默认是在当前目录下。</p>
<pre><code>webpack-dev-server --content-base ./dist
</code></pre>
<p>这个时候还要注意的一点就是在<code>webpack.config.js</code>文件里面，如果配置了<code>output</code>的<code>publicPath</code>这个字段的值的话，在<code>index.html</code>文件里面也应该做出调整。<strong>因为<code>webpack-dev-server</code>伺服的文件是相对<code>publicPath</code>这个路径的</strong>。因此，如果你的<code>webpack.config.js</code>配置成这样的：</p>
<pre><code class="javascript">    module.exports = {
        entry: './src/js/index.js',
        output: {
            path: './dist/js',
            filename: 'bundle.js'，
            publicPath: '/assets/'
        }
    }</code></pre>
<p>那么，在<code>index.html</code>文件当中引入的路径也发生相应的变化:</p>
<pre><code class="javascript">    &lt;!DOCTYPE html&gt;
    &lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;Demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src="assets/bundle.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<p>如果在<code>webpack.config.js</code>里面没有配置<code>output</code>的<code>publicPath</code>的话，那么<code>index.html</code>最后引入的文件<code>js文件</code>路径应该是下面这样的。</p>
<pre><code class="javascript">    &lt;!DOCTYPE html&gt;
    &lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;Demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src="bundle.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<h2>Automatic Refresh</h2>
<p><code>webpack-dev-server</code>支持2种自动刷新的方式：</p>
<ul>
<li><p>Iframe mode</p></li>
<li><p>inline mode</p></li>
</ul>
<p>这2种模式配置的方式和访问的路径稍微有点区别，最主要的区别还是<code>Iframe mode</code>是在网页中嵌入了一个<code>iframe</code>，将我们自己的应用注入到这个<code>iframe</code>当中去，因此每次你修改的文件后，都是这个<code>iframe</code>进行了<code>reload</code>。</p>
<p>通过查看<code>webpack-dev-server</code>的源码，<code>lib</code>路径下的<code>Server.js</code>文件，第38-48行，分别新建几个流，这几个流保存了<code>client</code>文件夹下的相关文件：</p>
<pre><code class="javascript">    // Prepare live html page
    var livePage = this.livePage = new StreamCache();
    fs.createReadStream(path.join(__dirname, "..", "client", "live.html")).pipe(livePage);

    // Prepare the live js file
    var liveJs = new StreamCache();
    fs.createReadStream(path.join(__dirname, "..", "client", "live.bundle.js")).pipe(liveJs);

    // Prepare the inlined js file
    var inlinedJs = new StreamCache();
    fs.createReadStream(path.join(__dirname, "..", "client", "index.bundle.js")).pipe(inlinedJs);</code></pre>
<pre><code>    // Init express server
    var app = this.app = new express();

    // middleware for serving webpack bundle
    this.middleware = webpackDevMiddleware(compiler, options);

    app.get("/__webpack_dev_server__/live.bundle.js", function(req, res) {
        res.setHeader("Content-Type", "application/javascript");
        liveJs.pipe(res);
    });

    app.get("/webpack-dev-server.js", function(req, res) {
        res.setHeader("Content-Type", "application/javascript");
        inlinedJs.pipe(res);
    });

    app.get("/webpack-dev-server/*", function(req, res) {
        res.setHeader("Content-Type", "text/html");
        this.livePage.pipe(res);
    }.bind(this));
</code></pre>
<p>当使用<code>Iframe mode</code>时，请求<code>/webpack-dev-server/index.html</code>路径时，会返回<code>client/index.html</code>文件，这个文件的内容就是：</p>
<pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"/&gt;&lt;meta charset="utf-8"/&gt;&lt;meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/&gt;&lt;script type="text/javascript" charset="utf-8" src="/__webpack_dev_server__/live.bundle.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
<p>这个页面会请求<code>live.bundle.js</code>,其中里面会新建一个<code>Iframe</code>，你的应用就被注入到了这个<code>Iframe</code>当中。同时<code>live.bundle.js</code>中含有<code>socket.io</code>的<code>client</code>代码，这样它就能和<code>webpack-dev-server</code>建立的<code>http server</code>进行<code>websocket</code>通讯了。并根据返回的信息完成相应的动作。</p>
<p>而<code>Inline-mode</code>，是<code>webpack-dev-server</code>会在你的<code>webpack.config.js</code>的入口配置文件中再添加一个入口,</p>
<pre><code>    module.exports = {
        entry: {
            app: [
                'webpack-dev-server/client?http://localhost:8080/',
                './src/js/index.js'
            ]
        },
        output: {
            path: './dist/js',
            filename: 'bundle.js'
        }
    }</code></pre>
<p>这样就完成了将<code>inlinedJS</code>打包进<code>bundle.js</code>里的功能，同时<code>inlinedJS</code>里面也包含了<code>socket.io</code>的<code>client</code>代码，可以和<code>webpack-dev-server</code>进行<code>websocket</code>通讯。</p>
<p>当然你也可以直接在你<code>index.html</code>引入这部分代码:</p>
<pre><code>&lt;script src="http://localhost:8080/webpack-dev-server.js"&gt;&lt;/script&gt;

</code></pre>
<p>不过<code>Iframe mode</code>和<code>Inline mode</code>最后达到的效果都是一样的，都是监听文件的变化，然后再将编译后的文件推送到前端，完成页面的<code>reload</code>的。</p>
<h3>Iframe mode</h3>
<p><code>Iframe mode</code>下<code>cmd line</code>不需要添加其他的内容，浏览器访问的路径是:</p>
<pre><code>
localhost:8080/webpack-dev-server/index.html。
</code></pre>
<p>这个时候这个页面的<code>header部分</code>会出现整个<code>reload消息</code>的状态。当时改变源文件的时候，即可以完成自动编译打包，页面自动刷新的功能。</p>
<p><img data-src="/img/bVB9lm?w=2550&amp;h=748" src="/img/bVB9lm?w=2550&amp;h=748.jpeg"></p>
<h3>Inline mode</h3>
<p>使用<code>inline mode</code>的时候，<code>cmd line</code>需要写成：</p>
<pre><code>webpack-dev-server --inline --content-base ./dist
</code></pre>
<p>这个时候访问的路径是:</p>
<pre><code>localhost:8080/index.html
</code></pre>
<p>也能完成自动编译打包，页面自动刷新的功能。但是没有的<code>header</code>部分的<code>reload</code>消息的显示，不过在控制台中会显示<code>reload</code>的状态。</p>
<p><img data-src="/img/bVB9ln?w=2548&amp;h=1444" src="/img/bVB9ln?w=2548&amp;h=1444.jpeg"></p>
<h2>Hot Module Replacement</h2>
<p>开启<code>Hot Module Replacemen</code>t功能，在<code>cmd line</code>里面添加<code>--hot</code></p>
<pre><code>webpack-dev-server --hot --inline --content-base ./dist
</code></pre>
<h2>其他配置选项</h2>
<pre><code>--quiet 控制台中不输出打包的信息
--compress 开启gzip压缩
--progress 显示打包的进度
</code></pre>
<p>还有一切其他的配置信息可以查阅官方文档:</p>
<p><a href="http://webpack.github.io/docs/webpack-dev-server.html#webpack-dev-server-cli">webpack-dev-server-cli</a></p>
<p>这是我的<code>package.json</code>的文件：</p>
<pre><code>    {
  "name": "reptile",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline --content-base ./dist",
    "build": "webpack --progress --colors"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "babel-core": "^6.13.2",
    "babel-loader": "^6.2.5",
    "babel-preset-es2015": "^6.13.2",
    "babel-preset-react": "^6.11.1",
    "css-loader": "^0.23.1",
    "react": "^15.3.1",
    "react-dom": "^15.3.1",
    "style-loader": "^0.13.1",
    "webpack": "^1.13.2",
    "webpack-dev-server": "^1.14.1"
  }
}</code></pre>
<p>首先命令行：输入 <code>npm install</code> 所有依赖。然后输入<code>npm run dev</code>。在浏览器中打开localhost:8080/index.html，然后就可以愉快的开发咯。</p>
<h2>本地搭建API Server</h2>
<p>如果你在本地还启动了一个<code>api server</code>,<code>port</code>为3000,这个<code>server</code>主要和你的前端应用进行数据交互。这个时候很显然会出现跨域的问题，那么这个时候，你前端应用的入口文件应当是用你自己启动的<code>api server</code>提供的。</p>
<pre><code>    var express = require('express');
    var app = express();
    
    app.get('/', function(req, res) {
        res.send('xxx/xxx/index.html'); //这个地方填写dist/index.html的路径
    })</code></pre>
<p>此外<code>webpack.config.js</code>:</p>
<pre><code>    module.exports = {
        entry: './src/js/index.js',
        output: {
            path: './dist/js',
            filename: 'bundle.js',
            publicPath: 'localhost:8080/dist'
        },
        devServer: {
            '/get': {
                targer: 'localhost:3000',
                secure: false
            }
        }
    }</code></pre>
<p>将<code>publicPath</code>字段的内容配置为绝对路径。同时<code>index.html</code>文件中对<code>js</code>引用的路径也改为绝对路径</p>
<pre><code>    &lt;script src="localhost:8080/dist/bundle.js"&gt;&lt;/script&gt;</code></pre>
<p>如果对<code>web-dev-server</code>还有其他问题的话，请留言告知。</p>
<p>另外2篇关于<code>webpack</code>的文章:</p>
<p><a href="https://segmentfault.com/a/1190000007962830">webpack1.x分包及异步加载套路</a><br><a href="https://segmentfault.com/a/1190000008279471">webpack2分包及异步加载套路</a></p>