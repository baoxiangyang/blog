<p>最近看到了很多公司都在准备明年的实习校招，虽然离三月份还有一段时间，感觉已经可以准备了。在网上看了一些排序算法和数组去重操作，感觉都写的很好，心血来潮，也来写一写。</p>
<p><img data-src="/img/remote/1460000008138239?w=690&amp;h=460" src="/img/remote/1460000008138239?w=690&amp;h=460.jpeg"></p>
<h2>排序算法的设计和实现</h2>
<p>说到排序，之前在做百度前端学院的题目的时候，也碰到过，并把它整理到 <a href="https://songjinzhong.github.io/BaiDu_IFE/stage2/task19/">github</a> 上。这是一个可视化的排序展示，支持冒泡、插入和选择排序，具体使用先 随机添加 40 个，然后点排序，就可以看到可视化的效果。</p>
<p>推荐一下，<a href="http://math.hws.edu/eck/jsdemo/sortlab.html">HTML5 Canvas Demo: Sorting Algorithms</a>，这里还有个可视化的<a href="http://coolshell.cn/articles/3933.html">排序博客</a>，各大排序算法的实现都栩栩如生。</p>
<p>javascript 写排序算法也比较奇葩，主要是参数的问题，比如 javascript 算法函数可以扔给 Array 原型：<code>Array.prototype.sort = function</code>，也可以直接写个函数带参数：<code>function sort(array){}</code>，在我看来，哪种方法都一样，需要注意的是兼容性的问题，如果可以考虑对所有可遍历对象都能排序（比如 arguments），才大法好。</p>
<p>好了，直接入主题了（下面的排序均是从小到大的顺序）。</p>
<h3>插入排序</h3>
<p>插入排序是一种基本排序，它的基本思路是构建有序序列，对于未排序的数据，在已排序的基础上，从右向左（或者二分查找）选择位置插入，<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">维基百科-插入排序</a>。</p>
<pre><code class="javascript">function insert_sort(input){
  var i, j, temp;
  for(i = 1; i &lt; input.length; i++){
    temp = input[i];
    for(j = i-1; j &gt;= 0 &amp;&amp; input[j] &gt; temp; j--)
      input[j+1] = input[j];
    input[j+1] = temp;
  }
  return input;
}</code></pre>
<p>如果以比较次数和移动次数来衡量算法的效率，最好情况下，比较 n-1 次，移动 0 次，最坏情况，比较 n*(n-1)/2 次，移动 n*(n-1)/2 次。</p>
<h3>二分插入排序</h3>
<p>思路基本同上，只是在查找插入位置的时候，不是依次查找，而是采用二分法：</p>
<pre><code class="javascript">function bin_insert_sort(input){
  var i, j, low, high, mid, temp;
  for(i = 1; i &lt; input.length; i++){
    temp = input[i];
    high = i - 1;
    low = 0;
    while(low &lt;= high){
      mid = parseInt((low + high) / 2);
      if(temp &lt; input[mid]){
        high = mid - 1;
      }else{
        low = mid + 1;
      }
    }
    // low 位置就是要插入的位置
    for(j = i-1; j &gt;= low; j--)
      input[j+1] = input[j];
    input[low] = temp;
  }
  return input;
}</code></pre>
<h3>希尔排序</h3>
<p>希尔排序其实是加强版的插入排序，就是在原先插入排序的基础上，加入了步长，原先插入排序的步长是 1，而且步长不同，效率也有差异，选择一个合适的步长也很重要。而且，希尔排序的最后一步，也必定是步长为 1 的插入排序，只不过此时整个排序已经基本稳定。<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">维基百科-希尔排序</a>。</p>
<pre><code class="javascript">function shell_sort(input){
  var gap, i, j, temp;
  gap = input.length &gt;&gt; 1;
  while(gap &gt; 0){
    for (i = gap; i &lt; input.length; i++) {
      temp = input[i];
      for (j = i - gap; j &gt;= 0 &amp;&amp; input[j] &gt; temp; j -= gap)
        input[j + gap] = input[j];
      input[j + gap] = temp;
    }
    gap = gap &gt;&gt; 1;
  }
  return input;
}</code></pre>
<h3>选择排序</h3>
<p>选择排序的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">维基百科-冒泡排序</a>。</p>
<pre><code class="javascript">function select_sort(input){
  var i, j, min, temp;
  for(i = 0; i &lt; input.length - 1; i++){
    min = i;
    for(j = i + 1; j &lt; input.length; j++){
      if(input[min] &gt; input[j])
        min = j;
    }
    temp = input[min];
    input[min] = input[i];
    input[i] = temp;
  }
  return input;
}</code></pre>
<p>选择排序在最好情况下，也要比较 n*(n-1)/2，移动 n-1 次（这里可以加个判断，移动 0 次），最差情况下，比较 n*(n-1)/2 次，移动 n-1 次。所有最好，最坏情况下，比较次数是一样的。</p>
<h3>冒泡排序</h3>
<p>冒泡排序的基本原理：对于带排序列，它会多次遍历序列，每次都会比较相邻的两个元素，若顺序相反，即交换它们，<a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">维基百科-冒泡排序</a>。</p>
<pre><code class="javascript">function bubble_sort(input){
  var i, j, temp, flag;
  for(i = 0; i &lt; input.length - 1; i++){
    flag = true;
    for(j = 0; j &lt; input.length - i; j++){
      if(input[j] &gt; input[j + 1]){
        temp = input[j];
        input[j] = input[j + 1];
        input[j + 1] = temp;
        flag = false;
      }
    }
    if(flag)
      // 提前结束
      break;
  }
  return input;
}</code></pre>
<p>有 flag 时，最好情况比较 n-1 次，移动 0 次，最坏情况，比较 n*(n-1)/2 次，交换 n*(n-1)/2。</p>
<h3>快排</h3>
<p>记得我一个同学去百度面试，百度面试官上来就让他手写了一个快排，可见对快排的掌握很重要呀，而且快排理解起来也不容易。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">维基百科-快排</a>。快排的基本思路就是选择一个元素，然后按照与这个元素的比较，将大于这个元素的都拿到右边，小于这个元素的都拿到左边，并找到这个元素的位置，这个元素的左右两边递归。</p>
<pre><code class="javascript">function quick_sort(input){
  function sort(start, end){
    if(start &gt;= end){
      return;
    }
    var mid = partition(start, end);
    sort(start, mid - 1);
    sort(mid + 1, end);
  }
  function partition(start, end){
    var left = start, right = end, key = input[start], temp;
    while(left &lt; right){
      while(left &lt; right &amp;&amp; input[right] &gt;= key){
        right --;
      }
      input[left] = input[right];
      while(left &lt; right &amp;&amp; input[left] &lt;= key){
        left ++;
      }
      input[right] = input[left];
    }
    input[left] = key;
    return left;
  }
  // main here
  sort(0, input.length - 1);
  return input;
}</code></pre>
<p>partition 函数就是来找对应的 mid，sort 函数用来排序。</p>
<p>关于快排的优化，可以从以下几个方面来考虑：</p>
<ol>
<li><p>partition 函数的哨兵（比较值）除了 start 以外，用其他位置（比如中位数）是否可行；</p></li>
<li><p>当 start 和 end 间距很小的时候，改用其他高效算法</p></li>
<li><p>还有就是优化递归。</p></li>
</ol>
<p>其实呢，上面的这个算法，并不属于 JavaScript 版本，而更像 C 版本的，重在让人理解快排，下面是 JS 版的快排，来体验下 JS 的迷人特性吧：</p>
<pre><code class="javascript">// javascript 版
function quick_sort(input) {
  var len = input.length;
  if (len &lt;= 1)
    return input.slice(0);
  var left = [];
  var right = [];
  // 基准函数
  var mid = [input[0]];
  for (var i = 1; i &lt; len; i++)
    if (input[i] &lt; mid[0])
      left.push(input[i]);
    else
      right.push(input[i]);
  return quick_sort(left).concat(mid.concat(quick_sort(right)));
};</code></pre>
<p>这个 JS 版快排也比较好懂，找到那个基准（这里是第一个元素 input[0]）之后，遍历，把小于基准的放到左边，大于基准的放到右边，然后返回拼接数组。</p>
<h3>归并排序</h3>
<p>在学习分治算法时，典型的一个例子就是归并。<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">维基百科-归并排序</a>。思路就是先分后和，依旧是递归。</p>
<pre><code class="javascript">function merge_sort(input){
  function merge(left, right){
    var temp = [];
    var i = 0, j = 0;
    while(i &lt; left.length &amp;&amp; j &lt; right.length){
      if(left[i] &lt; right[j]){
        temp.push(left[i]);
        i++;
      }else{
        temp.push(right[j]);
        j++;
      }
    }
    if(i &lt; left.length){
      temp = temp.concat(left.slice(i));
    }
    if(j &lt; right.length){
      temp = temp.concat(right.slice(j));
    }
    return temp;
  }
  if(input.length &lt;=1){
    return input;
  }
  var mid = parseInt(input.length / 2);
  return merge(merge_sort(input.slice(0, mid)), merge_sort(input.slice(mid)))
}</code></pre>
<p>同样，以上归并仍然是类似 C 语言版本，JavaScript 版本如下：</p>
<pre><code class="javascript">// javascript 版
function merge_sort(input) {
  var merge = function(left, right) {
    var final = [];
    while (left.length &amp;&amp; right.length)
      final.push(left[0] &lt;= right[0] ? left.shift() : right.shift());
    return final.concat(left.concat(right));
  };
  var len = input.length;
  if (len &lt; 2) return input;
  var mid = len / 2;
  return merge(merge_sort(input.slice(0, parseInt(mid))), merge_sort(input.slice(parseInt(mid))));
};</code></pre>
<p>数组的一系列操作大大优化排序的过程。</p>
<h3>堆排序</h3>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">维基百科-堆排序</a>。</p>
<p>其实，对于堆排序，只要牢记几个操作就可以，比如找到最后一个父节点，如何找到子节点（初始为 0），如何建立一个最大堆。</p>
<pre><code class="javascript">function heap_sort(input){
  var arr = input.slice(0);
  function swap(i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  // 上推操作
  function max_heapify(start, end) {
    var dad = start;
    var son = dad * 2 + 1;
    if (son &gt;= end)
      return;
    if (son + 1 &lt; end &amp;&amp; arr[son] &lt; arr[son + 1])
      son++;
    if (arr[dad] &lt;= arr[son]) {
      swap(dad, son);
      max_heapify(son, end);
    }
  }

  var len = arr.length;
  // 建立一个最大堆
  for (var i = Math.floor(len / 2) - 1; i &gt;= 0; i--)
    max_heapify(i, len);
  for (var i = len - 1; i &gt; 0; i--) {
    swap(0, i);
    max_heapify(0, i);
  }

  return arr;
};</code></pre>
<p>堆排序的过程大致如下：先生成一个最大堆，然后将根节点（最大元素）与最后一个元素交换，然后把剩下的 n-1 元素再次生成最大堆，交换，生成...</p>
<h2>总结</h2>
<p>那么问题来了，到底这些算法写的对不对，不然写个测试脚本来试试：</p>
<pre><code class="javascript">// 两种排序算法
var test = function(sort1, sort2){
  var arr1 = [], arr2 = [];
  // 随机生成 100 个 1～100 随机数
  function random_arr(a1, a2){
    var tmp;
    for(var i = 0; i &lt; 100; i++){
      tmp = parseInt(Math.random()*100) + 1;
      a1.push(tmp);
      a2.push(tmp);
    }
  }

  var flag = true;
  for(var i = 0; i &lt; 100; i++){
    random_arr(arr1, arr2);
    // 比较排序算法的结果
    if(sort1(arr1).toString() != sort2(arr2).toString()){
      flag = false;
      break;
    }
    arr1 = arr2 = [];
  }
  return flag ? "Ok!" : "Error!"
}

console.log(test(insert_sort, merge_sort)); //"Ok!"</code></pre>
<p>如果已知插入排序是正确的情况下，就可以验证归并排序是否正确了。共勉！</p>
<h2>参考</h2>
<blockquote><p><a href="https://zh.wikipedia.org/w/index.php?title=Special:%E6%90%9C%E7%B4%A2&amp;profile=default&amp;fulltext=Search&amp;search=%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;searchToken=2hr0n0ogeab2hwdmlm2z5ujdm">维基百科 排序搜索</a><br><a href="http://www.barretlee.com/blog/2016/08/11/algorithms-of-sort/">聊一聊排序算法</a><br><a href="http://www.cnblogs.com/JChen666/p/3360853.html">秒杀9种排序算法(JavaScript版)</a><br><a href="http://www.cnblogs.com/wteam-xq/p/4752610.html">排序图解：js排序算法实现</a></p></blockquote>
<p>欢迎来<a href="http://yuren.space">我的博客</a>交流</p>