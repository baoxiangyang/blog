http://www.qdfuns.com/notes/36539/24a66634ecba54ab3d8f7407168754f2.html">原文链接</a></p>
<h1>排序算法</h1>
<h2>1、冒泡排序</h2>
<pre><code class="javascript">function bubbleSort(arr){
  var i = 0,
      j = 0;
  for(i=1; i&lt;arr.length; i++){
    for(j=0; j&lt;=arr.length-i; j++){
      var temp = 0;
      // "&gt;" 从小到大排序
      // "&lt;" 从大到小排序
      if(arr[j] &gt; arr[j+1]){
        temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
  return arr;
}</code></pre>
<h2>2、快速排序</h2>
<pre><code class="javascript">function quickSort(arr,l,r){
  if(l &lt; r){
    var i = l, j = r, x = arr[i];
    while(i&lt;j){
      while(i&lt;j &amp;&amp; arr[j]&gt;x)
        j--;
      
      if(i&lt;j)
        //这里用i++，被换过来的必然比x小，赋值后直接让i自加，不用再比较，可以提高效率
        arr[i++] = arr[j];
      
      while(i&lt;j &amp;&amp; arr[i]&lt;x)
        i++;
      
      if(i&lt;j)
        //这里用j--，被换过来的必然比x大，赋值后直接让j自减，不用再比较，可以提高效率
        arr[j--] = arr[i];
    }
    arr[i] = x;
    
    quickSort(arr, l, i-1);
    quickSort(arr, i+1, r);
  }
}</code></pre>
<h2>3、二路归并</h2>
<pre><code class="javascript">function merge(left, right) {
    var result = [],
        il = 0,
        ir = 0;

    while (il &lt; left.length &amp;&amp; ir &lt; right.length) {
        if (left[il] &lt; right[ir]) {
            result.push(left[il++]);
        } else {
            result.push(right[ir++]);
        }
    }
    while(left[il]){
        result.push(left[il++]);
    }
    while(right[ir]){
        result.push(right[ir++]);
    }
    return result;
}</code></pre>
<h1>字符串操作</h1>
<h2>1、判断回文字符串</h2>
<pre><code class="javascript">function palindrome(str){
  // \W匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
  var re = /[\W_]/g;
  // 将字符串变成小写字符,并干掉除字母数字外的字符
  var lowRegStr = str.toLowerCase().replace(re,'');
  // 如果字符串lowRegStr的length长度为0时，字符串即是palindrome
  if(lowRegStr.length===0) return true;
  // 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome
  if(lowRegStr[0]!=lowRegStr[lowRegStr.length-1]) return false;
  //递归
  return palindrome(lowRegStr.slice(1,lowRegStr.length-1));
}</code></pre>
<h2>2、翻转字符串</h2>
<h3>思路一：反向遍历字符串</h3>
<pre><code class="javascript">function reverseString(str){
  var tmp = '';
  for(var i=str.length-1; i&gt;=0; i--)
    tmp += str[i];
  return tmp
}</code></pre>
<h3>思路二：转化成array操作</h3>
<pre><code class="javascript">function reverseString(str){
  var arr = str.split("");
  var i = 0,j = arr.length-1;
  while(i&lt;j){
    tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
    i++;
    j--;
  }
  return arr.join("");
}</code></pre>
<h2>3、生成指定长度随机字符串</h2>
<pre><code class="javascript">function randomString(n){
  var str = 'abcdefghijklmnopqrstuvwxyz0123456789';
  var tmp = '';
  for(var i=0; i&lt;n; i++) {
    tmp += str.charAt(Math.round(Math.random()*str.length));
  }
  return tmp;
}</code></pre>
<h2>4、统计字符串中次数最多字母</h2>
<pre><code class="javascript">function findMaxDuplicateChar(str) {
  if(str.length == 1) {
    return str;
  }
  var charObj = {};
  for(var i = 0; i &lt; str.length; i++) {
    if(!charObj[str.charAt(i)]) {
      charObj[str.charAt(i)] = 1;
    } else {
      charObj[str.charAt(i)] += 1;
    }
  }
  var maxChar = '',
      maxValue = 1;
  for(var k in charObj) {
    if(charObj[k] &gt;= maxValue) {
      maxChar = k;
      maxValue = charObj[k];
    }
  }
  return maxChar + '：' + maxValue;
}</code></pre>
<h1>数组操作</h1>
<h2>1、数组去重</h2>
<pre><code class="javascript">function unique(arr){
  var obj = {}
  var result = []
  for(var i in arr){
    if(!obj[arr[i]]){
      obj[arr[i]] = true;
      result.push(arr[i]);
    }
  }
  return result;
}</code></pre>
<h2>2、数组中最大差值</h2>
<pre><code class="javascript">function getMaxProfit(arr){
  var min = arr[0],
      max = arr[0];
  for(var i = 0; i &lt; arr.length; i++){
    if(arr[i] &lt; min) min = arr[i];
    if(arr[i] &gt; max) max = arr[i];
  }
  return max - min;
}</code></pre>
<h1>其他常见算法</h1>
<h2>1、阶乘</h2>
<h3>非递归实现</h3>
<pre><code class="javascript">function factorialize(num) {
  var result = 1;
    if(num &lt; 0) return -1;
    if(num == 0 || num == 1) return 1;
    while(num&gt;1) {
      result *= num--;
    }
    return result;
}</code></pre>
<h3>递归实现</h3>
<pre><code class="javascript">function factorialize(num) {
  var result = 1;
  if(num &lt; 0) return -1;
  if(num == 0 || num == 1) return 1;
  if(num &gt; 1) return num*factorialize(num-1);
}</code></pre>
<h2>2、生成菲波那切数列</h2>
<h3>强行递归实现</h3>
<pre><code class="javascript">function getfib(n){
  if(n == 0) return 0;
  if(n == 1) return 1;
  if(n &gt; 1) return getfib(n-1) + getfib(n-2);
}
function fibo(len){
    var fibo = [];
    for(var i = 0; i &lt; len; i++){
      fibo.push(getfib(i));
    }
    return fibo;
}</code></pre>
<h3>简约非递归实现</h3>
<pre><code class="javascript">function getFibonacci(n) {
  var fibarr = [];
  var i = 0;
  while(i &lt; n) {
    if(i &lt;= 1) {
      fibarr.push(i);
    } else {
      fibarr.push(fibarr[i - 1] + fibarr[i - 2])
    }
    i++;
  }
  return fibarr;
}</code></pre>
<h2>3、二分查找</h2>
<h3>非递归实现</h3>
<pre><code class="javascript">function binary_search(arr, key) {
  var low = 0,
      high = arr.length - 1;
  while(low &lt;= high){
    var mid = parseInt((high + low) / 2);
    if(key == arr[mid]){
      return mid;
    }else if(key &gt; arr[mid]){
      low = mid + 1;
    }else if(key &lt; arr[mid]){
      high = mid -1;
    }
  }
  return -1;
}</code></pre>
<h3>递归实现</h3>
<pre><code class="javascript">function binary_search2(arr, low, high, key) {
  if(low &gt; high) return -1;
  var mid = parseInt((low + high)/2);
  if(key == arr[mid]) {
    return mid;
  } else if(key &gt; arr[mid]) {
    return binary_search2(arr, mid+1, high, key);
  } else if(key &lt; arr[mid]) {
    return binary_search2(arr, low, mid-1, key);
  }