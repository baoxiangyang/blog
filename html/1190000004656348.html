<h2>源码地址</h2>
<blockquote><p>插件完整版地址 <a href="https://github.com/zhanyouwei/m-lazy">m-lazy</a><br><a href="https://github.com/zhanyouwei/m-lazy">https://github.com/zhanyouwei...</a></p></blockquote>
<h2>欢迎一起交流</h2>
<p>欢迎关注我的个人公众号，不定期更新自己的工作心得。<br><img data-src="/img/bVEk23?w=258&amp;h=258" src="/img/bVEk23?w=258&amp;h=258.jpeg"></p>
<h2>正文开始</h2>
<p>Web 图片的懒加载就是通过读取img元素，然后获得img元素的<code>data-src</code>（也可以约定为其他属性名）属性的值，并赋予<code>img</code>的src，从而实现动态加载图片的机制。</p>
<p><strong>这里需要注意的是：</strong> img在初始化的时候不要设置src属性，因为即使设置 <code>src=''</code> 浏览器也会尝试加载图片。</p>
<p>一个简单的图片懒加载共涉及两个方面，</p>
<h2>1. HTML 约定</h2>
<p>我们首先需要给准备实施懒加载的<code>img</code>元素添加指定的<code>class</code> 这里为<code>m-lazyload</code> ,同时将img src赋值给 data-src属性。<br>具体示例为：</p>
<pre><code>&lt;img class="m-lazyload" data-src="imgUrl"&gt;</code></pre>
<h2>2. JavaScript 实现</h2>
<p>动态加载总共分为以下几个步骤，这里每个步骤都将被拆分为独立的函数</p>
<h5>1. 添加页面滚动监听事件</h5>
<pre><code>window.addEventListener('scroll', _delay, false);

function _delay() {
  clearTimeout(delay);
  delay = setTimeout(function () {
    _loadImage();
  }, time);
}</code></pre>
<h5>2. 当触发监听事件时会执行 <code>_loadImage</code> 函数，该函数负责加载图片</h5>
<pre><code>function _loadImage() {
  for (var i = imgList.length; i--;) {
    var el = imgList[i];
    if (_isShow(el)) {
      el.src = el.getAttribute('data-src');
      el.className = el.className.replace(new RegExp("(\\s|^)" + _selector.substring(1, _selector.length) + "(\\s|$)"), " ");
      imgList.splice(i, 1);
    }
  }
}</code></pre>
<p>虽然执行了<code>_loadImage</code>函数，但是我们得知道哪些图片需要被加载，这里的判断依据是什么呢？</p>
<p>依据就是判断该图片是否在当前窗口的可视区域内，在这里我们封装一个<code>_isShow</code>函数来实现</p>
<pre><code>function _isShow(el) {
  var coords = el.getBoundingClientRect();
  return ( (coords.top &gt;= 0 &amp;&amp; coords.left &gt;= 0 &amp;&amp; coords.top) &lt;= (window.innerHeight || document.documentElement.clientHeight) + parseInt(offset));
}</code></pre>
<p>自此一个图片加载的闭环就形成了</p>
<p>当网页滚动的事件被触发 -&gt; 执行加载图片操作 -&gt; 判断图片是否在可视区域内 -&gt; 在，则动态将<code>data-src</code>的值赋予该图片。</p>
<h2>太简单了？</h2>
<p><strong>事实就是如此！！！</strong></p>
<h2>如此简单，不妨扩展一下</h2>
<ol>
<li><p>添加一些自定义参数，谁都喜欢自定义，不是吗？</p></li>
<li><p>支持<code>iScroll</code>, iScroll是一个高性能，资源占用少，无依赖，多平台的javascript滚动插件。</p></li>
</ol>
<h5>这里我们做了些优化</h5>
<ol>
<li><p>图片加载后移除选择器，避免重复判断。</p></li>
<li><p>缓存img元素结合，减少dom元素查询性能损耗</p></li>
<li><p>扩展<code>prototype</code>添加<code>getNode</code>方法，支持分页数据懒加载（由于我们之前缓存了dom元素）</p></li>
</ol>
<p>OK！说了这么多，show me the code 吧！</p>
<pre><code>
(function () {
  var imgList = [],  // 页面所有img元素集合
    delay,   // setTimeout 对象
    offset,  //偏移量，用于指定图片距离可视区域多少距离，进行加载
    time,  // 延迟载入时间
    _selector; // 选择器 默认为 .m-lazyload

  function _isShow(el) {
    var coords = el.getBoundingClientRect();
    return ( (coords.top &gt;= 0 &amp;&amp; coords.left &gt;= 0 &amp;&amp; coords.top) &lt;= (window.innerHeight || document.documentElement.clientHeight) + parseInt(offset));
  }

  function _loadImage() {
    for (var i = imgList.length; i--;) {
      var el = imgList[i];
      if (_isShow(el)) {
        el.src = el.getAttribute('data-src');
        el.className = el.className.replace(new RegExp("(\\s|^)" + _selector.substring(1, _selector.length) + "(\\s|$)"), " ");
        imgList.splice(i, 1);
      }
    }
  }

  function _delay() {
    clearTimeout(delay);
    delay = setTimeout(function () {
      _loadImage();
    }, time);
  }

  function ImageLazyload(selector, options) {
    var defaults = options || {};
    offset = defaults.offset || 0;
    time = defaults.time || 250;
    _selector = selector || '.m-lazyload';
    this.getNode();
    _delay();//避免首次加载未触发touch事件,主动触发一次加载函数
    if (defaults.iScroll) {
      defaults.iScroll.on('scroll', _delay);
      defaults.iScroll.on('scrollEnd', _delay);
    } else {
      window.addEventListener('scroll', _delay, false);
    }
  }
  ImageLazyload.prototype.getNode = function () {
    imgList = [];
    var nodes = document.querySelectorAll(_selector);
    for (var i = 0, l = nodes.length; i &lt; l; i++) {
      imgList.push(nodes[i]);
    }
  };
})();
</code></pre>