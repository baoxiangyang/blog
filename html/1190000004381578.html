<p><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html">参考资料</a></p>
<p>首先，网页大小与浏览器窗口大小从来都不是一回事！！！这尼玛最近才明白，坑~</p>
<p>所以，要知道以下常:</p>
<p><strong>网页的范围</strong><br>我们在代码里面设置的CSS或者js脚本，改变的样式就是网页范围下的改变，也就是说，我们设置的CSS大小是网页的不是浏览器窗口的大小。</p>
<p><strong>浏览器窗口</strong><br>浏览器窗口中看到的那部分<strong>实时动态</strong>的网页面积，又叫做viewport（视口）。</p>
<p><strong>为什么说是实时动态的窗口？</strong><br>比如，我上班时偷偷的新窗口打开淘宝，然后把窗口调的很小，这样老大就不会发觉拉。这样一来，本来全屏的窗口变成了小窗口，因此浏览器的窗口大小也就被改变了。</p>
<p>在不出现各种滚动条的情况下，viewport的大小和网页的大小是相同的。</p>
<h3>获取网页的大小的方法1</h3>
<p>clientHeight和clientWidth属性。这两个属性指元素的内容部分再加上padding的所占据的视觉面积，不包括border和滚动条占用的空间。<br>获取body的这两个属性，可以得出网页的大小。</p>
<p>盗个图说明一下：</p>
<p><img data-src="https://segmentfault.com/image?src=http://i260.photobucket.com/albums/ii7/ruanyf/blog/bg2009091402.gif&amp;objectId=1190000004381578&amp;token=4ff1bcf722d3363f25b1d7e5f7d826fe" src="/img/bg2009091402.gif&amp;objectId=1190000004381578&amp;token=4ff1bcf722d3363f25b1d7e5f7d826fe"></p>
<p>再盗个代码</p>
<pre><code>function getViewport(){
　　　　if (document.compatMode == "BackCompat"){
　　　　　　return {
　　　　　　　　width: document.body.clientWidth,
　　　　　　　　height: document.body.clientHeight
　　　　　　}
　　　　} else {
　　　　　　return {
　　　　　　　　width: document.documentElement.clientWidth,
　　　　　　　　height: document.documentElement.clientHeight
　　　　　　}
　　　　}
　　}</code></pre>
<p>注意事项</p>
<ol>
<li><p>这个函数必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错。</p></li>
<li><p>大多数情况下，都是document.documentElement.clientWidth返回正确值。但是，在IE6的quirks模式中，document.body.clientWidth返回正确的值，因此函数中加入了对文档模式的判断。</p></li>
<li><p>clientWidth和clientHeight都是只读属性，不能对它们赋值。</p></li>
</ol>
<h3>获取网页的大小的方法2</h3>
<p>document对象的scrollHeight和scrollWidth属性就是网页的大小，意思就是滚动条滚过的所有长度和宽度。</p>
<pre><code>function getPagearea(){
　　　　if (document.compatMode == "BackCompat"){
　　　　　　return {
　　　　　　　　width: Math.max(document.body.scrollWidth,
　　　　　　　　　　　　　　　　document.body.clientWidth),
　　　　　　　　height: Math.max(document.body.scrollHeight,
　　　　　　　　　　　　　　　　document.body.clientHeight)
　　　　　　}
　　　　} else {
　　　　　　return {
　　　　　　　　width: Math.max(document.documentElement.scrollWidth,
　　　　　　　　　　　　　　　　document.documentElement.clientWidth),
　　　　　　　　height: Math.max(document.documentElement.scrollHeight,
　　　　　　　　　　　　　　　　document.documentElement.clientHeight)
　　　　　　}
　　　　}
　　}</code></pre>
<h3>元素的绝对位置</h3>
<p>详见参考资料里面的函数</p>
<p><img data-src="https://segmentfault.com/image?src=http://i260.photobucket.com/albums/ii7/ruanyf/blog/bg2009091403.gif&amp;objectId=1190000004381578&amp;token=3030df6fbb09180d4da44802608cd105" src="/img/bg2009091403.gif&amp;objectId=1190000004381578&amp;token=3030df6fbb09180d4da44802608cd105"></p>
<h3>网页元素的相对位置</h3>
<p>详见参考资料里面的函数</p>
<p><img data-src="https://segmentfault.com/image?src=http://i260.photobucket.com/albums/ii7/ruanyf/blog/bg2009091404.gif&amp;objectId=1190000004381578&amp;token=9063e7b683007872b60acb89edb57c8c" src="/img/bg2009091404.gif&amp;objectId=1190000004381578&amp;token=9063e7b683007872b60acb89edb57c8c"></p>
<h3>获取元素位置的快速方法</h3>
<p><code>getBoundingClientRect()</code>:返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。</p>
<pre><code>　　var X= this.getBoundingClientRect().left;
　　var Y =this.getBoundingClientRect().top;</code></pre>
<p>再加上滚动距离，就可以得到绝对位置</p>
<pre><code>　　var X= this.getBoundingClientRect().left+document.documentElement.scrollLeft;
　　var Y =this.getBoundingClientRect().top+document.documentElement.scrollTop;</code></pre>
<p>目前，IE、Firefox 3.0+、Opera 9.5+都支持该方法，而Firefox 2.x、Safari、Chrome、Konqueror不支持。</p>