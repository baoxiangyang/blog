<p>前不久，做了一个H5项目，需要在横竖屏变化时，做一些处理。毫无疑问，需要使用<code>orientationchange</code>来监听横竖屏的变化。</p>
<h3>方案一：</h3>
<pre><code class="js">// 监听 orientation changes
window.addEventListener("orientationchange", function(event) {
    // 根据event.orientation|screen.orientation.angle等于0|180、90|-90度来判断横竖屏
}, false);</code></pre>
<p>代码添加上后，就各种兼容性问题。这里兼容性问题出现在两个地方：</p>
<ul>
<li><p><code>orientationchange</code></p></li>
<li><p><code>event.orientation|screen.orientation.angle</code></p></li>
</ul>
<h5>如下是<code>orientationchange</code>事件的兼容性：</h5>
<p><a href="http://www.quirksmode.org/dom/events/orientationchange.html"><img data-src="/img/remote/1460000006889507" src="/img/remote/1460000006889507.png"></a></p>
<h5>如下是<code>screen.orientation</code>的兼容性：</h5>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Screen/orientation"><img data-src="/img/remote/1460000006889508" src="/img/remote/1460000006889508.png"></a></p>
<h3>方案二：</h3>
<p>上述方案不行，只能另行他法了。google一下，了解到可以通过<code>resize</code>配合<code>(window.inner/outerWidth, window.inner/outerHeight)</code>来实现：</p>
<pre><code class="js">window.addEventListener("resize", function(event) {
    var orientation=(window.innerWidth &gt; window.innerHeight)? "landscape":"portrait";
    if(oritentation === 'portrait'){
        // do something ……
    } else {
        // do something else ……
    }
}, false);</code></pre>
<p>这种方案基本满足大部分项目的需求，但是还是有些不足之处：</p>
<ul>
<li><p>只要window的size变化，就会不断触发触发<code>resize</code>事件。可以使用setTimeout来优化一下</p></li>
<li><p>如果有多个地方需要监听横竖屏，就需要注册多个<code>window.addEventListener("resize", function(event) {……})</code>。能不能通过<code>订阅与发布模式</code>来改进一下，只注册一个<code>resize</code>负责监听横竖屏变化，只要横竖发生变化就发布通知订阅的对象。其他需要监听横竖屏的地方只需订阅一下即可。</p></li>
</ul>
<p>关键代码如下：</p>
<pre><code class="js">    var resizeCB = function(){
      if(win.innerWidth &gt; win.innerHeight){//初始化判断
        meta.init = 'landscape';
        meta.current = 'landscape';
      } else {
        meta.init = 'portrait';
        meta.current = 'portrait';
      }
      return function(){
        if(win.innerWidth &gt; win.innerHeight){
          if(meta.current !== 'landscape'){
            meta.current = 'landscape';
            event.trigger('__orientationChange__', meta);
          }
        } else {
          if(meta.current !== 'portrait'){
            meta.current = 'portrait';
            event.trigger('__orientationChange__', meta);
          }
        }
      }
    }();</code></pre>
<p><a href="https://github.com/zhansingsong/orientationchange-fix/blob/master/other/pl_2.js">完整代码猛击这里</a></p>
<h3>方案三：</h3>
<p>不过个人觉得通过<code>window.innerWidth &gt; window.innerHeight</code>来实现的是一种伪检测，有点不可靠。 可不可以通过浏览器来实现检测？如基于CSS3<code>@media</code>媒体查询来实现。</p>
<p>如下<code>@media</code>兼容性：<br><a href="http://caniuse.com/#feat=css-mediaqueries"><img data-src="/img/remote/1460000006889509" src="/img/remote/1460000006889509.png"></a><br>如上上图所示，移动端浏览器都支持CSS3 media。</p>
<h5>实现思路：</h5>
<ul>
<li><p>创建包含标识横竖屏状态的特定css样式</p></li>
<li><p>通过JS向页面中注入CSS代码</p></li>
<li><p>resize回调函数中获取横竖屏的状态</p></li>
</ul>
<p>这里我选择<code>&lt;html&gt;&lt;/html&gt;</code>的节点<code>font-family</code>作为检测样式属性。理由如下：</p>
<ul>
<li><p>选择<code>&lt;html&gt;&lt;/html&gt;</code>主要为了避免reflow和repaint</p></li>
<li><p>选择<code>font-family</code>样式，主要是因为<code>font-family</code>有如下特性：</p></li>
</ul>
<blockquote><ul>
<li><p>优先使用排在前面的字体。</p></li>
<li><p>如果找不到该种字体，或者该种字体不包括所要渲染的文字，则使用下一种字体。</p></li>
<li><p>如果所列出的字体，都无法满足需要，则让操作系统自行决定使用哪种字体。</p></li>
</ul></blockquote>
<p>这样我们就可以指定特定标识来标识横竖屏的状态，不过需要将指定的标识放置在其他字体的前面，这样就不会引起hmtl字体的变化。</p>
<p>关键代码如下：</p>
<pre><code class="js">    // callback
    var resizeCB = function() {
        var hstyle = win.getComputedStyle(html, null),
            ffstr = hstyle['font-family'],
            pstr = "portrait, " + ffstr,
            lstr = "landscape, " + ffstr,
            // 拼接css
            cssstr = '@media (orientation: portrait) { .orientation{font-family:' + pstr + ';} } @media (orientation: landscape) {  .orientation{font-family:' + lstr + ';}}';
        // 载入样式        
        loadStyleString(cssstr);
        // 添加类
        html.className = 'orientation' + html.className;
        if (hstyle['font-family'] === pstr) { //初始化判断
            meta.init = 'portrait';
            meta.current = 'portrait';
        } else {
            meta.init = 'landscape';
            meta.current = 'landscape';
        }
        return function() {
            if (hstyle['font-family'] === pstr) {
                if (meta.current !== 'portrait') {
                    meta.current = 'portrait';
                    event.trigger('__orientationChange__', meta);
                }
            } else {
                if (meta.current !== 'landscape') {
                    meta.current = 'landscape';
                    event.trigger('__orientationChange__', meta);
                }
            }
        }
    }();</code></pre>
<p><a href="https://github.com/zhansingsong/orientationchange-fix/blob/master/other/pl_3.js">完整代码猛击这里</a></p>
<h4>测试效果</h4>
<ul>
<li><p>portrait效果：<br><img data-src="/img/remote/1460000006889510" src="/img/remote/1460000006889510.png"></p></li>
<li><p>landscape效果：<br><img data-src="/img/remote/1460000006889511" src="/img/remote/1460000006889511.png"></p></li>
</ul>
<h2>方案四：</h2>
<p>可以再改进一下，在支持<code>orientationchange</code>时，就使用原生的<code>orientationchange</code>，不支持则使用<strong>方案三</strong>。</p>
<p>关键代码如下：</p>
<pre><code class="js">// 是否支持orientationchange事件
var isOrientation = ('orientation' in window &amp;&amp; 'onorientationchange' in window);
// callback
var orientationCB = function(e) {
    if (win.orientation === 180 || win.orientation === 0) {
        meta.init = 'portrait';
        meta.current = 'portrait';
    }
    if (win.orientation === 90 || win.orientation === -90) {
        meta.init = 'landscape';
        meta.current = 'landscape';
    }
    return function() {
        if (win.orientation === 180 || win.orientation === 0) {
            meta.current = 'portrait';
        }
        if (win.orientation === 90 || win.orientation === -90) {
            meta.current = 'landscape';
        }
        event.trigger(eventType, meta);
    }
};
var callback = isOrientation ? orientationCB() : (function() {
    resizeCB();
    return function() {
        timer &amp;&amp; win.clearTimeout(timer);
        timer = win.setTimeout(resizeCB, 300);
    }
})();
// 监听
win.addEventListener(isOrientation ? eventType : 'resize', callback, false);</code></pre>
<p><a href="https://github.com/zhansingsong/orientationchange-fix/blob/master/other/pl_orientation.js">完整代码猛击这里</a></p>
<h2>方案五：</h2>
<p>目前，上述几种方案都是通过自定制的<strong>订阅与发布</strong>事件模式来实现的。这里可以基于浏览器的事件机制，来模拟<code>orientationchange</code>。即对<code>orientationchange</code>的不兼容进行修复。</p>
<p>关键代码如下：</p>
<pre><code class="js">var eventType = 'orientationchange';
// 触发原生orientationchange
var fire = function() {
    var e;
    if (document.createEvent) {
        e = document.createEvent('HTMLEvents');
        e.initEvent(eventType, true, false);
        win.dispatchEvent(e);
    } else {
        e = document.createEventObject();
        e.eventType = eventType;
        if (win[eventType]) {
            win[eventType]();
        } else if (win['on' + eventType]) {
            win['on' + eventType]();
        } else {
            win.fireEvent(eventType, e);
        }
    }
}</code></pre>
<p><a href="https://github.com/zhansingsong/orientationchange-fix/blob/master/src/orientationchange-fix.js">完整代码猛击这里</a></p>
<p>通过上述5种方案，自己对移动端横竖屏检测有了更进一步的认识，有些东西只有自己亲身经历过才知道为什么要这么写，自己也把其中缘由记录在文章中，希望对大家有帮助。经过5种方案的演变得到了最终<code>orientationchange-fix</code>，github地址：<a href="https://github.com/zhansingsong/orientationchange-fix">https://github.com/zhansingsong/orientationchange-fix</a></p>