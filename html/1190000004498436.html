<h2>正则表达式</h2>
<p><code>var expression = / pattern / flags;</code></p>
<p><strong>flags:</strong>每个正则表达式都可带一个或多个标志，用以标明正则表达式的行为</p>
<ul>
<li><p>g:表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止。</p></li>
<li><p>i:表示不区分大小写模式</p></li>
<li><p>m:表示多行模式，即在到达文本末尾时还会继续查找下一行中是否与模式匹配的项。</p></li>
</ul>
<h3>正则表达式中的元字符</h3>
<blockquote><p>这些元字符在正则表达式都有一种或者多种用途。因此如果想要匹配字符串中包含的这些字符必须转义。下面将描述元字符在模式中的各种应用。</p></blockquote>
<p><code>( [ { \ ^ $ | ) ? * .] }</code></p>
<table>
<thead><tr>
<th>字符</th>
<th>含义</th>
</tr></thead>
<tbody>
<tr>
<td>\t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\cX</td>
<td>与X对应的控制字符（Ctrl+X）</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\0</td>
<td>空字符</td>
</tr>
</tbody>
</table>
<h4>类</h4>
<blockquote><p>所谓类是指，符合某些特征的对象，是一个泛指，而不是特指某个字符。</p></blockquote>
<p>使用元字符[ ]构建类。</p>
<p><strong>1.[ ]:构建简单类</strong></p>
<p><code>[abc]</code><br><img data-src="/img/bVs2oB" src="/img/bVs2oB.png"><br><strong>2.^:与[ ]并用构建反向类</strong></p>
<p><code>[^abc]</code><br><img data-src="/img/bVs2oL" src="/img/bVs2oL.png"></p>
<p><strong>3.范围类</strong><br><code>[a-zA-Z]</code><br><img data-src="/img/bVs2oR" src="/img/bVs2oR.png"></p>
<h4>边界</h4>
<blockquote><p>单独使用^代表以xxx开头</p></blockquote>
<table>
<thead><tr><th>边界元字符</th></tr></thead>
<tbody>
<tr>
<td>^</td>
<td>以xxx开头</td>
</tr>
<tr>
<td>$</td>
<td>以xxx结尾</td>
</tr>
<tr>
<td>\b</td>
<td>单词边界</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界</td>
</tr>
</tbody>
</table>
<p><code>^ab</code><br><img data-src="/img/bVs2oY" src="/img/bVs2oY.png"><br><code>ab$</code><br><img data-src="/img/bVs2o3" src="/img/bVs2o3.png"><br><code>\ba</code> <br><img data-src="/img/bVs2o9" src="/img/bVs2o9.png"><br><code>a\b</code> <br><img data-src="/img/bVs2pe" src="/img/bVs2pe.png"></p>
<h4>或</h4>
<blockquote><p>元字符|代表或</p></blockquote>
<p><code>a|c</code> <br><img data-src="/img/bVs2pg" src="/img/bVs2pg.png"></p>
<h4>预定义类</h4>
<table>
<thead><tr>
<th>字符</th>
<th>等价类</th>
<th> </th>
</tr></thead>
<tbody>
<tr>
<td>.</td>
<td><sup><a class="footnote-ref">1</a></sup></td>
<td>除了回车符和换行符之外的所有字符</td>
</tr>
<tr>
<td>\d</td>
<td>[0-9]</td>
<td>数字字符</td>
</tr>
<tr>
<td>\D</td>
<td><sup><a class="footnote-ref">2</a></sup></td>
<td>非数字字符</td>
</tr>
<tr>
<td>\s</td>
<td>[\t\n\x0B\f\r]</td>
<td>空白符</td>
</tr>
<tr>
<td>\S</td>
<td><sup><a class="footnote-ref">3</a></sup></td>
<td>非空白符</td>
</tr>
<tr>
<td>\w</td>
<td>[a-zA-Z_0-9]</td>
<td>单词字符，字母、数字下划线</td>
</tr>
<tr>
<td>\W</td>
<td><sup><a class="footnote-ref">4</a></sup></td>
<td>非单词字符</td>
</tr>
</tbody>
</table>
<h4>分组</h4>
<blockquote><p>使用元字符( )进行分组</p></blockquote>
<p><code>(ab)</code> <br><img data-src="/img/bVs2pi" src="/img/bVs2pi.png"><br><strong>嵌套分组(捕获组):</strong><code>(ab(cd))</code> <br><img data-src="/img/bVs2pk" src="/img/bVs2pk.png"><br><strong>忽略分组:</strong>有时候我们不希望捕获某些分组，只需要在分组内加上 ?:就可以了，这并不意味着该分组内容不属于正则表达式，只是不会给这个分组加编号了而已<br><code>(ab(?:cd))</code><br><img data-src="/img/bVs2pr" src="/img/bVs2pr.png"></p>
<h4>量词</h4>
<blockquote><p>代表出现次数,次数都为正整数</p></blockquote>
<table>
<thead><tr><th>量词元字符</th></tr></thead>
<tbody>
<tr>
<td>?</td>
<td>出现0次或1次      <strong>[0,1]</strong>
</td>
</tr>
<tr>
<td>+</td>
<td>至少出现1次       <strong>&gt;=1</strong>
</td>
</tr>
<tr>
<td>*</td>
<td>出现0次或多次     <strong>&gt;=0</strong>
</td>
</tr>
</tbody>
</table>
<p><strong>{ }元字符</strong><br>{n}   :出现n次        <br>{n,m} :出现n到m次   <br>{n,}  :至少出现n次  <br>{0,m} :最多出现m次</p>
<h5>贪婪模式与非贪婪模式</h5>
<blockquote><p>{3,5}到底代表匹配3次，4次还是5次呢？在贪婪模式下会尽可能的多的匹配，也就是说会匹配5次，默认是贪婪模式。而在非贪婪模式下则尽可能少的匹配，也就说会匹配3次，在量词后面加上<code>?</code>即可</p></blockquote>
<p>贪婪模式<code>'123456789'.replace(/\d{5,8}/g,'O');//"O9"</code><br>非贪婪模式<code>'123456789'.replace(/\d{5,8}?/g,'O');//"06789"</code></p>
<h4>前瞻</h4>
<table>
<thead><tr>
<th>表达式</th>
<th>含义</th>
</tr></thead>
<tbody>
<tr>
<td>exp1(?=exp2)</td>
<td>匹配后面是exp2的exp1</td>
</tr>
<tr>
<td>exp1(?!exp2)</td>
<td>匹配后面不是exp2的exp</td>
</tr>
</tbody>
</table>
<p><code>good(?=bad)</code> ![]()<br><code>good(?!bad)</code> ![]()</p>
<h3>正则表达式实例方法</h3>
<h4>exec()</h4>
<blockquote><p>参数:接收一个参数，即要应用模式的 <strong>字符串</strong>。<br>返回:第一个匹配项信息的数组，或者在没有匹配项的情况下返回null。</p></blockquote>
<p>返回的数组包含两个额外的信息:index和input。index匹配项在字符串中的位置，input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项)</p>
<pre><code>var text = 'mom and dad and baby';
var pattern = /mom( and dad)( and baby?)?/g

var matches = pattern.exec(text);

matches// ["mom and dad and baby", " and dad", " and baby"]
matches.index// 0
matches.input// 'mom and dad and baby'

// 忽略分组
var matches = /mom(?: and dad)(?: and baby?)?/g.exec(text)
matches// ["mom and dad and baby"]

var matches = /mom( and dad)(?: and baby?)?/g.exec(text)
matches// ["mom and dad and baby", " and dad"]

var matches = /mom(?: and dad)( and baby?)?/g.exec(text)
matches// ["mom and dad and baby", " and baby"]</code></pre>
<p><strong>Note:</strong>对于<code>exec()</code>方法即使在模式中设置了全局标志(g),它每次也只返回一个匹配项。但是在同一个字符串上多次调用<code>exec()</code>则会在字符串中查找新匹配项。而在不设置全局标志的情况下，在同一个字符串上多次调用<code>exe()</code>，始终返回第一个匹配项信息。</p>
<pre><code>/*非全局调用*/
var reg1 = /\d/;
/*全局调用*/
var reg2 = /\d/g;

reg1.exec('a1b2c3');//["1"]
reg1.exec('a1b2c3');//["1"]
reg2.exec('a1b2c3');//["1"]
reg2.exec('a1b2c3');//["2"]
reg2.exec('a1b2c3');//["3"]
reg2.exec('a1b2c3');//null

while(r=reg.exec('a1b3c3')){
console.log(r.index+':'+r[0])
}//1:1 3:2x 5:3</code></pre>
<h4>test()</h4>
<blockquote><p>参数:接收一个字符串参数</p></blockquote>
<p>返回:布尔值<br>在想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。</p>
<pre><code>var text = '000-00-0000';
var pattern = /\d{3}-\d{2}-\d{4}/;

if(pattern.test(text)){
    console.log('The pattern was matched')
} // The pattern was matched</code></pre>
<pre><code>//分组()-&gt;$1分组内匹配
'a1b2c3'.replace(/a(\d)b(\d)c(\d)/g,'a$1-b$2-c$3');//"a1-b2-c3"
'a%1b%2c%3'.replace(/%(\d)%/,'#$1#');//"a#1#b%2%c%3%"

//忽略分组
'a1b2c3'.replace(/a(?:\d)b(?:\d)c(?:\d)/g,'a$1-b$2-c$3');//"a$1-b$2-c$3"

//前瞻
'goodByron'.replace(/good(?=Byron)/g,'T');//"TByron"
'goodByron'.replace(/good(?!Byron)/g,'T');//"goodByron"'</code></pre>
<p>lastIndex:告诉已经搜到哪了，下一次从那开始</p>
<pre><code>var reg = /\d+/g;

reg.test('a1b2c3');//true
reg.lastIndex//2
reg.test('a1b2c3');//true
reg.lastIndex;//4
reg.test('a1b2c3');//true
reg.lastIndex//6
reg.test('a1b2c3');//false
reg.lastIndex;//0</code></pre>
<p>参考网站:<a href="http://regexper.com/">Regexper</a></p>
<hr>
<ol>
<li>\r\n <a class="footnote-backref">↩</a>
</li>
<li>0-9 <a class="footnote-backref">↩</a>
</li>
<li>\t\n\x0B\f\r <a class="footnote-backref">↩</a>
</li>
<li>a-zA-Z_0-9 <a class="footnote-backref">↩</a>
</li>
</ol>