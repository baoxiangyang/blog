对象是通过MSXML库中的ActiveX对象实现的。在IE中可能会遇到三种不同版本的XHR对象，即MSXML2.XMLHttp、MSXML2.XMLHttp.3.0和MXSML.XMLHttp.6.0。</p>
<p>适用于IE7之前的浏览器的代码：</p>
<pre><code>function createXHR() {
    if (typeof arguments.callee.activeXString != "string") {
        var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"],
            i, len;
        for (var i = 0, len = versions.length; i &lt; len; i++) {
            try {
                new ActiveXObject(versions[i]);
                arguments.callee.activeXString = versions[i];
                break;
            } catch (e) {
                //
            }
        }
    }
    return new ActiveXObject(arguments.callee.activeXString);
}
</code></pre>
<p><strong>IE7之后的版本和其他浏览器都会使用下面的函数来创建：</strong></p>
<pre><code>var xhr = new XMLHttpRequest();
</code></pre>
<p>兼容代码：</p>
<pre><code>function createXHR() {
    if (typeof XMLHttpRequest != "undefined") {
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != "undefined") {
        if (typeof arguments.callee.activeXString != "string") {
            var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"],
                i, len;
            for (var i = 0, len = versions.length; i &lt; len; i++) {
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                    break;
                } catch (e) {
                    //
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error("No XHR Object available.");
    }
}
</code></pre>
<p>兼容代码的应用：</p>
<pre><code>var xhr = new createXHR();
</code></pre>
<h1>XHR的用法</h1>
<p>在使用XHR对象时，要调用的第一方法时</p>
<ul><li><p><code>open（）</code>，它接收三个参数：要发送请求的<strong>类型</strong>，请求的<strong>URL</strong>和表示<strong>是否异步</strong>发送请求的布尔值。</p></li></ul>
<p>如：</p>
<pre><code>xhr.open("get", "note.txt", false);
</code></pre>
<p>open()表示启动一个请求以备发送，send()方法才是真正的发送；</p>
<p>要发送特定的请求，要向下面一样调用</p>
<ul><li><p><code>send()</code>方法：</p></li></ul>
<p>如：</p>
<pre><code>xhr.open("get", "note.txt", false);
xhr.send(null);
</code></pre>
<p>XHR从服务器返回后，发生变化的属性，即保存服务器相应数据的属性为：</p>
<ul>
<li><p><code>responseText</code>:作为响应主体被返回的文本</p></li>
<li><p><code>responseXML</code>:如果响应类型是"text/xml"和"application/xml"，则保存着响应数据的XML DOM文档</p></li>
<li><p><code>status</code>：响应的HTTP状态</p></li>
<li><p><code>statusText</code>：HTTP状态的说明</p></li>
</ul>
<p>一般来说，可以将HTTP状态吗为200作为成功标志，此时responseText属性内容准备就绪，responseXML也应该能够访问。此外状态吗为304表示请求的资源没有被修改，可以直接使用浏览器中缓存的版本。</p>
<p>完整代码如下：</p>
<pre><code>var xhr = new XMLHttpRequest();

xhr.open("get", "note.txt", false);
xhr.send(null);

if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
    document.write(xhr.responseText);
} else {
    alert("Request was unsuccessful: " + xhr.status);
}
</code></pre>
<p>要注意的是：</p>
<p>我们在多数情况下都要发送异步请求的，才能让js继续执行而不必等待响应。</p>
<p>可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下：</p>
<ul>
<li><p>0：未初始化。尚未调用open()；</p></li>
<li><p>1：启动。已经调用open()但未调用send()；</p></li>
<li><p>2：发送。已经调用send()但尚未接收到响应；</p></li>
<li><p>3：接收。已经接收到部分响应数据；</p></li>
<li><p>4：完成。已经接收到全部响应数据，而且可以在客户端中使用；</p></li>
</ul>
<p>具体格式如下：</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300) || xhr.status == 304) {
            //......
        }
    }
};
xhr.open("get", "user.json", true);
xhr.send();
</code></pre>
<p>举个例子：</p>
<p>json文件：</p>
<pre><code>[{
    "name": "oliver",
    "age": 18,
    "user": true
}, {
    "name": "troy",
    "age": 26,
    "user": true
}]
</code></pre>
<p>dom：</p>
<pre><code>&lt;pre id="pre"&gt;&lt;/pre&gt;
&lt;button id="btn"&gt;insert&lt;/button&gt;
</code></pre>
<p>js：</p>
<pre><code>var btn = document.getElementById("btn"),
    pre = document.getElementById("pre"),
    obj = null;

btn.onclick = function() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300) || xhr.status == 304) {
                console.log(xhr.responseText);
                obj = JSON.parse(xhr.responseText);
                pre.innerHTML = obj[1].name; //troy
            }
        }
    };
    xhr.open("get", "user.json", true);
    xhr.send();
};
</code></pre>
<p>当点击btn时，pre部分显示获取的json文件中的部分信息。</p>
<p>另外在接收到响应之前还可以调用</p>
<ul><li><p><code>abort()</code>方法来取消异步请求。</p></li></ul>
<p>如下所示：</p>
<pre><code>
xhr.abort();
</code></pre>
<p>在终止请求之后，还应该对XHR对象进行解引用操作。<strong>由于内存原因，不建议重用XHR对象。</strong></p>
<h1>HTTP头部信息</h1>
<p>XHR对象提供了操作请求头部和响应头部信息的方法。 在默认情况下，在发送XHR请求同时，还会发送下列头部信息：</p>
<ul>
<li><p>Accept： 浏览器能够处理的内容类型</p></li>
<li><p>Accept - Charset： 浏览器能够显示的字符集</p></li>
<li><p>Accept - Encoding: 浏览器能够处理的压缩编码</p></li>
<li><p>Accept - Language: 浏览器当前设置的语言</p></li>
<li><p>Connection: 浏览器与服务器之间连接的类型</p></li>
<li><p>Cookie: 当前页面设置的任何Cookie</p></li>
<li><p>Host: 发送请求的页面所在的域</p></li>
<li><p>Referer: 发送请求的页面的URI</p></li>
<li><p>User - Agent: 浏览器的用户代理字符串</p></li>
</ul>
<p>使用</p>
<ul><li><p><code>setRequestHeader()</code>方法可以设置自定义的请求头部信息。</p></li></ul>
<p>这个方法接收两个参数： 头部字段名和头部字段值。 要成功发送请求头部信息， 必须在调用open（） 方法之后且send（） 方法之前调用它。 建议使用自定义的头部名称。如：</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300) || xhr.status == 304) {
            //......
        }
    }
};
xhr.open("get", "user.json", true);
xhr.setRequestHeader("MyHeader", "MyValue"); //这里定义
xhr.send();
</code></pre>
<p>另外，调用XHR对象的<code>getResponseHeader()</code>方法传入头部字段名称，可以取得相应的响应头部信息。而调用<code>getAllResponseHeaders()</code>方法则可以取得一个包含所有头部信息的长字符串：</p>
<pre><code>var myHeader = xhr.getResponseHeader("MyHeader");
var allHeaders = xhr.getAllResponseHeaders();
</code></pre>
<h1>GET请求</h1>
<p>用encodeURIComponent()编码后的格式如下：</p>
<pre><code>xhr.open("get", "example.php?name1=value1&amp;name2=value2", true);
</code></pre>
<p>下面的函数可以辅助向现有的URL的末尾添加查询字符串参数：</p>
<pre><code>function addURLParam(url, name, value) {
    url += (url.indexOf("?") == -1 ? "?" : "&amp;"); //检查URL是否包含问号（以确定是否已经有参数存在），没有就加上问好，否则添加一个和号
    url += encodeURIComponent(name) + "=" + encodeURIComponent(value);
    return url;
}
</code></pre>
<p>举个例子：</p>
<pre><code>var url = "example.php";
url = addURLParam(url, "name", "oli");
url = addURLParam(url, "book", "js");
xhr.open("get", url, false);
</code></pre>
<h1>POST请求</h1>
<p>POST请求通常用于向服务器发送应该保存的数据</p>
<p>使用post提交，要设置头部属性Content-type。如果不设置，会出现数据无