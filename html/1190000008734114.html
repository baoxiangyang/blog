<blockquote><p>Webpack是模块打包工具。</p></blockquote>
<p><strong><a href="https://webpack.js.org/">Webpack</a>已成为现代Web开发最重要的工具之一。首先，它是一个JavaScript模板打包工具，他能转换所有的前端资源，如HTML和CSS，甚至图片。它可以让你更好地控制你应用程序的HTTP请求数量，并允许你使用其他的风格资源（如Jade，Sass和ES6）。Webpack还允许你轻松地从npm上使用软件包。</strong></p>
<p>本文面向刚刚接触Webpack的初学者，主要介绍Webpack的初始设置和配置、模板、加载程序、插件、代码拆分和热模块替换。如果你发现视频教程对你更有帮助，我强烈推荐Glen Maddern’s的<a href="https://www.youtube.com/watch?v=WQue1AN93YU">Webpack from First Principles</a>作为一个起点，了解是什么使得Webpack那么特别。</p>
<p>接下来，你需要有<a href="https://www.sitepoint.com/quick-tip-multiple-versions-node-nvm/">Node.js installed</a>环境，你也可以 <a href="https://github.com/sitepoint-editors/webpack-demo">download the demo app from our Github repo</a></p>
<h2>Setup</h2>
<p>让我们用<code>npm</code>新建一个项目并初始化，安装<code>Webpack</code>:</p>
<pre><code>mkdir webpack-demo
cd webpack-demo
npm init -y
npm install webpack@beta --save-dev
mkdir src
touch index.html src/app.js webpack.config.js</code></pre>
<p>编辑这些文件：</p>
<pre><code>&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello webpack&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script src="dist/bundle.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="JavaScript">// src/app.js
const root = document.querySelector('#root')
root.innerHTML = `&lt;p&gt;Hello webpack.&lt;/p&gt;`</code></pre>
<pre><code class="JavaScript">// webpack.config.js
const webpack = require('webpack')
const path = require('path')

const config = {
  context: path.resolve(__dirname, 'src'),
  entry: './app.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  },
  module: {
    rules: [{
      test: /\.js$/,
      include: path.resolve(__dirname, 'src'),
      use: [{
        loader: 'babel-loader',
        options: {
          presets: [
            ['es2015', { modules: false }]
          ]
        }
      }]
    }]
  }
}

module.exports = config</code></pre>
<p>上面的配置是一个常见的起点，它指示<code>webpack</code>将我们的入口点<code>src/app.js</code>编译输出到<code>/dist/bundle.js</code>中，所有的<code>.js</code>文件将通过<code>Babel</code>从<code>ES2015</code>转换到<code>ES5</code>。</p>
<p>为了让它运行，我们需要安装三个包：<code>babel-core</code>，<code>Webpack</code>模块和资源转换器——<code>babel-loader</code>和预设的<code>babel-preset-es2015</code>。<br><code>{ modules: false }</code>启用<a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html">Tree Shaking</a>把我们包中不被使用的输出删除，从而降低文件大小。</p>
<pre><code>npm install babel-core babel-loader babel-preset-es2015 --save-dev</code></pre>
<p>最后，将<code>package.json</code>文件中的<code>script</code>部分替换为：</p>
<pre><code class="json">"scripts": {
  "start": "webpack --watch",
  "build": "webpack -p"
},</code></pre>
<p>在命令行中运行<code>npm start</code>来监视模式启动<code>webpack</code>——每当我们<code>src</code>目录中的<code>.js</code>文件更改时，都会重新编译输出到<code>bundle</code>中。控制台中的输出会告诉我们正在创建的包，重要的是要注意包的数量和大小。<br><img data-src="/img/bVKLwP?w=744&amp;h=274" src="/img/bVKLwP?w=744&amp;h=274.png"><br>现在你应该可以在浏览器中加载<code>index.html</code>，并使用“Hello webpack”。</p>
<pre><code>open index.html</code></pre>
<p>打开<code>dist/bundle.js</code>查看<code>webpack</code>做了什么，顶部是<code>webpack</code>的模板引导代码，底部是我们的模板。也许你对这不会有很深刻的印象，但如果你跟着进度学到了这里，你可以运用<code>ES6 module</code>和<code>webpack</code>生产一个能在所有浏览器中运行的用于生产的包。</p>
<p>输入命令行<code>Ctrl + C</code>停止<code>webpack</code>，并运行<code>npm run build</code>用于在生产模式下编译我们的包。</p>
<p>请注意，此时包的大小已经从2.16kB下降到585字节。<br>再查看一下<code>dist/bundle.js</code>，你会看到一个丑恶的代码，我们的包已经压缩或丑化（uglify/minify），代码运行效果是一样的，但它并不符合最少字符需要。</p>
<h2>Modules</h2>
<p>开箱即用的<code>webpack</code>知道如何使用各种格式的JavaScript模块，最显著的两种是：</p>
<ul>
<li><p>ES2015的<code>import</code>语句</p></li>
<li><p>CommonJS的<code>require()</code>语句</p></li>
</ul>
<p>我们可以通过安装<a href="https://lodash.com/">lodash</a>并从<code>app.js</code>导入它来测试一下：</p>
<pre><code>npm install lodash --save</code></pre>
<pre><code class="JavaScript">// src/app.js
import {groupBy} from 'lodash/collection'

const people = [{
  manager: 'Jen',
  name: 'Bob'
}, {
  manager: 'Jen',
  name: 'Sue'
}, {
  manager: 'Bob',
  name: 'Shirley'
}, {
  manager: 'Bob',
  name: 'Terrence'
}]
const managerGroups = groupBy(people, 'manager')

const root = document.querySelector('#root')
root.innerHTML = `&lt;pre&gt;${JSON.stringify(managerGroups, null, 2)}&lt;/pre&gt;`</code></pre>
<p>运行<code>npm start</code>启动<code>webpack</code>，刷新一下<code>index.html</code>页面，你可以看到按<code>manager</code>排序的人数组。</p>
<p>让我们来把<code>people</code>数组移动到自己的<code>people.js</code>文件中：</p>
<pre><code class="JavaScript">// src/people.js
const people = [{
  manager: 'Jen',
  name: 'Bob'
}, {
  manager: 'Jen',
  name: 'Sue'
}, {
  manager: 'Bob',
  name: 'Shirley'
}, {
  manager: 'Bob',
  name: 'Terrence'
}]

export default people</code></pre>
<p>我们可以使用相对路径简单地从<code>app.js</code>导入它。</p>
<pre><code class="JavaScript">// src/app.js
import {groupBy} from 'lodash/collection'
import people from './people'

const managerGroups = groupBy(people, 'manager')

const root = document.querySelector('#root')
root.innerHTML = `&lt;pre&gt;${JSON.stringify(managerGroups, null, 2)}&lt;/pre&gt;`</code></pre>
<p>注意：没有相对路径的导入，如<code>lodash/collection</code>是从<code>npm</code>安装到<code>node_modules</code>的模块，自己写的模块是需要加一个相对路径,如<code>./people</code>来告诉<code>webpack</code>区分好各个模块。</p>
<h2>Loaders</h2>
<p>我们已经介绍了<code>babel-loader</code>——很多<a href="https://webpack.js.org/loaders/">loders</a>之一，通过配置用于告诉<code>webpack</code>当遇到不同文件类型的<code>import</code>时要怎么做。你可以把过个<code>loader</code>整合在一起，我们可以通过从<code>JavaScript</code>中导入<code>Sass</code>来很好地了解这是如何工作的。</p>
<h4>Sass</h4>
<p>这种转换涉及到三个独立的<code>loader</code>和<code>node-sass</code>库：</p>
<pre><code>npm install css-loader style-loader sass-loader node-sass --save-dev</code></pre>
<p>在<code>webpack.config.js</code>中给我们的<code>.scss</code>文件添加新的配置规则：</p>
<pre><code class="JavaScript">// webpack.config.js
rules: [{
  test: /\.scss$/,
  use: [
    'style-loader',
    'css-loader',
    'sass-loader'
  ]
}, {
  // ...
}]</code></pre>
<blockquote><p>注意：每次更改<code>webpack.config.js</code>中的任何规则时，都需要使用<code>Ctrl+C</code>和<code>npm start</code>命令重新启动项目。</p></blockquote>
<p><code>loader</code>数组会以相反的顺序执行：</p>
<ul>
<li><p><code>sass-loader</code> 把Sass转换成CSS</p></li>
<li><p><code>css-loader</code> 把CSS解析到JavaScript中，并分解所有的依赖关系</p></li>
<li><p><code>style-loader</code> 把我们的CSS输出到文档中的&lt;style&gt;标签中</p></li>
</ul>
<p>你可以把它当做函数调用，一个<code>loader</code>的输出会作为<code>input</code>输入下一个。</p>
<pre><code>styleLoader(cssLoader(sassLoader('source')))</code></pre>
<p>让我们来添加一个Sass源文件：</p>
<pre><code class="Sass">/* src/style.scss */
$bluegrey: #2B3A42;

pre {
  padding: 20px;
  background: $bluegrey;
  color: #dedede;
  text-shadow: 0 1px 1px rgba(#000, .5);
}</code></pre>
<p>你现在可以从JavaScript中直接请求Sass，从<code>app.js</code>的头部引入：</p>
<pre><code>// src/app.js
import './style.scss'

// ...</code></pre>
<p>刷新一下<code>index.html</code>你就会看到刚添加的样式了。</p>
<h4>CSS in JS</h4>
<p>我们刚刚从JavaScript中导入了Sass文件，作为一个模块。</p>
<p>打开<code>dist/bundle.js</code>文件并搜索<code>“pre {</code>。事实上，我们的Sass已经被编译成一个CSS字符串，并保存为我们的<code>bundle</code>中的一个模板。当我们在JavaScript中导入此模板时，<code>style-loader</code>会将该字符串输出到嵌入的<code>&lt;style&gt;</code>标签中。</p>
<p>我知道你肯定是在想，为什么会这样？</p>
<p>我不会在这里深入讨论这个话题，但是你可以从以下几个方面考虑：</p>
<ul>
<li><p>你可能希望包含在项目中的JavaScript组件依赖于其他资源（HTML、CSS、Images、SVG）来正常运行，如果这些资源可以整合在一起，那么导入和使用就会容易很多。</p></li>
<li><p>消除死代码：当JS代码不需要导入JS组件时，将不再导入CSS，生成的<code>bundle</code>只会包含执行某些操作的代码。</p></li>
<li><p>CSS模块：CSS的全局命名空间使得开发者很难确信CSS的一个更改不会产生任何的副作用。<a href="https://github.com/css-modules/css-modules">CSS modules</a>通过在默认情况下使CSS local和暴露在JavaScript下使用的唯一类名来改变这一问题。</p></li>
<li><p>通过巧妙的方法打包/拆分代码，来较少HTTP请求数量。</p></li>
</ul>
<h4>Images</h4>
<p>我们能够看到的最后一个关于<code>loader</code>的例子是使用<code>url-loader</code>处理图片。</p>
<p>在标准的HTML文档中，当浏览器遇到一个<code>&lt;img&gt;</code>标签或<code>background-image</code>属性时会抓取图片。使用webpack，当遇到小图片的时候，你可以通过将图片源作为字符串存储在JavaScript中来优化小图片，这样，你预加载它们，浏览器就不用为了提取它们而发起单独的请求了。</p>
<pre><code>npm install file-loader url-loader --save-dev</code></pre>
<p>添加一个加载图片的规则：</p>
<pre><code class="JavaScript">// webpack.config.js
rules: [{
  test: /\.(png|jpg)$/,
  use: [{
    loader: 'url-loader',
    options: { limit: 10000 } // Convert images &lt; 10k to base64 strings
  }]
}, {
  // ...
}]</code></pre>
<p>重新运行项目：<code>Ctrl + C</code>和<code>npm start</code></p>
<p>使用下面命令下载<a href="https://raw.githubusercontent.com/sitepoint-editors/webpack-demo/master/src/code.png">test image</a></p>
<pre><code>curl https://raw.githubusercontent.com/sitepoint-editors/webpack-demo/master/src/code.png --output src/code.png</code></pre>
<p>你现在可以在<code>app.js</code>的头部导入图片源：</p>
<pre><code class="JavaScript">// src/app.js
import codeURL from './code.png'
const img = document.createElement('img')
img.src = codeURL
img.style.backgroundColor = "#2B3A42"
img.style.padding = "20px"
img.width = 32
document.body.appendChild(img)

// ...</code></pre>
<p>这将包括一张图片，其中<code>src</code>属性包含图片本身的<code>data URL</code>:</p>
<pre><code class="HTML">&lt;img src="data:image/png;base64,iVBO..." style="background: #2B3A42; padding: 20px" width="32"&gt;</code></pre>
<p>此外，由于使用<code>url()</code>引用的<code>css-loader</code>图片也通过<code>url-loader</code>运行，这就好像直接在CSS中嵌入它们。</p>
<pre><code>/* src/style.scss */
pre {
  background: $bluegrey url('code.png') no-repeat center center / 32px 32px;
}</code></pre>
<p>编译成为：</p>
<pre><code>pre {
    background: #2b3a42 url("data:image/png;base64,iVBO...") no-repeat scroll center center / 32px 32px;
}</code></pre>
<h4>Modules to Static Assets</h4>
<p>你现在应该可以看到<code>loders</code>是如何帮助在资源间建立一个依赖关系树的，这是webpack首页上的图片展示：<br><img data-src="/img/bVKObk?w=1634&amp;h=700" src="/img/bVKObk?w=1634&amp;h=700.png"></p>
<p>尽管JavaScript是入口点，但webpack注意到你的其他资源（如HTML、CSS和SVG）都具有各自的依赖关系——这些依赖关系是应该视为构建过程的一部分的。</p>
<blockquote><p>作者：<a href="https://www.sitepoint.com/author/mbrown/">Mark Brown</a><br>原文链接：<a href="https://www.sitepoint.com/beginners-guide-to-webpack-2-and-module-bundling/#plugins">A Beginner’s Guide to Webpack 2 and Module Bundling</a></p></blockquote>