<p>先前一直比较关注前端的东西，对后端了解较少。不过一直对Node.js比较感兴趣，去年12月还去参加了阿里的CNODE交流聚会。</p>

<p>以后希望通过这里的博客分享一些学习Node.js的笔记。一方面总结了自己的学习心得，另一方面也可以和大家一起分享交流。</p>

<p>嗯，大概就是这样子。</p>

<p>这篇就先介绍一个Node.js的模块——<a rel="nofollow" href="https://github.com/mikeal/request">request</a>。有了这个模块，http请求变的超简单。</p>

<p><img data-src="https://segmentfault.com/image?src=https://nodei.co/npm/request.png&amp;objectId=1190000000385867&amp;token=b4e3d02d2e65d8e77ae7f27bdaa7b93d" src="/img/request.png&amp;objectId=1190000000385867&amp;token=b4e3d02d2e65d8e77ae7f27bdaa7b93d"></p>

<h2>使用超简单</h2>

<p>Request使用超简单，同时支持https和重定向。</p>

<pre><code class="lang-js">var request = require('request');
request('http://www.google.com', function (error, response, body) {
  if (!error &amp;&amp; response.statusCode == 200) {
    console.log(body) // 打印google首页
  }
})
</code></pre>

<h2>流</h2>

<p>任何响应都可以输出到文件流。</p>

<pre><code class="lang-js">request('http://google.com/doodle.png').pipe(fs.createWriteStream('doodle.png'))
</code></pre>

<p>反过来，也可以将文件传给PUT或POST请求。未提供header的情况下，会检测文件后缀名，在PUT请求中设置相应的<code>content-type</code>。</p>

<pre><code class="lang-js">fs.createReadStream('file.json').pipe(request.put('http://mysite.com/obj.json'))
</code></pre>

<p>请求也可以<code>pipe</code>给自己。这种情况下会保留原<code>content-type</code>和<code>content-length</code>。</p>

<pre><code>request.get('http://google.com/img.png').pipe(request.put('http://mysite.com/img.png'))
</code></pre>

<h2>表单</h2>

<p><code>request</code>支持<code>application/x-www-form-urlencoded</code>和<code>multipart/form-data</code>实现表单上传。</p>

<p><code>x-www-form-urlencoded</code>很简单：</p>

<pre><code class="lang-js">request.post('http://service.com/upload', {form:{key:'value'}})
</code></pre>

<p>或者：</p>

<pre><code class="lang-js">request.post('http://service.com/upload').form({key:'value'})
</code></pre>

<p>使用<code>multipart/form-data</code>不用操心设置header之类的琐事，<code>request</code>会帮你解决。</p>

<pre><code class="lang-js">var r = request.post('http://service.com/upload')
var form = r.form()
form.append('my_field', 'my_value')
form.append('my_buffer', new Buffer([1, 2, 3]))
form.append('my_file', fs.createReadStream(path.join(__dirname, 'doodle.png'))
form.append('remote_file', request('http://google.com/doodle.png'))
</code></pre>

<h2>HTTP认证</h2>

<pre><code class="lang-js">request.get('http://some.server.com/').auth('username', 'password', false);
</code></pre>

<p>或</p>

<pre><code class="lang-js">request.get('http://some.server.com/', {
  'auth': {
    'user': 'username',
    'pass': 'password',
    'sendImmediately': false
  }
});
</code></pre>

<p><code>sendImmediately</code>，默认为真，发送一个基本的认证header。设为<code>false</code>之后，收到<code>401</code>会重试（服务器的401响应必须包含<code>WWW-Authenticate</code>指定认证方法）。</p>

<p>sendImmediately为真时支持Digest认证。</p>

<h2>OAuth登录</h2>

<pre><code class="lang-js">// Twitter OAuth
var qs = require('querystring')
  , oauth =
    { callback: 'http://mysite.com/callback/'
    , consumer_key: CONSUMER_KEY
    , consumer_secret: CONSUMER_SECRET
    }
  , url = 'https://api.twitter.com/oauth/request_token'
  ;
request.post({url:url, oauth:oauth}, function (e, r, body) {
  // Ideally, you would take the body in the response
  // and construct a URL that a user clicks on (like a sign in button).
  // The verifier is only available in the response after a user has
  // verified with twitter that they are authorizing your app.
  var access_token = qs.parse(body)
    , oauth =
      { consumer_key: CONSUMER_KEY
      , consumer_secret: CONSUMER_SECRET
      , token: access_token.oauth_token
      , verifier: access_token.oauth_verifier
      }
    , url = 'https://api.twitter.com/oauth/access_token'
    ;
  request.post({url:url, oauth:oauth}, function (e, r, body) {
    var perm_token = qs.parse(body)
      , oauth =
        { consumer_key: CONSUMER_KEY
        , consumer_secret: CONSUMER_SECRET
        , token: perm_token.oauth_token
        , token_secret: perm_token.oauth_token_secret
        }
      , url = 'https://api.twitter.com/1/users/show.json?'
      , params =
        { screen_name: perm_token.screen_name
        , user_id: perm_token.user_id
        }
      ;
    url += qs.stringify(params)
    request.get({url:url, oauth:oauth, json:true}, function (e, r, user) {
      console.log(user)
    })
  })
})
</code></pre>

<h2>定制HTTP header</h2>

<p><code>User-Agent</code>之类可以在<code>options</code>对象中设置。在下面的例子中，我们调用github API找出某仓库的收藏数和派生数。我们使用了定制的<code>User-Agent</code>和https.</p>

<pre><code class="lang-js">var request = require('request');

var options = {
    url: 'https://api.github.com/repos/mikeal/request',
    headers: {
        'User-Agent': 'request'
    }
};

function callback(error, response, body) {
    if (!error &amp;&amp; response.statusCode == 200) {
        var info = JSON.parse(body);
        console.log(info.stargazers_count + " Stars");
        console.log(info.forks_count + " Forks");
    }
}

request(options, callback);
</code></pre>

<h2>cookies</h2>

<p>默认情况下，cookies是禁用的。在<code>defaults</code>或<code>options</code>将<code>jar</code>设为<code>true</code>，使后续的请求都使用cookie.</p>

<pre><code class="lang-js">var request = request.defaults({jar: true})
request('http://www.google.com', function () {
  request('http://images.google.com')
})
</code></pre>

<p>通过创建<code>request.jar()</code>的新实例，可以使用定制的cookie，而不是<code>request</code>全局的cookie jar。</p>

<pre><code class="lang-js">var j = request.jar()
var request = request.defaults({jar:j})
request('http://www.google.com', function () {
  request('http://images.google.com')
})
</code></pre>

<p>或者</p>

<pre><code class="lang-js">var j = request.jar()
var cookie = request.cookie('your_cookie_here')
j.setCookie(cookie, uri, function (err, cookie){})
request({url: 'http://www.google.com', jar: j}, function () {
  request('http://images.google.com')
})
</code></pre>

<p>注意，<code>setCookie</code>至少需要三个参数，最后一个是回调函数。</p>

<h2>项目主页</h2>

<p><a rel="nofollow" href="https://github.com/mikeal/request">request的GitHub主页</a></p>