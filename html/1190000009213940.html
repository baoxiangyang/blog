<p>在 HTML5 的本地存储中，有一种叫 indexedDB 的数据库，该数据库是一种存储在客户端本地的 NoSQL 数据库，它可以存储大量的数据。从上篇：<a href="https://github.com/lin-xin/blog/issues/11">HTML5 进阶系列：web Storage</a> ，我们知道 web Storage 可以方便灵活的在本地存取简单数据，但是对于大量结构化存储，indexedDB 的优势就更加明显。接下来我们来看看 indexedDB 如何存储数据。</p>
<h2>连接数据库</h2>
<p>一个网站可以有多个 indexedDB 数据库，但每个数据库的名称是唯一的。我们需要通过数据库名来连接某个具体的数据库。</p>
<pre><code class="js">var request = indexedDB.open('dbName', 1);  // 打开 dbName 数据库
request.onerror = function(e){              // 监听连接数据库失败时执行
    console.log('连接数据库失败');
}
request.onsuccess = function(e){            // 监听连接数据库成功时执行
    console.log('连接数据库成功');
}</code></pre>
<p>我们使用 indexedDB.open 方法来连接数据库，该方法接收两个参数，第一个是数据库名，第二个是数据库版本号。该方法会返回一个 IDBOpenDBRequest 对象，代表一个请求连接数据库的请求对象。我们可以通过监听请求对象的 onsuccess 和 onerror 事件来定义连接成功或失败需执行的方法。</p>
<p>因为 indexedDB API 中不允许数据库中的数据仓库在同一版本中发生变化，所以需要在 indexedDB.open 方法中传入新的版本号来更新版本，避免在同一版本中重复修改数据库。版本号必须为整数！</p>
<pre><code class="js">var request = indexedDB.open('dbName', 2);  // 更新版本，打开版本为2的数据库
// ...
request.onupgradeneeded = function(e){
    console.log('新数据库版本号为=' + e.newVersion);
}</code></pre>
<p>我们通过监听请求对象的 onupgradeneeded 事件来定义数据库版本更新时执行的方法。</p>
<h2>关闭数据库</h2>
<p>使用 indexedDB.open 连接数据库成功后会返回一个 IDBOpenDBRequest 对象，我们可以调用该对象的 close 方法来关闭数据库。</p>
<pre><code class="js">var request = indexedDB.open('dbName', 2);
// ...
request.onsuccess = function(e){
    console.log('连接数据库成功');
    var db = e.target.result;
    db.close();
    console.log('数据库已关闭');
}</code></pre>
<h2>删除数据库</h2>
<pre><code class="js">
indexedDB.deleteDatabase('dbName');
console.log('数据库已删除');</code></pre>
<h2>创建对象仓库</h2>
<p>object store（对象仓库）是 indexedDB 数据库的基础，在indexedDB 中并没有数据库表，而对象仓库，就是相当于一个数据库表。</p>
<pre><code class="js">var request = indexedDB.open('dbName', 3);
// ...
request.onupgradeneeded = function(e){
    var db = e.target.result;
    var store = db.createObjectStore('Users', {keyPath: 'userId', autoIncrement: false});
    console.log('创建对象仓库成功');
}</code></pre>
<p>db.createObjectStore 方法接收两个参数，第一个为对象仓库名，第二个参数为可选参数，值为一个js对象。该对象中的 keyPath 属性为主键，相当于数据库表中 id 为主键。autoIncrement 属性为 false，则表示主键值不自增，添加数据时需指定主键值。</p>
<p>注意：在数据库中，对象仓库名不可重复，否则浏览器会报错。</p>
<h2>创建索引</h2>
<p>indexedDB 数据库中通过数据对象的某个属性来创建索引，在数据库中进行检索时，只能通过被设为索引的属性进行检索。</p>
<pre><code class="js">var request = indexedDB.open('dbName', 4);
// ...
request.onupgradeneeded = function(e){
    var db = e.target.result;
    var store = db.createObjectStore('newUsers', {keyPath: 'userId', autoIncrement: false});
    var idx = store.createIndex('usernameIndex','userName',{unique: false})
    console.log('创建索引成功');
}</code></pre>
<p>store.createIndex 方法接收三个参数，第一个为索引名，第二个为数据对象的属性，上例中使用 userName 属性来创建索引，第三个参数为可选参数，值为一个js对象。该对象中的 unique 属性为 true，代表索引值不可以相同，即两条数据的 userName 不可以相同，为 false 则可以相同。</p>
<h2>基于事务</h2>
<p>在 indexedDB 中，所有数据操作都只能在事务中执行。连接数据库成功后，可以使用 IDBOpenDBRequest 对象的 transaction 方法开启只读事务或读写事务。</p>
<pre><code class="js">var request = indexedDB.open('dbName', 5);
// ...
request.onupgradeneeded = function(e){
    var db = e.target.result;
    var tx = db.transaction('Users','readonly');
    tx.oncomplete = function(e){
        console.log('事务结束了');
    }
    tx.onabort = function(e){
        console.log('事务被中止了');
    }
}</code></pre>
<p>db.transaction 方法接收两个参数，第一个参数可以是字符串或数组，字符串时则是一个对象仓库名，数组时则是由对象仓库名组成的数组，transaction 可以对参数中任何一个对象仓库进行操作。第二个参数为事务模式，传入 readonly 时只能对对象仓库进行读操作，无法写操作。可以传入 readwrite 进行读写操作。</p>
<h2>操作数据</h2>
<ul>
<li><p>add() : 增加数据。接收一个参数，为需要保存到对象仓库中的对象。</p></li>
<li><p>put() : 增加或修改数据。接收一个参数，为需要保存到对象仓库中的对象。</p></li>
<li><p>get() : 获取数据。接收一个参数，为需要获取数据的主键值。</p></li>
<li><p>delete() : 删除数据。接收一个参数，为需要获取数据的主键值。</p></li>
</ul>
<pre><code class="js">var request = indexedDB.open('dbName', 5);
// ...
request.onsuccess = function(e){
    var db = e.target.result;
    var tx = db.transaction('Users','readwrite');
    var store = tx.objectStore('Users');
    var value = {
        'userId': 1,
        'userName': 'linxin',
        'age': 24
    }
    var req1 = store.put(value);        // 保存数据
    var req2 = store.get(1);            // 获取索引userId为1的数据
    req2.onsuccess = function(){
        console.log(this.result.userName);    // linxin
    }
    var req3 = store.delete(1);             // 删除索引为1的数据
    req3.onsuccess = function(){
        console.log('删除数据成功');        // 删除数据成功
    }
}</code></pre>
<p>add 和 put 的作用类似，区别在于 put 保存数据时，如果该数据的主键在数据库中已经有相同主键的时候，则会修改数据库中对应主键的对象，而使用 add 保存数据，如果该主键已经存在，则保存失败。</p>
<h2>检索数据</h2>
<p>上面我们知道使用 get() 方法可以获取数据，但是需要制定主键值。如果我们想要获取一个区间的数据，可以使用游标。游标通过对象仓库的 openCursor 方法创建并打开。</p>
<p>openCursor 方法接收两个参数，第一个是 IDBKeyRange 对象，该对象创建方法主要有以下几种：</p>
<pre><code class="js">// boundRange 表示主键值从1到10(包含1和10)的集合。
// 如果第三个参数为true，则表示不包含最小键值1，如果第四参数为true，则表示不包含最大键值10，默认都为false
var boundRange = IDBKeyRange.bound(1, 10, false, false);

// onlyRange 表示由一个主键值的集合。only() 参数则为主键值，整数类型。
var onlyRange = IDBKeyRange.only(1);

// lowerRaneg 表示大于等于1的主键值的集合。
// 第二个参数可选，为true则表示不包含最小主键1，false则包含，默认为false
var lowerRange = IDBKeyRange.lowerBound(1, false);

// upperRange 表示小于等于10的主键值的集合。
// 第二个参数可选，为true则表示不包含最大主键10，false则包含，默认为false
var upperRange = IDBKeyRange.upperBound(10, false);</code></pre>
<p>openCursor 方法的第二个参数表示游标的读取方向，主要有以下几种：</p>
<ul>
<li><p>next : 游标中的数据按主键值升序排列，主键值相等的数据都被读取</p></li>
<li><p>nextunique : 游标中的数据按主键值升序排列，主键值相等只读取第一条数据</p></li>
<li><p>prev : 游标中的数据按主键值降序排列，主键值相等的数据都被读取</p></li>
<li><p>prevunique : 游标中的数据按主键值降序排列，主键值相等只读取第一条数据</p></li>
</ul>
<pre><code class="js">var request = indexedDB.open('dbName', 6);
// ...
request.onsuccess = function(e){
    var db = e.target.result;
    var tx = db.transaction('Users','readwrite');
    var store = tx.objectStore('Users');
    var range = IDBKeyRange.bound(1,10);
    var req = store.openCursor(range, 'next');
    req.onsuccess = function(){
        var cursor = this.result;
        if(cursor){
            console.log(cursor.value.userName);
            cursor.continue();
        }else{
            console.log('检索结束');
        }
    }
}</code></pre>
<p>当存在符合检索条件的数据时，可以通过 update 方法更新该数据：</p>
<pre><code class="js">cursor.updata({
    userId : cursor.key,
    userName : 'Hello',
    age : 18
});</code></pre>
<p>可以通过 delete 方法删除该数据：</p>
<pre><code class="js">cursor.delete();</code></pre>
<p>可以通过 continue 方法继续读取下一条数据，否则读到第一条数据之后不再继续读取：</p>
<pre><code class="js">cursor.continue();</code></pre>
<h2>总结</h2>
<p>从连接数据库，创建对象仓库、索引，到操作、检索数据，完成了 indexedDB 存取数据的完整流程。下面通过一个完整的例子来更好地掌握 indexedDB 数据库。代码地址：<a href="https://github.com/lin-xin/blog/tree/master/indexedDB-demo">indexedDB-demo</a></p>
<h3>更多文章：<a href="https://github.com/lin-xin/blog/">lin-xin/