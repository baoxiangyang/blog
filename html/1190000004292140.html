e>sequelize</code> 过程中发现一个“奇怪”的问题，将某个时间插入到表中后，通过 <code>sequelize</code> 查询出来的时间和通过 <code>mysql</code> 命令行工具查询出来的时间不一样。非常困惑，于是研究了下，下面是学习成果。</p>
<h2>基本概念</h2>
<p>我们先来介绍一些可能当年在地理课上学习过的基本概念。</p>
<p>说起来，时间真是一个神奇的东西。以前人们通过观察太阳的位置来决定时间（比如：使用日晷），这就使得不同经纬度的地区时间是不一样的。后来人们进一步规定以子午线为中心，向东西两侧延伸，每 15 度划分一个时区，刚好是 24 个时区。然后因为一天有 24 小时，地球自转一圈是 360 度，360 度 / 24 小时 = 15 度/小时，所以每差一个时区，时间就差一个小时。</p>
<p>最开始的标准时间（子午线中心处的时间）是英国伦敦的皇家格林威治天文台的标准时间（因为它刚好在本初子午线经过的地方），这就是我们常说的 <code>GMT</code>（Greenwich Mean Time）。然后其他各个时区根据标准时间确定自己的时间，往东的时区时间晚（表示为 GMT+hh:mm）、往西的时区时间早（表示为 GMT-hh:mm）。比如，中国标准时间是东八区，我们的时间就总是比 <code>GMT</code> 时间晚 8 小时，他们在凌晨 1 点，我们已经是早晨 9 点了。</p>
<p>但是 <code>GMT</code> 其实是根据地球自转、公转计算的（太阳每天经过英国伦敦皇家格林威治天文台的时间为中午 12 点），不是非常准确，于是后面提出了根据原子钟计算的标准时间 <code>UTC</code>（Coordinated Universal Time）。</p>
<p>一般情况下，<code>GMT</code> 和 <code>UTC</code> 可以互换，但是实际上，<code>GMT</code> 是一个时区，而 <code>UTC</code> 是一个时间标准。</p>
<p>可以在这里看到所有的时区：<a href="http://www.timeanddate.com/time/map/">http://www.timeanddate.com/time/map/</a></p>
<p>所以，当我们“展示”某个时间时，明确时区就变得非常重要了。不然你只说现在是 <code>2016-01-11 19:30:00</code>，然后不告诉我时区，我其实是没法准确知道时间的（当然，我可以认为这个时间是我所在时区的当地时间）。如果你说现在是 <code>2016-01-11 19:30:00 GMT+0800</code>，那我就知道这个时间是东八区的时间了。如果我在东八区，那时间就是 19:30，如果我在 <code>GMT</code> 时区，那时间就是 11:30（减掉 8 小时）。</p>
<h2>JavaScript 中的“时间”</h2>
<p>我们现在来介绍下 JavaScript 中的“时间”，包括：<code>Date</code>、<code>Date.parse</code>、<code>Date.UTC</code>、<code>Date.now</code>。</p>
<p>注：下面的代码示例可以在 node shell 里面运行，如果你运行的时候结果和下面的不一致，那可能咱们不在一个时区：）</p>
<h3>Date 构造器</h3>
<p>构造时间的方法有下面几种：</p>
<pre><code class="javascript">new Date();           // 当前时间
new Date(value);      // 自 1970-01-01 00:00:00 UTC 经过的毫秒数
new Date(dateString); // 时间字符串
new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);</code></pre>
<p>需要注意的是：构造出的日期用来显示时，会被转换为本地时间（调用 <code>toString</code> 方法）：</p>
<pre><code class="javascript">&gt; new Date()
Mon Jan 11 2016 20:15:18 GMT+0800 (CST)</code></pre>
<p>打印出我写这篇文章时的本地时间。后面的 <code>GMT+0800</code> 表示是“东八区”，<code>CST</code> 表示是“中国标准时间（China Standard Time）”。</p>
<p>有一个很“诡异”的地方是如果我们直接使用 <code>Date</code>，而不是 <code>new Date</code>，得到的将会是字符串，而不是 <code>Date</code> 类型的对象：</p>
<pre><code class="javascript">&gt; typeof Date()
'string'
&gt; typeof new Date()
'object'</code></pre>
<h4>时间字符串</h4>
<p>我们先说最复杂的时间字符串形式。它实际上支持两种格式：一种是 RFC-2822 的标准；另一种是 ISO 8601 的标准。我们主要介绍后一种。</p>
<h5>ISO 8601</h5>
<p>ISO 8601的标准格式是：<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>，分别表示：</p>
<ul>
<li><p><code>YYYY</code>：年份，0000 ~ 9999</p></li>
<li><p><code>MM</code>：月份，01 ~ 12</p></li>
<li><p><code>DD</code>：日，01 ~ 31</p></li>
<li><p><code>T</code>：分隔日期和时间</p></li>
<li><p><code>HH</code>：小时，00 ~ 24</p></li>
<li><p><code>mm</code>：分钟，00 ~ 59</p></li>
<li><p><code>ss</code>：秒，00 ~ 59</p></li>
<li><p><code>.sss</code>：毫秒</p></li>
<li><p><code>Z</code>：时区，可以是：<code>Z</code>（UFC）、<code>+HH:mm</code>、<code>-HH:mm</code></p></li>
</ul>
<p>这里我们主要来说下 <code>T</code>、以及 <code>Z</code>。</p>
<h6>T</h6>
<p><code>T</code> 也可以用空格表示，但是这两种表示有点不一样，<code>T</code> 其实表示 <code>UTC</code>，而空格会被认为是本地时区（前提是不通过 <code>Z</code> 指定时区）。比如下面的例子：</p>
<pre><code class="javascript">&gt; new Date('1970-01-01 00:00:00')
Thu Jan 01 1970 00:00:00 GMT+0800 (CST)

&gt; new Date('1970-01-01T00:00:00')
Thu Jan 01 1970 08:00:00 GMT+0800 (CST)</code></pre>
<p>示例 1 的空格表示法被当做了本地时区，所以显示的时间和传入的时间一致。</p>
<p>示例 2 的 <code>T</code> 被当做 <code>UTC</code> 时间，所以显示的时间会加上本地时区（东八区）的 8 小时偏移。实际上，<code>1970-01-01T00:00:00</code> 等价于 <code>1970-01-01 00:00:00Z</code>。</p>
<h6>Z</h6>
<p><code>Z</code> 用来表示传入时间的时区（zone），不指定并且没有使用 <code>T</code> 分隔而是使用空格分隔时，就按本地时区处理，比如下面的例子：</p>
<pre><code class="javascript">&gt; new Date('1970-01-01T00:00:00+08:00')
Thu Jan 01 1970 00:00:00 GMT+0800 (CST)

&gt; new Date('1970-01-01 00:00:00')
Thu Jan 01 1970 00:00:00 GMT+0800 (CST)

&gt; new Date('1970-01-01T00:00:00+00:00')
Thu Jan 01 1970 08:00:00 GMT+0800 (CST)</code></pre>
<p>示例 1 是东八区时间，显示的时间和传入的时间一致（因为我本地时区是东八区）。</p>
<p>示例 2 和示例 1 结果一样，不指定时区就是本地时区。</p>
<p>示例 3 指定时区为 <code>GMT</code> 时区（偏移为 0），显示的时间会加上本地时区的偏移（8 小时）。</p>
<h5>RFC-2822</h5>
<p>RFC-2822 的标准格式大概是这样：<code>Wed Mar 25 2015 09:56:24 GMT+0100</code>。其实就是上面显示时间时使用的形式：</p>
<pre><code class="javascript">&gt; new Date('Thu Jan 01 1970 00:00:00 GMT+0800 (CST)')
Thu Jan 01 1970 00:00:00 GMT+0800 (CST)</code></pre>
<p>除了能表示基本信息，还可以表示星期，但是一点也不容易读，不建议使用。完整的规范可以在这里查看：<a href="http://tools.ietf.org/html/rfc2822#page-14">http://tools.ietf.org/html/rfc2822#page-14</a></p>
<h4>时间戳</h4>
<p><code>Date</code> 构造器还可以接受整数，表示想要构造的时间自 <code>UTC</code> 时间 <code>1970-01-01 00:00:00</code> 经过的毫秒数。比如下面的代码：</p>
<pre><code class="javascript">&gt; new Date(1000 * 1)
Thu Jan 01 1970 08:00:01 GMT+0800 (CST)</code></pre>
<p>传人 1 秒，等价于：<code>1970-01-01 00:00:01Z</code>，显示的时间加上了本地时区的偏移（8 小时）。</p>
<h4>多参数</h4>
<p>最后，<code>Date</code> 构造器还支持传递多个参数，这种方法就没办法指定时区了，都当做本地时间处理。比如下面的代码：</p>
<pre><code class="javascript">&gt; new Date(1970, 0, 1, 0, 0, 0)
Thu Jan 01 1970 00:00:00 GMT+0800 (CST)</code></pre>
<p>显示时间和传入时间一致，均是本地时间。注意：月份是从 0 开始的。</p>
<h3>Date.parse</h3>
<p><code>Date.parse</code> 接受一个时间字符串，如果字符串能正确解析就返回自 <code>UTC</code> 时间 <code>1970-01-01 00:00:00</code> 经过的毫秒数，否则返回 <code>NaN</code>：</p>
<pre><code class="javascript">&gt; Date.parse('1970-01-01 00:00:00')
-28800000

&gt; new Date(Date.parse('1970-01-01 00:00:00'))
Thu Jan 01 1970 00:00:00 GMT+0800 (CST)

&gt; Date.parse('1970-01-01T00:00:00')
0

&gt; new Date(Date.parse('1970-01-01T00:00:00'))
Thu Jan 01 1970 08:00:00 GMT+0800 (CST)</code></pre>
<p>示例 1，-28800000 换算后刚好是 8 小时表示的毫秒数，<code>28800000 / (1000 * 60 * 60)</code>，我们传入的是本地时区时间，等于 <code>UTC</code> 时间的 <code>1969-12-31 16:00:00</code>，和 <code>UTC</code> 时间 <code>1970-01-01 00:00:00</code> 相差刚好 -8 小时。</p>
<p>示例 2，将 parse 后的毫秒数传递给构造器，最后显示的时间加上了本地时区的偏移（8 小时），所以结果刚好是 <code>1970-01-01 00:00:00</code>。</p>
<p>示例 3，传入的是 <code>UTC</code> 时区时间，所以结果为 0。</p>
<p>示例 4，将 parse 后的毫秒数传递给构造器，最后显示的时间加上了本地时区的偏移（8 小时），所以结果刚好是 <code>1970-01-01 08:00:00</code>。</p>
<h3>Date.UTC</h3>
<p><code>Date.UTC</code> 接受的参数和 <code>Date</code> 构造器多参数形式一样，然后返回时间自 <code>UTC </code> 时间 <code>1970-01-01 00:00:00</code> 经过的毫秒数：</p>
<pre><code class="javascript">&gt; Date.UTC(1970,0,1,0,0,0)
0

&gt; Date.parse('1970-01-01T00:00:00')
0

&gt; Date.parse('1970-01-01 00:00:00Z')
0</code></pre>
<p>可以看出，<code>Date.UTC</code> 进行的是一种“绝对运算”，传入的时间就是 <code>UTC</code> 时间，不会转换为当地时间。</p>
<h3>Date.now</h3>
<p><code>Date.now</code> 返回当前时间距 <code>UTC</code> 时间 <code>1970-01-01 00:00:00</code> 经过的毫秒数：</p>
<pre><code class="javascript">&gt; Date.now()
1452520484343

&gt; new Date(Date.now())
Mon Jan 11 2016 21:54:55 GMT+0800 (CST)

&gt; new Date()
Mon Jan 11 2016 21:55:00 GMT+0800 (CST)</code></pre>
<h2>MySQL 中的“时间”</h2>
<p>MySQL 中和时间相关的数据类型主要包括：<code>YEAR</code>、<code>TIME</code>、<code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>。</p>
<p><code>DATE</code>、<code>YEAR</code>、<code>TIME</code> 比较简单，大概总结如下：</p>
<table>
<thead><tr>
<th align="left">名称</th>
<th align="left">占用字节</th>
<th align="left">取值</th>
</tr></thead>
<tbody>
<tr>
<td align="left">DATE</td>
<td align="left">3 字节</td>
<td align="left">1000-01-01 ~ 9999-12-31</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1 字节</td>
<td align="left">1901 ~ 2155</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">3 字节</td>
<td align="left">-838:59:59 ~ 838:59:59</td>
</tr>
</tbody>
</table>
<p>注：<code>TIME</code> 的小时范围可以这么大（超过 24 小时），是因为它还可以用来表示两个时间点之差。</p>
<h3>DATEIME vs TIMESTAMP</h3>
<p>我们主要来说明下 <code>DATETIME</code> 和 <code>TIMESTAMP</code>，可以做下面的总结：</p>
<table>
<thead><tr>
<th align="left">名称</th>
<th align="left">占用字节</th>
<th align="left">取值</th>
<th align="left">受 time_zone 设置影响</th>
</tr></thead>
<tbody>
<tr>
<td align="left">DATETIME</td>
<td align="left">8 字节</td>
<td align="left">1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">4 字节</td>
<td align="left">1970-01-01 00:00:00 ~ 2038-01-19 03:14:07</td>
<td align="left">是</td>
</tr>
</tbody>
</table>
<p>第一个区别是占用字节不同，导致能表示的时间范围也不一样。</p>
<p>第二个区别是 <code>DATETIME</code> 是“常量”，保存时就是保存时的值，检索时是一样的值，不会改变；而 <code>TIMESTAMP</code> 则是“变量”，保存时数据库服务器将其从<code>time_zone</code> 时区转换为 <code>UTC</code> 时间后保存，检索时将其转换从 <code>UTC</code> 时间转换为 <code>time_zone</code> 时区时间后返回。</p>
<p>比如，我们有下面这样一张表：</p>
<pre><code class="sql">CREATE TABLE `tests` (
    `id` INTEGER NOT NULL auto_increment , 
    `datetime` DATETIME, 
    `timestamp` TIMESTAMP, 
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;</code></pre>
<p>连接到数据库服务器后，可以执行 <code>SHOW VARIABLES LIKE '%time_zone%'</code> 查看当前时区设置。类似下面这样的结果：</p>
<table>
<thead><tr>
<th align="left">Variable_name</th>
<th align="left">Value</th>
</tr></thead>
<tbody>
<tr>
<td align="left">system_time_zone</td>
<td align="left">CST</td>
</tr>
<tr>
<td align="left">time_zone</td>
<td align="left">SYSTEM</td>
</tr>
</tbody>
</table>
<p>说明我目前时区是 <code>CST</code>（China  Standard Time），也就是东八区。</p>
<p>我们尝试插入下面的数据：</p>
<pre><code class="sql">INSERT INTO `tests` (`id`, `datetime`, `timestamp`) VALUES (DEFAULT, '1970-01-01 00:00:00', '1970-01-01 00:00:00');</code></pre>
<p>会发现有一个报错：<code>Error Code: 1292. Incorrect datetime value: '1970-01-01 00:00:00' for column 'timestamp'</code>。给 timestamp 这一列提供的值不对，因为我们尝试插入 <code>1970-01-01 00:00:00</code> 时，数据库服务器会根据 <code>time_zone</code> 的设置将其转换为 <code>UTC</code> 时间，也就是 <code>1969-12-31 16:00:00</code>，而这个值明显超过了 <code>TIMESTAMP</code> 类型的范围。</p>
<p>我们换个大一点的值：</p>
<pre><code class="sql">INSERT INTO `tests` (`id`, `datetime`, `timestamp`) VALUES (DEFAULT, '2000-01-01 00:00:00', '2000-01-01 00:00:00');</code></pre>
<p>这次就成功插入了。</p>
<p>再次检索时结果也是正确的（数据库服务器将值从 <code>UTC</code> 时间转换为 <code>time_zone</code> 设置的时区时间）：</p>
<pre><code class="sql">SELECT * FROM sample.tests;</code></pre>
<p>返回：</p>
<table>
<thead><tr>
<th align="left">id</th>
<th align="left">datetime</th>
<th align="left">timestamp</th>
</tr></thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">2000-01-01 00:00:00</td>
<td align="left">2000-01-01 00:00:00</td>
</tr></tbody>
</table>
<p>如果我们先将 <code>time_zone</code> 设置为一个不同的值后再进行检索就会发现不同的结果：</p>
<pre><code class="sql">SET time_zone = '+00:00';
SELECT * FROM sample.tests;</code></pre>
<p>返回：</p>
<table>
<thead><tr>
<th align="left">id</th>
<th align="left">datetime</th>
<th align="left">timestamp</th>
</tr></thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">2000-01-01 00:00:00</td>
<td align="left">1999-12-31 16:00:00</td>
</tr></tbody>
</table>
<p>可以看到 datetime 列值没有受 <code>time_zone</code> 设置的影响，而 timestamp 列值却改变了。数据库服务器将其从 <code>UTC</code> 时区转换为 <code>time_zone</code> 时区的时间（首先 <code>2000-01-01 00:00:00</code> 在上面进行插入时根据 <code>time_zone</code> 被转换为了 <code>1999-12-31 16:00:00</code>，此次检索时 <code>time_zone</code> 被设置为 <code>+00:00</code>，转换回来刚好就是 <code>1999-12-31 16:00:00</code>）。</p>
<p>那这两种类型怎么选择呢？建议优先使用 <code>DATETIME</code>，表示范围大、不容易受服务器的设置影响。</p>
<h2>在 JavaScript 和 MySQL 间转换</h2>
<p>分别说明了 JavaScript 和 MySQL 中的“时间”后，我们来聊聊 ORM 框架一般都是怎么样在两者间进行正确、合适的转换来避免混乱的。下面的说明将基于 sequelize 框架来解释，主要是一种思路，其他的框架可以阅读框架提供的文档或是源码。</p>
<p>sequelize 实际上有一个 <code>timezone</code> 的配置，默认是 <code>+00:00</code>（<a href="http://sequelize.readthedocs.org/en/latest/api/sequelize/">http://sequelize.readthedocs.org/en/latest/api/sequelize/</a>）。这个 <code>timezone</code> 有下面的用途：</p>
<ul>
<li><p>建立数据库连接时，执行 <code>SET time_zone = opts.timezone</code></p></li>
<li><p>MySQL 的时间类型和 JavaScript 的时间类型的互相转换</p></li>
</ul>
<p>第一个用途很简单，体现在源码里就是执行一个 <code>SQL</code> 语句：</p>
<pre><code class="javascript">connection.query("SET time_zone = '" + self.sequelize.options.timezone + "'"); /* jshint ignore: line */</code></pre>
<p>第二个用途主要体现在两个地方：1）在 JavaScript 中调用 ORM 方法进行插入、更新时，需要将 <code>Date</code> 类型转为正确的 SQL 语句；2）从 MySQL 服务器查询数据时，需要将数据库查询到的值转换为 JavaScript 中的 Date 类型。下面我们分别来看一看。</p>
<h3>JavaScript -&gt; MySQL</h3>
<p>这个转换的核心代码如下：</p>
<pre><code class="javascript">SqlString.dateToString = function(date, timeZone, dialect) {
  if (moment.tz.zone(timeZone)) {
    date = moment(date).tz(timeZone);
  } else {
    date = moment(date).utcOffset(timeZone);
  }

  if (dialect === 'mysql' || dialect === 'mariadb') {
    return date.format('YYYY-MM-DD HH:mm:ss');
  } else {
    // ZZ here means current timezone, _not_ UTC
    return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');
  }
};</code></pre>
<p>代码逻辑如下：</p>
<ol>
<li><p>检查 <code>timeZone</code> 是否存在，如果存在（存在指的是类似 <code>America/New_York</code> 这样的表示法），调用 <code>tz</code> 设置 <code>date</code> 的时区。</p></li>
<li><p>如果不存在（类似 <code>+00:00</code>、<code>-07:00</code> 这样的表示法），调用 <code>utcOffset</code> 设置 <code>date</code> 的相对 <code>UTC</code> 的时区偏移。</p></li>
<li><p>最后使用上面设置的时区偏移将其 <code>format</code> 成 MySQL 需要的 <code>YYYY-MM-DD HH:mm:ss</code> 格式。</p></li>
</ol>
<p>举两个例子。</p>
<p>如果 <code>timeZone</code> 等于 <code>+00:00</code>，date 等于 <code>new Date('2016-01-12 09:46:00')</code>，到 <code>UTC</code> 的偏移等于 (timeZone - 本地时区) + timeZone：<code>(00:00 - 08:00) + 00:00 = -08:00</code>，即 <code>2016-01-12 09:46:00-08:00</code>，于是 <code>format</code> 后的结果是 <code>2016-01-12 01:46:00</code>。</p>
<p>如果 <code>timeZone</code> 等于 <code>+08:00</code>，date 等于 <code>new Date('2016-01-12 09:46:00')</code>，到 <code>UTC</code> 的偏移等于 (timeZone - 本地时区) + timeZone：<code>(08:00 - 08:00) + 08:00 = 08:00</code>，即 <code>2016-01-12 09:46:00+08:00</code>。于是 <code>format</code> 后的结果是 <code>2016-01-12 09:46:00</code>。</p>
<p>如果 <code>timeZone</code> 等于 <code>Asia/Shanghai</code>，结果也会是 <code>2016-01-12 09:46:00</code>，和 <code>+08:00</code> 等价。</p>
<p>sequelize 的 <code>timezone</code> 默认是 <code>+00:00</code>，所以，我们在 JavaScript 中的时间最后应用到数据库中都会被转换成 <code>UTC</code> 的时间（比实际的时间早 8 小时）。</p>
<h3>MySQL -&gt; JavaScript</h3>
<p>这个转换过程实际上是更底层的 node-mysql 库来实现的。核心代码如下：</p>
<pre><code class="javascript">  switch (field.type) {
    case Types.TIMESTAMP:
    case Types.DATE:
    case Types.DATETIME:
    case Types.NEWDATE:
      var dateString = parser.parseLengthCodedString();
      if (dateStrings) {
        return dateString;
      }
      var dt;

      if (dateString === null) {
        return null;
      }

      var originalString = dateString;
      if (field.type === Types.DATE) {
        dateString += ' 00:00:00';
      }

      if (timeZone !== 'local') {
        dateString += ' ' + timeZone;
      }

      dt = new Date(dateString);
      if (isNaN(dt.getTime())) {
        return originalString;
      }

      return dt;
   // 更多代码...
}</code></pre>
<p>处理过程大概是这样：</p>
<ol>
<li><p>用 <code>parser</code> 将服务器返回的二进制数据解析为时间字符串</p></li>
<li><p>如果配置了强制返回字符串 <code>dateStrings</code> 而不是转换回 <code>Date</code> 类型，直接返回 <code>dateString</code></p></li>
<li><p>如果字段类型是 <code>DATE</code>，时间字符串的时间部分统一为 <code>00:00:00</code></p></li>
<li><p>如果配置的 <code>timeZone</code> 不是 <code>local</code>（本地时区），时间字符串加上时区信息</p></li>
<li><p>将时间字符串传给 <code>Date</code> 构造器，如果构造出的时间不合法，返回原始时间字符串，否则返回时间对象</p></li>
</ol>
<p>默认情况下，sequelize 在进行连接时传递给 node-mysql 的 <code>timeZone</code> 是 <code>+00:00</code>，所以，第 4 步的时间字符串会是类似这样的值 <code>2016-01-12 01:46:00+00:00</code>，而这个值传递给 <code>Date</code> 构造器，在显示时转换回本地时区时间，就变成了 <code>2016-01-12 09:46:00</code>（比数据库中的时间晚 8 小时）。</p>
<h3>一个例子</h3>
<p>在使用 sequelize 定义模型时，其实是没有 <code>TIMESTAMP</code> 类型的，sequelize 只提供了一个 <code>Sequelize.DATE</code> 类型，生成建表语句时被转换为 <code>DATETIME</code>。</p>
<p>如果是在旧表上定义模型，而这张旧表刚好有 <code>TIMESTAMP</code> 类型的列，对 <code>TIMESTAMP</code> 类型的列定义模型时还是可以使用 <code>Sequelize.DATE</code>，对操作没有任何影响。但是 <code>TIMESTAMP</code> 是受 <code>time_zone</code> 设置影响的，这会引起一些困惑。下面我们来看一个例子。</p>
<p>sequelize 默认将 <code>time_zone</code> 设置为 <code>+00:00</code>，当我们执行下面代码时：</p>
<pre><code class="javascript">Test.create({
    'datetime': new Date('2016-01-10 20:07:00'),
    'timestamp': new Date('2016-01-10 20:07:00')
  });</code></pre>
<p>会进行上面提到的 JavaScript 时间到 MySQL 时间字符串的转换，生成的 SQL 其实是（时间被转换为了 <code>UTC</code> 时间，比本地时间早了 8 小时）：</p>
<pre><code class="sql">INSERT INTO `tests` (`id`,`datetime`,`timestamp`) VALUES (DEFAULT,'2016-01-10 12:07:00','2016-01-10 12:07:00');</code></pre>
<p>当我们执行 <code>Test.findAll()</code> 来查询数据时，会进行上面提到的 MySQL 时间到 JavaScript 时间的转换，其实就是返回这样的结果（显示时时间从 <code>UTC</code> 时间转换回了本地时间）：</p>
<pre><code class="javascript">&gt; new Date('2016-01-10 12:07:00+00:00')
Sun Jan 10 2016 20:07:00 GMT+0800 (CST)</code></pre>
<p>和我们插入时的时间是一致的。</p>
<p>如果我们通过 MySQL 命令行来查询数据时，发现其实是这样的结果：</p>
<table>
<thead><tr>
<th align="left">id</th>
<th align="left">datetime</th>
<th align="left">timestamp</th>
</tr></thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">2016-01-10 12:07:00</td>
<td align="left">2016-01-10 20:07:00</td>
</tr></tbody>
</table>
<p>这很好理解，因为我们数据库服务器的 <code>time_zone</code> 默认是东八区，<code>TIMESTAMP</code> 是受时区影响的，查询时被数据库服务器从 <code>UTC</code> 时间转换回了 <code>time_zone</code> 时区时间；<code>DATETIME</code> 不受影响，还是 <code>UTC</code> 时间。</p>
<p>如果我们先执行 <code>SET time_zone = '+00:00'</code>，再进行查询，那结果就都会是 <code>UTC</code> 时间了。所以，不要以为数据出错了哦。</p>
<p>总结下就是，sequelize 会将本地时间转换为 <code>UTC</code> 时间后入库，查询时再将 <code>UTC</code> 时间转换为本地时间。这能达到最好的兼容性，存储总是使用 <code>UTC</code> 时间，展示时应用端自己转换为本地时区时间后显示。当然这个的前提是数据类型选用 <code>DATETIME</code>。</p>
<h3>兼容老数据</h3>
<p>这里要说的最后一个问题是基于旧表定义 sequelize 模型，并且表中时间值插入时没有转换为 <code>UTC</code> 时间（全部是东八区时间），而且 <code>DATETIME</code> 和 <code>TIMESTAMP</code> 混用，该怎么办？</p>
<p>在默认配置下，情况如下：</p>
<p>查询 <code>DATETIME</code> 类型数据时，时间总是会晚 8 小时。比如，数据库中某条老数据的时间是 <code>2012-01-01 01:00:00</code>（已经是本地时间了，因为没转换），查询时被 sequelize 转换为 <code>new Date('2012-01-01 01:00:00+00:00')</code>，显示时转换为本地时间 <code>2012-01-01 09:00:00</code>，结果显然不对。</p>
<p>查询 <code>TIMESTAMP</code> 类型数据时，时间是正确的。这是因为 <code>TIMESTAMP</code> 受 <code>time_zone</code> 影响，sequelize 默认将其设置为 <code>+00:00</code>，查询时数据库服务器先将时间转换到 <code>time_zone</code> 设置的时区时间，由于没有时区偏移，刚好查出来的就是数据库中的值。比如：<code>2012-01-01 00:00:00</code>（注意这个值是 UTC 时间），sequelize 将其转换为 <code>new Date('2012-01-01 00:00:00+00:00')</code>，显示时转换为本地时间 <code>2012-01-01 08:00:00</code>，刚好“侥幸”正确。</p>
<p>新插入的数据 sequelize 会进行上一部分说的双向转换来保证结果的正确。</p>
<p>维持默认配置显然导致查询 <code>DATETIME</code> 不准确，解决方法就是将 sequelize 的 <code>timezone</code> 配置为 <code>+08:00</code>。这样一来，情况变成下面这样：</p>
<p>查询 <code>DATETIME</code> 类型数据时，时间 <code>2012-01-01 01:00:00</code> 被转换为 <code>new Date('2012-01-01 01:00:00+08:00')</code>，显示时转换为本地时间 <code>2012-01-01 01:00:00</code>，结果正确。</p>
<p>查询 <code>TIMESTAMP</code> 类型数据时，由于 <code>time_zone</code> 被设置为了 <code>+08:00</code>，数据库服务器先将库中 <code>UTC</code> 时间 <code>2011-01-01 00:00:00</code> 转换到 <code>time_zone</code> 时区时间（加上 8 小时偏移）为 <code>2011-01-01 08:00:00</code>，sequelize 将其转换为 <code>new Date('2011-01-01 08:00:00+08:00')</code>，显示时转换为本地时间 <code>2011-01-01 08:00:00</code>，结果正确。</p>
<p>插入、更新数据时，所有 JavaScript 时间会转换为东八区时间入库。</p>
<p>这样带来的问题是，所有入库时间都是东八区时间，如果有其他应用的时区不是东八区，那就需要自己基于东八区时间计算偏移并转换时间后显示了。</p>
<h2>参考资料</h2>
<p>一不小心写的有点长了，下面列出参考资料供大家进一步学习：</p>
<ul>
<li><p><a href="http://www.timeanddate.com/time/gmt-utc-time.html">http://www.timeanddate.com/time/gmt-utc-time.html</a></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date</a></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse</a></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC</a></p></li>
<li><p><a href="http://tools.ietf.org/html/rfc2822#page-14">http://tools.ietf.org/html/rfc2822#page-14</a></p></li>
<li><p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15</a></p></li>
<li><p><a href="http://www.w3schools.com/js/js_date_formats.asp">http://www.w3schools.com/js/js_date_formats.asp</a></p></li>
<li><p><a href="http://momentjs.com/timezone/docs/">http://momentjs.com/timezone/docs/</a></p></li>
<li><p><a href="http://sequelize.readthedocs.org/en/latest/api/sequelize/">http://sequelize.readthedocs.org/en/latest/api/sequelize/</a></p></li>
<li><p><a href="https://github.com/felixge/node-mysql">https://github.com/felixge/node-mysql</a></p></li>
<li><p>《MySQL 技术内幕》<