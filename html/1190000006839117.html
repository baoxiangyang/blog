<h2>先说结论</h2>
<p>实用而论，不想了解具体原理的同学只要记住一点即可：在配置好环境的情况下，拿到设计稿并发现需要使用固定宽高比元素的时候，在css中做好px（设计稿中的px）与rem换算就行（即便这个过程也有不少偷懒的办法,减轻工作量）.</p>
<h2>关于rem的基础知识</h2>
<p>这部分比较懒,可以参考</p>
<ol>
<li><p><a href="https://www.zhihu.com/question/21504656">知乎-css3的字体大小单位rem到底好在哪？</a></p></li>
<li><p><a href="http://ybshare.coding.io/share/flexible.htm">移动端页面适配方案</a> (主要参考的这个，还看不明白的可以看看)</p></li>
</ol>
<h2>rem解决了什么问题?</h2>
<p>针对文博在线微网站,rem能解决什么问题?他有什么好处呢?</p>
<p>我们是否遇到这样的情况:一个按钮,它的宽度可以做到自适应地随着设备的变化而去响应,但是高度呢?</p>
<p><img data-src="/img/remote/1460000006839120" src="/img/remote/1460000006839120.png"></p>
<p>再比如一个两列的图片列表（<strong>这个图表达的有些问题，还没想好该怎么表达~~</strong>）:</p>
<p><img data-src="/img/remote/1460000006839121" src="/img/remote/1460000006839121.png"></p>
<p>我们发现在没有使用特殊处理的情况下,想要图片按照给定的比例去显示是比较困难的.主要的原因是在<strong>css中height属性是不会轻易按照百分比去计算</strong>.之前项目中的pc站借助了javascript才搞定(当然最后发现没有什么实际的作用).但是在移动端,这个问题变的有意义了.</p>
<p>可能有人对rem兼容性有疑问,请看<a href="http://caniuse.com/#search=rem">这里</a></p>
<p><img data-src="/img/remote/1460000006839122" src="/img/remote/1460000006839122.png"></p>
<p>可以说在手机端使用,应该是没有问题的.淘宝的手机站已经采取了rem的方案.</p>
<h2>rem实战</h2>
<p>下面说说如何在实战中使用rem.首先我们设定,<code>1rem</code>等于当前设备状态下(不论横屏还是竖屏)的宽度的10%.</p>
<h4>设计稿到css</h4>
<p>以640设计稿举例,图中左右两个300px×150px的item</p>
<p><img data-src="/img/remote/1460000006839123" src="/img/remote/1460000006839123.png"></p>
<p>那么我们分成10份后,<code>1rem=64px</code></p>
<p><img data-src="/img/remote/1460000006839124" src="/img/remote/1460000006839124.png"></p>
<p>如果是原来的写法的话</p>
<pre><code class="css">.rem-block-wrap{
    float:left;
    width: 300px;
    height:150px;
    padding:10px;
    box-sizing: content-box;
}
.rem-block{
    width: 100%;
    height: 100%;
    background: #fff;
}</code></pre>
<p>转换成rem写法:</p>
<pre><code class="css">.rem-block-wrap{
    float:left;
    width: 4.6875rem; /*300px*/
    height:2.34375rem;/*150px*/
    padding:.15625rem;/*10px*/
}
.rem-block{
    width: 100%;
    height: 100%;
    background: #fff;
}</code></pre>
<p>针对字体的话,保留了使用px,因为有的时候我们并不希望字体出现奇怪的值</p>
<pre><code class="css">.example-item:nth-child(2),
.example-item:nth-child(2) button{
  font-size: 12px;
}
[data-dpr="2"] .example-item:nth-child(2),
[data-dpr="2"] .example-item:nth-child(2) button
{
  font-size: 24px;
}</code></pre>
<blockquote><p>在dpr等于2,且缩放为0.5的情况下(<code>&lt;meta name="viewport" content="initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no"&gt;</code>),<code>24px</code>其实相当于之前的<code>12px</code>,这么做的目的主要是消除ios系统下的1px偏差,了解具体,请<a href="http://wweggplant.github.io/blog/example/rem.html">点击这里</a></p></blockquote>
<p>css文件编写完毕后,在实际的html中我们需要计算真实设备中<code>html</code>的<code>font-size</code>的值,关键的代码如下:</p>
<h4>计算font-size和缩放的比例</h4>
<p>这里也是参考了 <a href="http://www.meow.re/demo/screen-adaptation-in-mobileweb/mobile-util.js">别人的代码</a> :</p>
<pre><code class="javascript">window.mobileUtil = (function(win, doc) {
    var UA = navigator.userAgent,
        isAndroid = /android|adr/gi.test(UA),
        isIos = /iphone|ipod|ipad/gi.test(UA) &amp;&amp; !isAndroid, // 据说某些国产机的UA会同时包含 android iphone 字符
        isMobile = isAndroid || isIos;  // 粗略的判断

    return {
        isAndroid: isAndroid,
        isIos: isIos,
        isMobile: isMobile,

        isNewsApp: /NewsApp\/[\d\.]+/gi.test(UA),
        isWeixin: /MicroMessenger/gi.test(UA),
        isQQ: /QQ\/\d/gi.test(UA),
        isYixin: /YiXin/gi.test(UA),
        isWeibo: /Weibo/gi.test(UA),
        isTXWeibo: /T(?:X|encent)MicroBlog/gi.test(UA),

        tapEvent: isMobile ? 'tap' : 'click',

        /**
         * 缩放页面
         */
        fixScreen: function() {
            var metaEl = doc.querySelector('meta[name="viewport"]'),
                metaCtt = metaEl ? metaEl.content : '',
                matchScale = metaCtt.match(/initial\-scale=([\d\.]+)/),
                matchWidth = metaCtt.match(/width=([^,\s]+)/);

            if ( !metaEl ) { // REM
                var docEl = doc.documentElement,
                    maxwidth = docEl.dataset.mw || 750, // 每 dpr 最大页面宽度
                    dpr = isIos ? Math.min(win.devicePixelRatio, 3) : 1,
                    scale = 1/dpr,
                    tid;

                docEl.removeAttribute('data-mw');
                docEl.dataset.dpr = dpr;
                metaEl = doc.createElement('meta');
                metaEl.name = 'viewport';
                metaEl.content = fillScale(scale);
                docEl.firstElementChild.appendChild(metaEl);

                var refreshRem = function() {
                    var width = docEl.getBoundingClientRect().width;
                    if (width / dpr &gt; maxwidth) {
                        width = maxwidth * dpr;
                    }
                    var rem = width / 10;
                    docEl.style.fontSize = rem + 'px';
                };

                win.addEventListener('resize', function() {
                    clearTimeout(tid);
                    tid = setTimeout(refreshRem, 300);
                }, false);
                win.addEventListener('pageshow', function(e) {
                    if (e.persisted) {
                        clearTimeout(tid);
                        tid = setTimeout(refreshRem, 300);
                    }
                }, false);

                refreshRem();
            } else if ( isMobile &amp;&amp; !matchScale &amp;&amp; ( matchWidth &amp;&amp; matchWidth[1] != 'device-width' ) ) { // 定宽
                var width = parseInt(matchWidth[1]),
                    iw = win.innerWidth || width,
                    ow = win.outerWidth || iw,
                    sw = win.screen.width || iw,
                    saw = win.screen.availWidth || iw,
                    ih = win.innerHeight || width,
                    oh = win.outerHeight || ih,
                    ish = win.screen.height || ih,
                    sah = win.screen.availHeight || ih,
                    w = Math.min(iw,ow,sw,saw,ih,oh,ish,sah),
                    scale = w / width;

                if ( scale &lt; 1 ) {
                    metaEl.content = metaCtt + ',' + fillScale(scale);
                }
            }

            function fillScale(scale) {
                return 'initial-scale=' + scale + ',maximum-scale=' + scale + ',minimum-scale=' + scale + ',user-scalable=no';
            }


            if (!isMobile) {
                alert("请在现代浏览器(chrome,火狐)的开发者模式下,模拟移动端设计查看");
            }
        },

        /**
         * 转href参数成键值对
         * @param href {string} 指定的href，默认为当前页href
         * @returns {object} 键值对
         */
        getSearch: function(href) {
            href = href || win.location.search;
            var data = {},reg = new RegExp( "([^?=&amp;]+)(=([^&amp;]*))?", "g" );
            href &amp;&amp; href.replace(reg,function( $0, $1, $2, $3 ){
                data[ $1 ] = $3;
            });
            return data;
        }
    };
})(window, document);
// 默认直接适配页面
mobileUtil.fixScreen();</code></pre>
<p>这段代码主要有两个作用:</p>
<ol>
<li><p>计算出适应宽度的<code>meta</code>标签的内容,<code>&lt;meta name="viewport" content="initial-scale=x,maximum-scale=x,minimum-scale=x,user-scalable=no"&gt;</code></p></li>
<li><p>计算html节点的<code>font-size</code></p></li>
</ol>
<p>效果如下图:</p>
<p><img data-src="/img/remote/1460000006839125" src="/img/remote/1460000006839125.png"></p>
<p>具体请点击<a href="http://wweggplant.github.io/blog/example/rem.html">demo</a></p>
<h4>px转rem</h4>
<p>到这里就会有一个问题,那就是px转到rem需要过程,这个工作想想就头大,不过这里我提供了几种方式减轻这个工作.</p>
<p>1.Sublime Text 2/3</p>
<p>效果如下图:</p>
<p><img data-src="/img/remote/1460000006839126" src="/img/remote/1460000006839126.gif"></p>
<p>具体情况请<a href="http://www.07net01.com/2015/08/900796.html">点击</a></p>
<p>2.gulp插件</p>
<p>使用<code>postcss</code>中的<code>postcss-px2rem</code>插件,具体情况请<a href="http://www.jianshu.com/p/b130293511af">点击</a></p>
<blockquote><p>phpStorm中也可以整合gulp</p></blockquote>
<h2>什么情况下使用rem?</h2>
<ol>
<li><p>整体的布局还是使用百分比</p></li>
<li><p>使用rem的最佳场景是,遇到例如多列带有图片的列表,常常需要图片固定宽高比例</p></li>
<li><p>字体一般情况建议使用px</p></li>
</ol>