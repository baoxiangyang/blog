<p>最近为实现一个新功能弄的焦头烂额 <code>@xxx</code> 的实现，在实现后写下些心得，供以后会跳入这坑的同志们参考。</p>
<p>首先，当让是考虑使用范围，由于项目仅仅需要考虑在 <code>WEBKIT</code> 环境下使用，所以可以不用考虑 <code>IE</code> 这也使得代码少了很多的 <code>if(){}else{}</code> 判断。在<a href="https://developer.mozilla.org/zh-CN/">Mozilla 开发者网络</a>上发现 <code>selection</code> 和 <code>range</code> 这两个关于选区对象和光标对象，结合 <a href="http://ichord.github.com/Caret.js/">Caret</a>（一个用于判断当前光标位置的JS插件）后，一个大致的雏形就浮现出来。</p>
<p>大概就长这样：</p>
<p><img data-src="/img/remote/1460000007846798" src="/img/remote/1460000007846798.png"></p>
<p>先整理思路，捋一捋实现步骤。</p>
<p>大致思路如下：</p>
<ol>
<li><p>键入 <code>@</code> 后将选择框显示出来</p></li>
<li><p>将焦点定位在弹出框中的搜索框中</p></li>
<li><p>点击选择框中的选项时，返回输入框</p></li>
<li><p>输入框中显示 <code>@xxx</code></p></li>
<li><p>将光标定位在 <code>@xxx</code> 之后</p></li>
<li><p>删除 <code>@xxx</code> 时需要整个 <code>@xxx</code> 一起删除</p></li>
</ol>
<p>由于项目使用了 <code>angular</code> 来构建，所以给的 <code>demo</code> 也是用 <code>angular</code> 来搭建的，但是不论用什么框架，想法有了，那么一切就好办了。</p>
<p><code>selection</code> 和 <code>range</code> 对象的具体使用请参考 <code>MDN</code> 上的相关文章：</p>
<ol>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection">selection</a></p></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range/Range">range</a></p></li>
<li><p><a href="http://acohome.cn/demo/@DEMO.html">DEMO页</a></p></li>
</ol>
<p>主要涉及的几个方法：</p>
<ol>
<li><p>getSelection(window.getSelectio)：获取光标所在的区域（一个div或是一个textarea）；</p></li>
<li><p>selection.getRangeAt：获取光标所在区域中光标选区的信息；</p></li>
<li><p>range.setStart：设置光标选区的起始位置；</p></li>
<li><p>range.setEnd：设置光标选区的结束位置；</p></li>
<li><p>range.deleteContents：将光标选区选中的内容删除；</p></li>
<li><p>range.insertNode：在光标选区中添加内容；</p></li>
<li><p>selection.extend：将选区的焦点移动到一个特定的位置；</p></li>
<li><p>selection.collapseToEnd：将当前的选区折叠到最末尾的一个点。</p></li>
</ol>
<h2>html 结构</h2>
<pre><code>&lt;div class="demo-wrap" ng-controller="Controller"&gt;

    &lt;!-- 文本输入框 --&gt;
    &lt;div class="demo" id="demo" contenteditable="true" ng-keydown="keyIn($event)"&gt;&lt;/div&gt;
    
    &lt;!-- 带有输入框的选人框 --&gt;
    &lt;div class="select-person" id="selectPerson" ng-show="showSelect" ng-style="sPersonPosi"&gt;
        &lt;input type="text" id="searchPersonInput" ng-model="personSearchText" ng-blur="missFocus()"&gt;
        &lt;ul class="person-wrap"&gt;
            &lt;li class="row" ng-click="sPersonDone({fullName:'所有人'})"&gt;
                &lt;div class="col-1"&gt;
                    &lt;div class="img-wrap"&gt;
                        &lt;portrait src="" text="'所有'"&gt;&lt;/portrait&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="col-2"&gt;所有人&lt;/div&gt;
            &lt;/li&gt;
            &lt;li class="row" ng-click="sPersonDone(item)" ng-repeat="item in atList | filter :{fullName: personSearchText}"&gt;
                &lt;div class="col-1"&gt;
                    &lt;div class="img-wrap"&gt;
                        &lt;portrait src="item.img" text="item.fullName.slice(-2)"&gt;&lt;/portrait&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="col-2" ng-bind="item.fullName"&gt;&lt;/div&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>样式相关的<code>CSS</code>代码就不放上来了，简要分析下页面结构，一个 <code>contenteditable="true"</code> 的输入框和一个 <code>id="selectPerson"</code> 的选人框。</p>
<ul>
<li><p>输入框使用 <code>contenteditable="true"</code> 主要是因为想在输入框中插入标签，将 <code>@xxx</code> 内容显示出不同的颜色（这就需要将 <code>@xxx</code> 放在一个标签中），绑定 <code>keyIn</code> 的键盘输入事件，用于检索用户输入 <code>@</code> 和 <code>backspace</code> ，并做出相应的动作；</p></li>
<li><p>选人框使用 <code>showSelect</code>  来控制是否显示，遍历显示需要显示的选人，以及使用 <code>input</code> 中的内容来过滤选人。</p></li>
</ul>
<h2>实现 @ 选择</h2>
<p>相关代码如下：</p>
<pre><code>$scope.keyIn = function(e) {
    var selection = getSelection();
    var ele = $('#demo');
    if (e.code == 'Digit2' &amp;&amp; e.shiftKey) {
        $scope.showSelect = true;
        var offset = ele.caret('offset');
        $scope.sPersonPosi = {
            left: offset.left - 10 + 'px',
            top: offset.top + 20 + 'px'
        };
        // 让选人框中的搜索框获取焦点
        $timeout(function(){
            $('#searchPersonInput')[0].focus();
        })
    }
}</code></pre>
<p>实现起来挺简单，代码也不复杂，利用 <code>caret</code> 插件获取到光标位置，将选人框在 <code>@</code> 符号的下方显示出来，并同时实现了步骤中的第二步：将焦点放在搜索框中。</p>
<h2>选人实现</h2>
<p>主要涉及步骤为：<code>3、4、5</code>。</p>
<p>当鼠标点击备选项时需要按顺序进行 <code>3、4、5</code> 步骤，所以需将 <code>3、4、5</code> 这 <code>3</code> 个步骤放在一起。<br>相关代码如下：</p>
<pre><code>$scope.sPersonDone = function(person) {

    // 成功选人后，关闭选择框，让输入框获取焦点。
    $scope.showSelect = false;
    var ele = $('#demo')[0];
    ele.focus();

    // 获取之前保留先来的信息。
    // 需要修改 keyIn 的代码，保存选区以及光标信息，用于获取在光标焦点离开前，光标的位置
    var selection = lastSelection.selection;
    var range = lastSelection.range;
    var textNode = range.startContainer;

    // 删除 @ 符号。
    range.setStart(textNode, range.endOffset);
    range.setEnd(textNode, range.endOffset + 1);
    range.deleteContents();

    // 生成需要显示的内容，包括一个 span 和一个空格。
    var spanNode1 = document.createElement('span');
    var spanNode2 = document.createElement('span');
    spanNode1.className = 'at-text';
    spanNode1.innerHTML = '@' + person.fullName;
    spanNode2.innerHTML = '&amp;nbsp;';

    // 将生成内容打包放在 Fragment 中，并获取生成内容的最后一个节点，也就是空格。
    var frag = document.createDocumentFragment(),
        node, lastNode;
    frag.appendChild(spanNode1);
    while ((node = spanNode2.firstChild)) {
        lastNode = frag.appendChild(node);
    }

    // 将 Fragment 中的内容放入 range 中，并将光标放在空格之后。
    range.insertNode(frag);
    selection.extend(lastNode, 1);
    selection.collapseToEnd();
};</code></pre>
<p>我们需要的效果是在 <code>@</code> 选人后，将整理好的 <code>@xxx</code> 包装成一个标签，放在原先 <code>@</code> 的位置，所以我们需要对原先的 <code>$scope.keyIn</code> 方法进行改造，保留原先的光标信息，方便在上面的方法中使用。</p>
<p>改造后的 <code>$scope.keyIn</code> 方法如下：</p>
<pre><code>$scope.keyIn = function(e) {
    var selection = getSelection();
    var ele = $('#demo');
    if (e.code == 'Digit2' &amp;&amp; e.shiftKey) {
        $scope.showSelect = true;
        
        // 保存光标信息
        lastSelection = {
            range: selection.getRangeAt(0),
            offset: selection.focusOffset,
            selection: selection
        };
        $scope.showSelect = true;

        // 设置弹出框位置
        var offset = ele.caret('offset');
        $scope.sPersonPosi = {
            left: offset.left - 10 + 'px',
            top: offset.top + 20 + 'px'
        };
        $timeout(function(){
            $('#searchPersonInput')[0].focus();
        })
    }
}</code></pre>
<p>这里估计挺多人会有疑问，为啥要在生成的标签后面加一个空格，而且这个空格要通过  <code>&amp;nbsp;</code>  这样的方式实现。</p>
<p>首先，先解释第一个问题：为啥要在标签后加一个空格？</p>
<p>如果不加空格的话，之后在输入文字会添加在我们生成的标签中，也就是说如果不加空格来隔断我们生成的标签，我们在文本框里所做的操作就是在我们生成的标签中进行。而加了个空格就为了避免该问题的发生，使得文本编辑在正确的编辑框中进行。</p>
<p>第二个问题：为啥不能直接加空格 <code>' '</code> ，而是通过  <code>&amp;nbsp;</code> ，不得不说这是个过个悲伤的事实，还是碰到了兼容性的问题，在 <code>chrome</code> 下运行好好的代码，在 <code>node-webkit</code> 中就会各种报错。原因在不断的 <code>defug</code> 后发现了： <code>node-webkit</code> 中，将一个 <code>' '</code> 添加到 <code>contenteditable="true"</code> 的 <code>div</code> 中会没有啊，坑爹啊有木有！！！呈上之前的代码来祭奠下。</p>
<pre><code>var spanNode1 = document.createElement('span');
var node = document.createTextNode(' ');
spanNode1.className = 'at-text';
spanNode1.innerHTML = '@' + person.fullName;
var frag = document.createDocumentFragment();
frag.appendChild(spanNode1);
frag.appendChild(node);
range.insertNode(frag);
selection.extend(node, 1);</code></pre>
<p>结果一上 <code>node-webkit</code> 环境各种报错。真是坑了个大爹。原因是光标定位不准，指定位置超出实际位置，但是 <code>node-webkit</code> 环境确实是可以输入空格的，一看原来是 <code>&amp;nbsp;</code> 而 <code>&amp;nbsp;</code> 不能通过 <code>createTextNode</code> 来创建，所以就有了之前的哪个曲线救国的策略了。</p>
<h2>删除实现</h2>
<p>终于捋到最后一个步骤了，删除时，需要将一整个标签一起删除。由于需要监听键盘的输入，所以就可与之前 <code>keyIn</code> 的代码写在一起。</p>
<p>最终的 <code>keyIn</code> 代码为：</p>
<pre><code>$scope.keyIn = function(e) {
    var selection = getSelection();
    var ele = document.getElementById('demo');
    if (e.code == 'Digit2' &amp;&amp; e.shiftKey) {

        // 保存光标信息
        lastSelection = {
            range: selection.getRangeAt(0),
            offset: selection.focusOffset,
            selection: selection
        };
        $scope.showSelect = true;

        // 设置弹出框位置
        var offset = $(ele).caret('offset');
        $scope.sPersonPosi = {
            left: offset.left + 'px',
            top: offset.top + 30 + 'px'
        };
        $timeout(function(){
            $('#searchPersonInput')[0].focus();
        })

    } else if (e.code == 'Backspace') {

        // 删除逻辑 
        // 1 ：由于在创建时默认会在 @xxx 后添加一个空格，
        // 所以当得知光标位于 @xxx 之后的一个第一个字符后并按下删除按钮时，
        // 应该将光标前的 @xxx 给删除
        // 2 ：当光标位于 @xxx 中间时，按下删除按钮时应该将整个 @xxx 给删除。

        var range = selection.getRangeAt(0);
        var removeNode = null;
        if (range.startOffset &lt;= 1 &amp;&amp; range.startContainer.parentElement.className != "at-text")
            removeNode = range.startContainer.previousElementSibling;
        if (range.startContainer.parentElement.className == "at-text")
            removeNode = range.startContainer.parentElement;
        if (removeNode)
            ele.removeChild(removeNode);

    }
};</code></pre>
<p>代码的逻辑都写在注释里了，这里就不多说了。</p>
<p>这样就完成 <code>@</code> 这一功能了。</p>