<h2>webpack 是什么</h2>
<p><img data-src="/img/bVzLhA?w=2598&amp;h=1299" src="/img/bVzLhA?w=2598&amp;h=1299.png"></p>
<p>一项技术、一个工具的出现，肯定是为了解决问题的。那么，webpack 是为了解决什么问题？答案是：<strong>文件依赖管理</strong>。浏览器端的 Js, 出于安全的考虑，对本地文件没有操作权限，不能引用其它 js, css 等文件。而 webpack 就是用来解决这个问题的，让你的项目可以很好地分文件、分模块，而且它对外部文件的引入同时支持 cmd, amd 和 commondJs 这三种形式，够有诚意。<br>或许你要说了，解决文件依赖，早在 require.js 和 sea.js 的时候，都已经解决了呀！那么，webpack 在这方面，有哪些新的突破：</p>
<ol>
<li><p>支持引用各种拓展名的文件</p></li>
<li><p>能够在不依赖 gulp 或 grunt 的情况下直接产出打包文件</p></li>
<li><p>支持实时编译，浏览器同步刷新</p></li>
</ol>
<p>这个时候，是不是很想唱一下王力宏的《唯一》：确定你就是我的唯一！<br>OK，进入正题。</p>
<h2>安装与运行</h2>
<p>目前，我们的项目目录结构是这样的：</p>
<pre><code>webpack_demo
|--src
|  |--pages
|  |  |--index
|  |  |  |--index.js
|--views_dev
|  |--index.html
|--webpack.config.js
|--package.json</code></pre>
<h3>安装</h3>
<p>在项目的根目录执行：</p>
<pre><code>$ npm init // 生成项目依赖文件配置 package.json
$ npm install webpack -g // 全局安装webpack
$ touch webpack.config.js // 在项目根目录下，新建 webpack.config.js 文件</code></pre>
<h3>配置</h3>
<p>然后，在以下3个文件，输入内容：</p>
<ol>
<li>
<p>页面 HTML 文件</p>
<pre><code>// views_dev/index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;哈喽，world&lt;/div&gt;
    &lt;script src="../asset/dev/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</li>
<li>
<p>页面引用的 js 文件</p>
<pre><code>// src/pages/index/index.js
console.log('I am in index/index.js, haha4');</code></pre>
</li>
<li>
<p>webpack 打包配置</p>
<pre><code>// webpack.config.js
module.exports = {
// 入口：要进行处理的实例（js）
entry: './src/pages/index/index.js',
// 出口：输出配置
output: {
    // 输出到哪个目录
    path: './asset/dev/',
    // 静态资源的引用路径
    publicPath: '/asset/dev/',
    // 实例最终输出的名字
    filename: '[name].js'
}
};</code></pre>
</li>
</ol>
<h3>运行</h3>
<p><strong>运行 webpack 命令</strong>，进行打包。</p>
<pre><code>$ webpack</code></pre>
<p>然后，搞定了，此时用浏览器打开 <code>views_dev/index.html</code> 这个文件，你会发现，打包成功了！</p>
<p><img data-src="/img/bVB25D?w=777&amp;h=169" src="/img/bVB25D?w=777&amp;h=169.png"></p>
<p>好的，你入门了，哈哈！接下去，我会详细介绍单个页面打包、多个页面打包，以及最后的发布上线。Now, go ~</p>
<h2>单个页面打包</h2>
<p>这里，你将学到：</p>
<ol>
<li><p>引入其它 js 文件。是的，你将学会 <strong>模块化</strong>。</p></li>
<li><p>引入其它类型的文件，以 css 为例。</p></li>
<li><p>实时编译 + 浏览器同步刷新。爽！</p></li>
</ol>
<p>现在，我们的项目目录，是这样：</p>
<pre><code>webpack_demo
|--src
|  |--pages
|  |  |--index
|  |  |  |--index.js
|  |  |  |--test.js
|  |  |  |--index.css
|  |--plugins
|  |  |--dialog
|  |  |  |--dialog.css
|  |  |  |--dialog.js
|--views_dev
|  |--index.html
|--webpack.config.js
|--package.json</code></pre>
<h3>引入其它 js 文件</h3>
<ol>
<li>
<p>通过相对路径<br>现在，我们要在 <code>src/pages/index.js</code> 里面引入 <code>src/pages/test.js</code> 文件。这样做就可以了：</p>
<pre><code>var Test = require('./test.js');</code></pre>
<p>你也许会问，此时，<code>var Test</code> 这个变量，得到的是什么？换个说法，怎么控制 <code>test.js</code> 被导出到外部的内容。答案是：通过 <code>module.exports</code>. 例如：</p>
<pre><code>// index/test.js
var str = "I am in test.js";
module.exports = str;</code></pre>
<p>那么，<code>require('./test.js')</code> 的值就是 "I am in test.js" 这个字符串。<code>module.exports</code> 可以导出任何值。比如，我们要导出 Object.</p>
<pre><code>module.exports = {
  aa: 'axxx',
  b: function() {}
};</code></pre>
</li>
<li>
<p>通过别名或模块<br>如果只能使用相对路径，那 <code>webpack</code> 就太不靠谱了。因为将有可能出现这样 <code>../../../../libs/libs-tost/toast.js</code>, 啊，想死！那么，怎么通过别名引入文件呢？假如，我们想引入 <code>src/plugins/dialog/dialog.js</code> 这个弹窗。</p>
<ul>
<li>
<p>在 <code>webpack.config.js</code> 中，配置别名</p>
<pre><code>// webpack.config.js
module.exports = {
    resolve: {
        // 定义别名
        alias: {
            plugins: 'D:/your/path/webpack_demo/src/plugins', // 别名可以是目录
            myDialog: 'D:/your/path/webpack_demo/src/plugins/dialog/dialog.js' // 也可以是文件
        }
    }
}</code></pre>
</li>
<li>
<p>可以使用了</p>
<pre><code>// src/index/index.js
var Dialog = require('plugins/dialog/dialog.js'); // 方式一
var Diaglog = require('myDialog'); // 方式二</code></pre>
<p>说明：<code>require(TagPath)</code> 的 <code>TagPath</code> 如果以单词开头，将被认为是模块匹配，它会去找 <code>node_modules</code> 和 <code>resolve.alias</code> 下的模块（或别名）。以方式一为例，它的<code>TagPath</code> 是以 <code>plugins</code> 开头（注意下：<code>/plugins</code> 和 <code>./plugins</code> 都不叫以单词开头），所以可以顺利匹配到 <code>resolve.alias.plugins</code>. 在实际应用中，你经常会看到 <code>require('jquery')</code>, <code>require('vue')</code>, <code>require('react')</code>, 这些就是匹配到 <code>node_modules</code> 下已安装的模块。</p>
</li>
</ul>
</li>
</ol>
<h3>引入其它类型的文件</h3>
<p><code>webpack</code> 的强大之处是，它允许你引入任何文件，比如：css, jpg, png. 那么，问题来了，对于不同的文件，它要怎么知道该如何分开处理呢？</p>
<pre><code>// webpack.config.js
module.exports = {
    module: {
        loaders: [{
            test: /\.css$/,
            loader: 'style!css'
        }, {
            test: /\.js$/,
            loader: 'babel'
        }]
    }
};</code></pre>
<p>上面的配置是说，对于拓展名是 <code>.css</code> 的文件，使用加载器 <code>style!css</code>（这边中间有一个感叹号，意思是：先是用 css  加载器处理，然后使用 style 加载器处理）。完整的写法是：<code>style-loader!css-loader</code>, 其中，<code>-loader</code>可以省略。而这里的，<code>style-loader</code> 和 <code>css-loader</code> 就需要你 npm 安装下了。</p>
<pre><code>$ npm i style-loader -D
$ npm i css-loader -D</code></pre>
<p>对于其它拓展名的处理，也是用同样的方式来处理。</p>
<h3>释放双手：自动编译 + 浏览器同步刷新</h3>
<p>你肯定希望，这样的功能。那么，开始吧，喝杯咖啡！</p>
<ol>
<li><p>自动编译<br>如果你只是想支持自动编译，那么很简单。只要运行 <code>$ webpack -w</code> 就可以开启它的自动编译功能。</p></li>
<li>
<p>用 webpack-dev-server 实现：自动编译 + 浏览器同步刷新</p>
<ul>
<li>
<p>首先，你需要安装 <code>webpack-dev-server</code> 这个包。</p>
<pre><code>$ npm i webpack-dev-server -D</code></pre>
</li>
<li>
<p>然后，我简单介绍下它：<a href="https://webpack.github.io/docs/webpack-dev-server.html">webpack-dev-server 文档</a></p>
<ul>
<li><p>运行时，它会启动一个本地 Node 服务器，默认端口8080. 即：localhost:8080. 并且自动识别当前目录下的 <code>webpack.config.js</code> 文件，来作为 <code>webpack</code> 配置文件。</p></li>
<li><p>产出的编译后文件，不在 output.path 里，而在它自己定义的内存。</p></li>
<li>
<p>行内参数说明：</p>
<ul>
<li><p>inline: 使用命令行模式。</p></li>
<li><p>content-base: 指定网站的根地址，如果你想指定为项目根目录，那么 <code>--content-base ./</code></p></li>
<li><p>hot: 开启热替换。一般用在 React 和 Vue 当中，我们这里不用。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>好了，那么，启动它吧：</p>
<pre><code>$ webpack-dev-server  --inline --content-base ./</code></pre>
<p>然后，你在浏览器中，访问 <code>http://localhost:8080/views_dev/index.html</code> 就会发现，你修改代码的时候，实时编译，并且浏览器同步刷新了。（不过，要补充一下，触发 webpack 重新编译时，才能同步刷新浏览器。意味着，你修改 <code>views_dev/*.html</code> 的 HTML 文件时，浏览器，不会被刷新，因为它不会触发 webpack 重新编译。）</p>
</li>
</ol>
<h2>多页面打包</h2>
<p>现在，我们加一点点配置，让它支持多个页面打包。之前，它是这样的：</p>
<pre><code>module.exports = {
    // 入口：要进行处理的实例（js）
    entry: './src/pages/index/index.js',
    // 出口：输出配置
    output: {
        // 输出到哪个目录
        path: './asset/dev/',
        // 静态资源的引用路径
        publicPath: '/asset/dev/',
        // 实例最终输出的名字
        filename: '[name].js'
    },
    // 其它配置...
};</code></pre>
<p>现在，我们需要改下 <code>entry</code> 的配置，如下：</p>
<pre><code>entry: {
    index: './src/pages/index/index.js',
    list: './src/pages/list/index.js',
    common: [
        './src/base/base.js',
        './src/base/base.css'
    ]
}</code></pre>
<p>上面的配置意思是，会独立打包3个实体。分别是 index, list, common. 知识点如下：</p>
<ol>
<li><p>它支持多个文件打包在一起，如这里的 <code>common</code> 的配置。我们一般，用来放公共基础包。</p></li>
<li>
<p>我们看到 <code>output.filename = [name].js</code>，这里的 <code>[name]</code> 取自于 entry 的 key 值。意味着，他们最终打包的输出是：</p>
<pre><code>webpack_demo
|--asset
|  |--dev
|  |  |--index.js
|  |  |--list.js
|  |  |--common.js</code></pre>
</li>
</ol>
<h2>上线</h2>
<p>发布上线，需要做什么呢？也许是这样：</p>
<ol>
<li><p>把静态资源生成到一个独立的目录下</p></li>
<li><p>压缩</p></li>
<li><p>加上 md5</p></li>
<li><p>html 和 css 中，引用的静态资源需要替换。</p></li>
</ol>
<p>哈哈，或许你还能想到很多。我就上面4步来说下实现方式。开始之前，我们一般会这么做：新建一个 webpack 的配置文件，用来做上线发布的配置。比如，我们同样放在根目录下，命名 <code>webpack.config.build.js</code>. 此时，你可以这样做：</p>
<pre><code>$ webpack -p --config webpack.config.build.js</code></pre>
<p>这里的 <code>-p</code> 是 production 模式的意思，它会对 css, js 文件进行压缩。后面 <code>--config</code> 就是指定此次运行的配置文件。</p>
<p>然后，我们来解决上面的4个要求：</p>
<ol>
<li>
<p>把静态资源生成到一个独立的目录下 + md5 + css引用的资源替换</p>
<pre><code>// webpack.config.build.js
module.exports = {
    output: {
        path: './asset/build/', // 文件编译输出路径改成 build
        publicPath: 'http://yourweb.com/asset/build/', // 这里替换成线上实际地址，可以修改 css 中对图片资源的引用路径。
        filename: '[name]_[hash:5].js' // 生成的文件名字，加上了5位的 hash值。当然了，位数和加hash的位置，你可以自己定义，比如 '[name].js?[hash]'.
    },
    // 其它配置...
};</code></pre>
</li>
<li><p>压缩。用 <code>webpack -p</code> 解决了。</p></li>
<li><p>替换 HTML 中静态资源的路径。可以用 webpack 的插件，<code>html-webpack-plugin</code> 来做。或者，你对 gulp 还是比较熟悉的话，用 <code>gulp-prefix</code> 来实现。这里就不详细写配置了。</p></li>
</ol>
<p>然后，恭喜你看完了！</p>