<h1>使用Web存储API</h1>
<blockquote><p><strong>TODO:</strong>本文由 <strong>赤石俊哉</strong> 翻译整理，您可以将本文自由地用于学习交流。如需用于其他用途请征得作者的同意。 <br>原文链接：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">Using the Web Storage API - Mozilla Developer Network (英文)</a></p></blockquote>
<hr>
<blockquote><p>Web存储API提供了浏览器可以在本地安全存储键值对的一个机能，它比cookies更为直观。这篇文章将会简单阐述一下如何来简单地使用这种技术。</p></blockquote>
<h2>基础概念</h2>
<p>存储对象是一个简单的键值存储，它跟对象类似，但是它们在页面读取后依然完整。键和值总是字符串（注意，整型数据也会自动地转为字符串，就像对象那样）。你可以像访问一个对象一样来访问这些值，或者使用方法：<code>Storage.getItem()</code>和<code>Storage.setItem()</code>。下面这三行都是设置了<code>colorSetting</code>记录：</p>
<pre><code class="javascript">localStorage.colorSetting = '#a4509b';
localStorage['colorSetting'] = '#a4509b';
localStorage.setItem('colorSetting', '#a4509b');</code></pre>
<blockquote><p><strong>Note:</strong> 强烈推荐使用Web存储API（<code>setItem</code>, <code>getItem</code>, <code>removeItem</code>, <code>key</code>, <code>length</code>）进行纯对象的键值操作来防止可能出现的隐患。</p></blockquote>
<p>两种Web存储中包含的机能如下:</p>
<ul>
<li><p><strong>sessionStorage</strong> 为每一个页面访问session期间维持一个单独的存储空间（只要浏览器打开就一直维持，包括页面重载和重新存储）。</p></li>
<li><p><strong>localStorage</strong> 做同样的事情，只不过在浏览器被关闭再打开后仍然维持着。</p></li>
</ul>
<p>这些机能可以通过<code>Window.sessionStorage</code>和<code>Window.localStorage</code>属性（更准确的说，在支持的浏览器中，<code>Window</code>对象实现了<code>WindowLocalStorage</code>和<code>WindowSessionStorage</code>对象，他们是由<code>localStorage</code>和<code>sessionStorage</code>挂起的）——调用其中任何一个，都会创建一个<code>Storage</code>对象的实例，透过它，数据项目可以被设置，取回，和移除。每一个<code>sessionStorage</code>和<code>localStorage</code>的源都是用不同的存储对象——它们是分辨运作和被控制的。</p>
<p>所以，第一次在文档中调用<code>localStorage</code>后，它会返回一个<code>Storage</code>对象，调用<code>sessionStorage</code>之后，他又会返回另一个<code>Storage</code>对象。它们都可以用同一种方式进行操控，但是都是彼此独立的。</p>
<h2>localStorage 功能检测</h2>
<p>为了能使用localStorage，我们应该先进行确认，当前的浏览器会话是否支持和允许使用它。</p>
<h3>测试支持和可用性</h3>
<p>如果浏览器支持localStorage，在它的window对象中就会有一个属性叫作<code>localStorage</code>。但是，由于种种原因，如果直接去断定这个属性是否存在可能会抛出异常。如果它确实存在，也没有保障我们就一定可以使用它，因为很多浏览器支持在设定中禁用localStorage。举个例子，那就是Safari，在隐私浏览模式下，他会给我们一个配额为0的空的localStorage对象，实际上就是使它无效化。我们在检测的时候，也应该把这一点考虑进来。</p>
<p>下面是一个用于检测localStorage是否支持以及可用的方法：</p>
<pre><code class="javascript">function storageAvailable(type) {
    try {
        var storage = window[type],
            x = '__storage_test__';
        storage.setItem(x, x);
        storage.removeItem(x);
        return true;
    }
    catch(e) {
        return false;
    }
}</code></pre>
<p>你应该这样使用它：</p>
<pre><code class="javascript">if (storageAvailable('localStorage')) {
    // Yippee! We can use localStorage awesomeness
}
else {
    // Too bad, no localStorage for us
}</code></pre>
<p>你可以用相同的办法来测试<code>sessionStorage</code>：<code>storageAvailable('sessionStorage')</code>。</p>
<p>你可以参考一下<a href="https://gist.github.com/paulirish/5558557">localStorage功能检测简报（英文）</a>。</p>
<h2>一个简单的例子</h2>
<p>为了举例说明一些典型的Web存储用例，我们创建了一个简单的例子，叫它<strong>Web Storage Demo</strong>吧。<a href="https://mdn.github.io/dom-examples/web-storage/">登录页面</a>提供了一个控件来自定义颜色，字体，和装饰图片：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008981523?w=700&amp;h=482" src="/img/remote/1460000008981523?w=700&amp;h=482.png"></span></p>
<p>当你选择不同的选项，页面会实时地更新，顺带一提，你的选项会被存储到<code>localStorage</code>里存储。所以当你离开页面重新载入它的时候，你的选择会被记住。</p>
<p>我们也提供了一个<a href="https://mdn.github.io/dom-examples/web-storage/event.html">事件输出页面</a>——如果你在另一个标签页中载入这个页面，那么你在登录页面中做出的任何选择之后，你会看到更新了的存储信息会被显示出来，因为<code>StorageEvent</code>被触发了。</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008981524?w=700&amp;h=482" src="/img/remote/1460000008981524?w=700&amp;h=482.png"></span></p>
<blockquote><p><strong>Note:</strong> 你可以从这里查看<a href="https://github.com/mdn/dom-examples/tree/master/web-storage">源代码</a>。</p></blockquote>
<h2>检测你的数据是否被填充成功</h2>
<p>拿上面的例子来说，在<code>main.js</code>中，我们将会测试存储对象是否已经被填入（也就是说页面是否之前就已经载入过了）：</p>
<pre><code class="javascript">if(!localStorage.getItem('bgcolor')) {
  populateStorage();
} else {
  setStyles();
}</code></pre>
<p><code>Storage.getItem()</code>方法被用于从存储中获取数据项目。在这个例子中，我们测试<code>bgcolor</code>项目是否存在。如果不存在，我们运行<code>populateStorage()</code>来将已经存在的自定义值存入存储。如果已经有数据了，我们运行<code>setStyle()</code>以使用存储的值来更新页面的样式。</p>
<p><strong>Note:</strong> 你也可以使用<code>Storage.length</code>来测试存储对象是否为空。</p>
<h2>从存储中获取数据</h2>
<p>就像之前我们所描述的，数据可以从存储中使用<code>Storage.getItem()</code>来获取。这个方法使用键来做参数，它会返回相应的数据的值。举个例子：</p>
<pre><code class="javascript">function setStyles() {
  var currentColor = localStorage.getItem('bgcolor');
  var currentFont = localStorage.getItem('font');
  var currentImage = localStorage.getItem('image');

  document.getElementById('bgcolor').value = currentColor;
  document.getElementById('font').value = currentFont;
  document.getElementById('image').value = currentImage;

  htmlElem.style.backgroundColor = '#' + currentColor;
  pElem.style.fontFamily = currentFont;
  imgElem.setAttribute('src', currentImage);
}</code></pre>
<p>在这里，前三行从本地存储中取出数据，接下来我们使用这些值设置显示的表单元素。所以当我们重新读取页面的时候，它们会保持同步。最后，我们更新了页面上的样式和装饰图片，所以你的自定义数值都在重载页面之后重现了。</p>
<h2>在存储中设置值</h2>
<p><code>Storage.setItem()</code>可以用于创建也可以用于更新数据的值。它需要两个参数——需要修改或者创建的键名，需要存储的值。</p>
<pre><code class="javascript">function populateStorage() {
  localStorage.setItem('bgcolor', document.getElementById('bgcolor').value);
  localStorage.setItem('font', document.getElementById('font').value);
  localStorage.setItem('image', document.getElementById('image').value);

  setStyles();
}</code></pre>
<p><code>populateStorage()</code>方法在本地存储中设置了三个项目——背景颜色，字体，图片路径。然后运行<code>setStyles()</code>方法更新页面样式，等等。</p>
<p>我们也在每一个表单元素上包含了一个<code>onchange</code>句柄，当表单的值发生改变时，数据和样式会立刻进行更新。</p>
<pre><code class="javascript">bgcolorForm.onchange = populateStorage;
fontForm.onchange = populateStorage;
imageForm.onchange = populateStorage;</code></pre>
<h2>使用StorageEvent在存储做出改变时进行响应</h2>
<p><code>StorageEvent</code>会在<code>Storage</code>对象发生变化时进行相应。它不能很好地在发生改变的页面上进行相应，但是在同一个域名的页面之间同步任何变化时，这是会是一个不错的方法。在不同的域名中无法访问相同的存储对象。</p>
<p>在事件页面（<code>events.js</code>）中，只有如下的代码:</p>
<pre><code class="javascript">window.addEventListener('storage', function(e) {  
  document.querySelector('.my-key').textContent = e.key;
  document.querySelector('.my-old').textContent = e.oldValue;
  document.querySelector('.my-new').textContent = e.newValue;
  document.querySelector('.my-url').textContent = e.url;
  document.querySelector('.my-storage').textContent = e.storageArea;
});</code></pre>
<p>这里我们添加了一个事件监听器给<code>window</code>对象，当当前源的存储对象发生改变时引发。就如你所能看见的，这个事件的参数包含了很多有用的信息——发生变化的键名，旧值，新值，发生变化的文档的URL，以及存储对象其自身。</p>
<h2>删除数据记录</h2>
<p>Web存储也提供了一对简单的方法来移除数据。在我们的demo中没有使用这些，把它们加到我们的项目里面来也不难。</p>
<ul>
<li><p><code>Storage.removeItem()</code>使用一个简单的参数（你想要移除的数据项目的键）来将它从域名下的存储对象中移除它。</p></li>
<li><p><code>Storage.clear()</code>是一个无参方法，它会清空域名下所有的存储对象。</p></li>
</ul>
<h2>浏览器兼容性</h2>
<h3>桌面</h3>
<table>
<thead><tr>
<th>特    性</th>
<th>Chrome</th>
<th>Firefox(Gecko)</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari(Webkit)</th>
</tr></thead>
<tbody>
<tr>
<td>localStorage</td>
<td>4</td>
<td>3.5</td>
<td>8</td>
<td>10.50</td>
<td>4</td>
</tr>
<tr>
<td>sessionStorage</td>
<td>5</td>
<td>2</td>
<td>8</td>
<td>10.50</td>
<td>4</td>
</tr>
</tbody>
</table>
<h3>移动</h3>
<table>
<thead><tr>
<th>特   性</th>
<th>Android</th>
<th>Firefox Mobile(Gecko)</th>
<th>IE Phone</th>
<th>Opera Mobile</th>
<th>Safari Mobile</th>
</tr></thead>
<tbody><tr>
<td>基础支持</td>
<td>2.1</td>
<td>?</td>
<td>8</td>
<td>11</td>
<td>iOS 3.2</td>
</tr></tbody>
</table>
<h2>Storage 事件</h2>
<p>当一个存储区域（本地存储和会话存储）被修改时，storage事件会被触发。</p>
<h3>通用信息</h3>
<table>
<thead><tr>
<th> </th>
<th> </th>
</tr></thead>
<tbody>
<tr>
<td>规范</td>
<td><a href="http://www.w3.org/TR/webstorage/#the-storage-event">Web Storage</a></td>
</tr>
<tr>
<td>接口</td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageEvent">StorageEvent</a></td>
</tr>
<tr>
<td>冒泡</td>
<td>否</td>
</tr>
<tr>
<td>可取消</td>
<td>否</td>
</tr>
<tr>
<td>目标</td>
<td>DefaultView(&lt;window&gt;)</td>
</tr>
<tr>
<td>默认动作</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3>属性</h3>
<table>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>target <code>readonly</code>
</td>
<td>EventTarget</td>
<td>事件的目标（DOM树中最顶层的目标）</td>
</tr>
<tr>
<td>type <code>readonly</code>
</td>
<td>DOMString</td>
<td>事件的类型</td>
</tr>
<tr>
<td>bubbles <code>readonly</code>
</td>
<td>Boolean</td>
<td>事件是否冒泡（bubbles）</td>
</tr>
<tr>
<td>cancelable <code>readonly</code>
</td>
<td>Boolean</td>
<td>事件是否可以取消</td>
</tr>
<tr>
<td>key <code>readonly</code>
</td>
<td>DOMString(string)</td>
<td>被修改的键名</td>
</tr>
<tr>
<td>oldValue <code>readonly</code>
</td>
<td>DOMString(string)</td>
<td>旧的值</td>
</tr>
<tr>
<td>newValue <code>readonly</code>
</td>
<td>DOMString(string)</td>
<td>新的值</td>
</tr>
<tr>
<td>url <code>readonly</code>
</td>
<td>DOMString(string)</td>
<td>更新该键名的文档的地址</td>
</tr>
<tr>
<td>storageArea <code>readonly</code>
</td>
<td>Storage</td>
<td>被影响的存储对象</td>
</tr>
</tbody>
</table>