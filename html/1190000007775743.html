<p>加载项目时,不管那些代码有没有执行到，都会下载下来。如果说，我们只下载我们需要执行的代码话，那么可以节省相当大的流量。也就是我们所说的按需加载,这对于大型项目是相当有用的。</p></blockquote>
<h1>基本使用</h1>
<p><a href="http://webpack.github.io/docs/code-splitting.html">webpack官网</a>有详细的介绍，这里简单阐述下：</p>
<p>加载函数：</p>
<pre><code>require.ensure(dependencies, callback, chunkName)</code></pre>
<p>这个方法可以实现js的按需加载，分开打包，<code>webpack</code>管包叫<code>chunk</code>，为了打包能正常输出，我们先给<code>webpack</code>配置文件配置一下chunk文件输出路径:</p>
<pre><code>// webpack.config.js
module.exports = {
  ...
  output: {
    ...
    chunkFilename: '[name].[chunkhash:5].chunk.js',
    publicPath: '/dist/'
  }
  ...
}</code></pre>
<p>每个chunk都会有一个ID，会在webpack内部生成，当然我们也可以给<code>chunk</code>指定一个名字，就是<code>require.ensure</code>的第三个参数。</p>
<p>注意： 如果这里不配置<code>chunkFilename</code>，那么打包出来的名称是id加name。</p>
<p>配置文件中</p>
<ul>
<li><p>[name] 默认是 ID，如果指定了chunkName则为指定的名字。</p></li>
<li><p>[chunkhash] 是对当前chunk 经过hash后得到的值，可以保证在chunk没有变化的时候hash不变，文件不需要更新，chunk变了后，可保证hash唯一，由于hash太长，这里截取了hash的5个字符。</p></li>
</ul>
<h1>demo展示</h1>
<pre><code class="javascript">// a.js
console.log('a');

// b.js
console.log('b');

// c.js
console.log('c');

// entry.js
require.ensure([], () =&gt; {
  require('./a')
  require('./b')
}, 'chunk1')

if(false){
  require.ensure([], () =&gt; {
    require('./c')
  }, 'chunk2')
}</code></pre>
<p>将会打包出3个文件，基础包、chunk1 和 chunk2，但是chunk2在if判断中，而且永远为false，所以 chunk2 虽然打包了但永远不会被加载。</p>
<h1>结合 react-router 按需加载</h1>
<p>react-router本身有一套<a href="https://react-guide.github.io/react-router-cn/docs/guides/advanced/DynamicRouting.html">动态加载方案</a>。</p>
<pre><code class="javascript">const CourseRoute = {
  path: 'course/:courseId',

  getChildRoutes(location, callback) {
    require.ensure([], function (require) {
      callback(null, [
        require('./routes/Announcements'),
        require('./routes/Assignments'),
        require('./routes/Grades'),
      ])
    })
  },

  getIndexRoute(location, callback) {
    require.ensure([], function (require) {
      callback(null, require('./components/Index'))
    })
  },

  getComponents(location, callback) {
    require.ensure([], function (require) {
      callback(null, require('./components/Course'))
    })
  }
}</code></pre>
<ul>
<li><p><code>getChildRoutes</code></p></li>
<li><p><code>getIndexRoute</code></p></li>
<li><p><code>getComponents</code></p></li>
</ul>
<h1>实际操作</h1>
<pre><code class="javascript">const home = (location, callback) =&gt; {
  require.ensure([], require =&gt; {
    callback(null, require('modules/home'))
  }, 'home')  
}

const blog = (location, callback) =&gt; {
  require.ensure([], require =&gt; {
    callback(null, require('modules/blog'))
  }, 'blog')  
}

&lt;Router history={history}&gt;
  &lt;Route path="/" component={App}&gt;
    &lt;Route path="home" getComponent={home}&gt;&lt;/Route&gt;
    &lt;Route path="blog" getComponent={blog}&gt;&lt;/Route&gt;
  &lt;/Route&gt;
&lt;/Router&gt;</code></pre>
<h1>能否将按需加载抽成公共函数？</h1>
<p>答案：不可以。</p>
<p>因为<code>require</code>函数太特别了，他是<code>webpack</code>底层用于加载模块，所以必须明确的声明模块名，<code>require</code>函数在这里只能接受字符串，不能接受变量 。</p>
<blockquote><p><a href="https://github.com/ReactTraining/react-router/tree/master/examples/huge-apps/routes/Grades">react-router官网案例</a></p