<h3>疑问</h3>
<p>最近遇到个问题：<code>flex:1;</code>跟<code>flex:1 1 0;</code>是否等价。按照我之前对W3C属性值语法的理解，<code>flex:1;</code>应该是<code>flex:1 1 auto;</code>的缺省写法，剩下的两个<code>flex-shrink</code>和<code>flex-basis</code>的坑应该分别对应<code>1</code>和<code>auto</code>。嗯，如果我没记错的话，简写属性(shorthand)有个特性：对于缺省值会重置为对应的单个属性的初始值（详情请参看《CSS权威指南第三版》P130）。这里的<code>flex-shrink</code>和<code>flex-basis</code>就是缺省的单个属性。可是常规测试（弹性子项未填充内容）都不能让人明显感知到<code>flex:1;</code>跟<code>flex:1 1 0;</code>的区别。那么问题来了：How Can We Feel The Difference？</p>
<h3>Try It</h3>
<p>首先，确定我们要做什么？通过实验了解flex的缺省auto跟0有何区别。</p>
<p>然后，给出代码（可以去我的<a href="https://github.com/uolcano/FECourseNote/tree/master/OtherResource/HTML_ref">Github</a>上找到名为shorthand_flex_test的两个文件查看源代码）：</p>
<pre><code class="css">.contain {
    background: #aec;
    height: 100px;
    display: flex;
    justify-content: space-around;/*设置主轴方向均分对齐*/
    flex-flow: row wrap;/*设置正常水平排列*/
    align-items: stretch;/*设置所有弹性子项拉伸到弹性容器高度*/
}
.item {
    border: 3px solid rgba(0,0,0,.2);
    padding: 10px;
    background: #eac;
    color: #fff;
    font-size: 2em;
    font-weight: bold;
    text-align: center;
}</code></pre>
<p>效果图：</p>
<p><img data-src="/img/bVr9HV" src="/img/bVr9HV.png"></p>
<p>接下来，看实验。</p>
<p><strong>第一步：<code>flex:1;</code> 和 <code>flex:1 1 auto;</code> 根据官方定义，缺省值就是初始值，两个实现出来的效果就应该相同。</strong></p>
<p>给.item设置<code>flex:1;</code>，效果图如下：</p>
<p><img data-src="/img/bVr9HZ" src="/img/bVr9HZ.png"></p>
<p>给.item设置<code>flex:1 1 auto;</code>，效果图：</p>
<p><img data-src="/img/bVr9Ig" src="/img/bVr9Ig.png"></p>
<p>WTF？不对！</p>
<p>先别急，F12看下设置<code>flex:1;</code>时devtool窗口里的计算值</p>
<p><img data-src="/img/bVr9IH" src="/img/bVr9IH.png"></p>
<p>再看看设置<code>flex:1 1 auto;</code>时的计算值（这句是废话，请自动省略）</p>
<p><img data-src="/img/bVr9IN" src="/img/bVr9IN.png"></p>
<p><strong>小结：</strong>原来缺省的时候不是取的单项的初始值啊（<code>flex-shrink:1</code>和<code>flex-basis:auto</code>）。那么这个<code>0%</code>是不是就等价于<code>0</code>呢？</p>
<p><strong>第二步，这次改为设置<code>flex:1 1 0;</code></strong></p>
<p><img data-src="/img/bVr9I1" src="/img/bVr9I1.png"></p>
<p>图还是这样的，可是计算值不一样啊，如下</p>
<p><img data-src="/img/bVr9I2" src="/img/bVr9I2.png"></p>
<p><strong>小结：</strong>其实百分比的计算值是以父类容器的宽度为基数计算的，而长度值<code>0</code>直接取值不用再计算，但是<code>0%</code>和<code>0</code>的最终计算值都是<code>0px</code>。</p>
<h3>解答结果</h3>
<p>所以说开始的疑问得到解答了：<code>flex:1;</code>跟<code>flex:1 1 0;</code>的视觉效果和最终计算值是一样的，只不过是计算过程不同。</p>
<h3>扩展实验</h3>
<p><strong>Part 1. 既然都做实验了，那么可以“顺便”研究一下，<code>flex</code>的几个常用值的几种写法，这里是<a href="https://drafts.csswg.org/css-flexbox/#flex-basis-property">drafts.csswg.org的</a>链接。</strong></p>
<blockquote><p><strong>第一种：<code>flex:initial;</code>等价于<code>flex:0 1 auto;</code>，也等价于<code>flex:0 auto;</code></strong></p></blockquote>
<p>给.item设置<code>flex:initial;</code></p>
<p><img data-src="/img/bVr9K3" src="/img/bVr9K3.png"></p>
<p>计算值</p>
<p><img data-src="/img/bVr9Px" src="/img/bVr9Px.png"></p>
<p><strong>小结：</strong>这里是<code>auto</code>自适应得到的<code>10%</code>。这个属性声明得到的效果就是使得弹性子项在有多余空间的时候不拉伸，在空间不足时收缩到最小的宽度/高度（由主轴方向决定具体的计算基数）。这里的宽度/高度可能涉及到弹性子项内部的文本内容，内容的有无使得<code>auto</code>跟另一个<code>flex-basis</code>的属性<code>content</code>有差异，后面讲。另外，当设置为这个属性值的时候，弹性容器上设置的主轴方向对齐效果和<code>margin:auto;</code>居中效果才能生效。</p>
<blockquote><p><strong>第二种：<code>flex:auto;</code>等价于<code>flex:1 1 auto;</code></strong></p></blockquote>
<p>给.item设置<code>flex:auto;</code></p>
<p><img data-src="/img/bVr9NF" src="/img/bVr9NF.png"></p>
<p>计算值</p>
<p><img data-src="/img/bVr9NG" src="/img/bVr9NG.png"></p>
<p><strong>小结：</strong>这使得弹性子项在有多余空间时拉伸，在空间不足时收缩。这时候弹性子项才有完整的弹性效果，而当多个弹性子项设置不同的<code>flex</code>属性声明时，任何多余空间都将被设置了<code>auto</code>属性值的弹性子项“吸收”掉。</p>
<blockquote><p><strong>第三种，<code>flex:none</code>等价于<code>flex:0 0 auto;</code></strong></p></blockquote>
<p>给.item设置<code>flex:none</code></p>
<p><img data-src="/img/bVr9NT" src="/img/bVr9NT.png"></p>
<p>计算值</p>
<p><img data-src="/img/bVr9NY" src="/img/bVr9NY.png"></p>
<p><strong>小结：</strong>这使得弹性子项完全失去弹性效果。效果跟设置<code>auto</code>属性值差不多，但是一旦内容溢出弹性容器，这里的弹性子项是不会收缩的。</p>
<p><strong>Part 2. 继续，看看之前提到的<code>content</code>是怎么回事。</strong></p>
<p>第一步，我们来跟<code>initial</code>的等价值做个对照。<code>initial</code>的就不贴了，Part1的第一种里有。直接看<code>flex:0 1 content;</code></p>
<p><img data-src="/img/bVr9PC" src="/img/bVr9PC.png"></p>
<p>计算值</p>
<p><img data-src="/img/bVr9Py" src="/img/bVr9Py.png"></p>
<p><strong>分析：</strong>什么情况？！<code>flex</code>的计算值呢？前面的<code>none</code>都会有计算值的，这里竟然不见了！稍等，可不可以这样理解，在设置<code>content</code>的时候，前面两个值可以忽略？</p>
<p>第二步，设置<code>flex:content;</code></p>
<p><img data-src="/img/bVr9PD" src="/img/bVr9PD.png"></p>
<p>计算值</p>
<p><img data-src="/img/bVr9PE" src="/img/bVr9PE.png"></p>
<p><strong>分析：</strong>果然是一毛一样的。BUT,WHY?<code>content</code>到底是干啥子的？</p>
<p><a href="https://drafts.csswg.org/css-flexbox/#valdef-flex-basis-content">标准</a>里说这个属性值设置会使得弹性子项的宽度/高度直接由其中的内容决定。哦~，难怪对照效果中明显是上面那组的弹性子项“们”是被内容撑开了的。</p>
<p>でも、这岂不是跟不设置<code>flex</code>属性没两样了！书读少勿欺我！保险起见，我只能开“大招”了：</p>
<pre><code class="css">    -webkit-flex: content;
    -moz-flex: content;
    -ms-flex: content;
    -o-flex: content;
    flex: content;</code></pre>
<p><img data-src="/img/bVr9QM" src="/img/bVr9QM.png"></p>
<p>计算值里还是找不到<code>flex</code>的影子</p>
<p><img data-src="/img/bVr9QR" src="/img/bVr9QR.png"></p>
<p>第三步，再在第二步的“大招”基础上加个<code>width:100px;</code></p>
<p><img data-src="/img/bVr9Q0" src="/img/bVr9Q0.png"></p>
<p>计算值里还只没影儿</p>
<p><img data-src="/img/bVr9Q2" src="/img/bVr9Q2.png"></p>
<p><strong>分析：</strong>这里给每个弹性子项设置了固定宽度（因为这水平轴就是主轴），因为没有<code>flex</code>属性的伸展因子<code>flex-grow</code>和收缩因子<code>flex-shrink</code>的影响，每个弹性子项都“老老实实的”按照<code>justify-content: space-around</code>的指令水平对齐了（嘴上说着不要“身体”还是挺老实的嘛，啧啧）。</p>
<p>好吧，只能承认，<code>content</code>是个无效的属性值。对！它并不是属性值。好大一个玩笑（轻点，别打脸）。它只是表示弹性子项的宽度/高度由内容决定，即被内容撑开。而这个撑开的宽度/高度则作为伸展因子和收缩因子的基数进行相应弹性变化的计算。</p>
<p><strong>Part 3. 凭什么说被内容撑开的宽度/高度就是连体因子（舌头打结了）的计算基数？不服来辩！</strong></p>
<p>第一步，先看不设置<code>flex</code>属性时上面对照实验中上面一组的数据（记得“关了”<code>width</code>），从左至右：</p>
<p><img data-src="/img/bVr9RT" src="/img/bVr9RT.png"></p>
<p><img data-src="/img/bVr9RU" src="/img/bVr9RU.png"></p>
<p><img data-src="/img/bVr9RV" src="/img/bVr9RV.png"></p>
<p>可以看到第一个no1和第三个no3的宽度是相同的84.297，第二个是290.875。这里要注意因为<code>box-sizing</code>初始值是<code>content-box</code>，所以内容区宽就是<code>width</code>的取值，边距边框都不用管。</p>
<p>第二步，设置一个伸展因子<code>flex:1 1 auto;</code>这里必须设置<code>flex-basis:auto;</code>因为缺省后就是<code>flex-basis:0%;</code>了，相当于以撑开的宽度/高度作为的基数置零了。效果图就不上了，对应前面的<code>flex:auto;</code>，下面是计算值</p>
<p><img data-src="/img/bVr9RZ" src="/img/bVr9RZ.png"></p>
<p><img data-src="/img/bVr9R0" src="/img/bVr9R0.png"></p>
<p><img data-src="/img/bVr9R1" src="/img/bVr9R1.png"></p>
<p>可以看到这次的第一个no1和第三个no3的宽度是126.813，第二个是333.391。然后让我们搬出伸展因子的计算公式：</p>
<pre><code>flex-basis + flow-grow / sum( flow-grow ) * remain</code></pre>
<p>这里的<strong>flow-grow</strong>指的就是<code>flex-flow</code>方向上的伸展因子的数值，而由于设置了<code>flex-basis:auto;</code>主轴的基数<strong>flex-basis</strong>的计算值应该就是第一步的数据84.297、290.875和84.297；<strong>remain</strong>则是容器总宽度减去第一步中的所有宽度总和的结果：</p>
<pre><code>665 - ( 84.2969 + 290.875 + 84.2969) - (10 + 3) * 2 * 3 = 127.5312</code></pre>
<p>这里因为是算的弹性容器内的区域所以要把内边距和边框都加上，另外之前在盒模型里显示的84.297不是精确值，最下面的计算值清单里的精确值是84.2969，以免引起后面结果错误。</p>
<p><img data-src="/img/bVr9Sn" src="/img/bVr9Sn.png"></p>
<p>最后套入公式：</p>
<p>第二部中第一个和第三个弹性子项的宽：</p>
<pre><code>84.2969 + ( 1 / 3 ) * 127.5312 = 126.8073
（这里跟126.813很接近，但是我找不出那里算漏了的，有知道的朋友麻烦告知，谢谢）</code></pre>
<p>第二个弹性子项的宽：</p>
<pre><code>290.875 + （1 / 3 ) * 127.5312 = 333.3854（待查错）</code></pre>
<p>这一部分先到这里吧。花了我好久时间，好晚了。</p>
<h3>总结</h3>
<p><code>flex</code>的缺省值并非是单一属性的初始值，并且还有常用的简写属性值<code>initial</code>、<code>auto</code>和<code>none</code>；当弹性子项没有设置固定宽度（对于水平的情况，也就是宽度本身是<code>auto</code>的）时，<code>flex-basis</code>如果也是<code>auto</code>，那么<code>flex-basis</code>的使用值就是弹性子项的内容本身撑起来的宽度（对于水平的情况）</p>
<h3>工具与环境</h3>
<ul>
<li><p>操作系统：window 7 ultimate 64bit</p></li>
<li><p>chrome内核版本：45.0.2454.101</p></li>
<li><p>编辑器：Sublime Text 3</p></li>
</ul>
<h3>参考资料</h3>
<ul>
<li><p><a href="https://drafts.csswg.org/css-flexbox/#propdef-flex">CSS Flexible Box Layout Module Level 1</a></p></li>
<li><p><a href="https://css-tricks.com/almanac/properties/f/flex/">flex | CSS-Tricks</a></p></li>
<li><p>关于弹性长度计算的描述：<a href="https://drafts.csswg.org/css-flexbox/#resolve-flexible-lengths">https://drafts.csswg.org/css-flexbox/#resolve-flexible-lengths</a></p></li>
</ul>
<h3>唠叨</h3>
<p>在查找资料过程中，发现一些不错的东西，分享加收藏一下。</p>
<ul>
<li><p>不明觉厉的网站和文章：<a href="http://ptb2.me/">http://ptb2.me/</a></p></li>
<li><p>CSS Flexbox试验场：<a href="http://vagor.cc/demo/flexbox-demo/index.html">http://vagor.cc/demo/flexbox-demo/index.html</a></p></li>
<li><p>Flexbox-推陈出新：<a href="https://css-tricks.com/old-flexbox-and-new-flexbox/">https://css-tricks.com/old-flexbox-and-new-flexbox/</a></p></li>
</ul>
<p>先这样了，为了发完这文章熬夜了。熊猫君思密达。<br>对了代码可以去我的<a href="https://github.com/uolcano/FECourseNote/tree/master/OtherResource/HTML_ref">Github</a>上找，说完了。</p>
<p>再补一点信息，一定不要忘了标准的文档开篇说的：</p>
<blockquote><p>Publication as a Candidate Recommendation does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.<a href="https://drafts.csswg.org/css-flexbox/#status">1</a></p></blockquote>