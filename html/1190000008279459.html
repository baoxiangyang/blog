<p>本篇为在学习Vue2.x的时候使用Webpack2.x的踩坑与总结，关于Vue2.x的踩坑与总结，<a href="https://segmentfault.com/a/1190000008279436">点击链接</a></p></blockquote>
<p>原文链接：<a href="http://mrzhang123.github.io/2017/02/07/webpack2/">http://mrzhang123.github.io/2...</a><br>项目地址：<a href="https://github.com/MrZhang123/Vue_project/tree/master/vue2.x">https://github.com/MrZhang123...</a></p>
<h1>本地安装npm包后如何在命令行运行</h1>
<p>在npm安装包的时候，如果使用全局安装，即<code>npm install &lt;packageName&gt; -g</code>，则在安装完成后可以在终端运行作为命令去运行，但是如果是本地安装的包<code>npm install --save-dev &lt;packageName&gt;</code>，则无法这样直接运行。那么如何运行本地安装的包呢？首先进入项目目录（即package.json所在目录），然后使用以下命令即可运行：</p>
<pre><code class="shell">
$ node_modules/.bin/&lt;packageName&gt;
</code></pre>
<p>除了可以这样在命令行运行外，还可以在文件中运行</p>
<pre><code class="js">
//index.js

let webpack = require('webpack');

webpack();
</code></pre>
<pre><code class="shell">
$ node index.js
</code></pre>
<h1>webpack1.x升级2.x</h1>
<h2>1.<code>module.loaders</code>改成了<code>module.rules</code>
</h2>
<p>旧的<code>loaders</code>被新的<code>rules</code>取代，后者允许配置<code>loader</code>以及其他更多项。</p>
<pre><code class="js">  module: {
-   loaders: [
+   rules: [
      {
        test: /\.css$/,
-       loaders: [
+       use: [
          {
            loader: "style-loader"
          },
          {
            loader: "css-loader",
-           query: {
+           options: {
              modules: true
            }
        ]
      },
      {
        test: /\.jsx$/,
        loader: "babel-loader", // Do not use "use" here
        options: {
          // ...
        }
      }
    ]
  }</code></pre>
<p>以上写法中，<code>Rule.loader</code>是<code>Rule.use: [ { loader } ]</code>的简写。</p>
<h2>2.链式调用loaders</h2>
<p>在webpack1.x中loaders可以链式调用，在2.x中依旧有该特性，使用<code>rule.use</code>配置项，<code>use</code>中设置一个loaders的数组而在1.x中使用<code>!</code>连接各个loader，旧版写法只有在使用旧的<code>module.loaders</code>时有效。</p>
<pre><code class="js">  module: {
-   loaders: {
+   rules: {
      test: /\.less$/,
-     loader: "style-loader!css-loader!less-loader"
+     use: [
+       "style-loader",
+       "css-loader",
+       "less-loader"
+     ]
    }
  }</code></pre>
<h2>3.取消在模块中自动添加<code>-loader</code>后缀</h2>
<p>webpack2.x中不再添加<code>-loader</code></p>
<pre><code class="js">  module: {
    rules: [
      {
        use: [
-         "style",
+         "style-loader",
-         "css",
+         "css-loader",
-         "less",
+         "less-loader",
        ]
      }
    ]
  }</code></pre>
<p>根据官方说法，做出这样更改的原因是省略<code>-loader</code>会对新手造成误解，所以去掉这个功能，如果想打开这个旧的功能，可以配置<code>resolveLoader.moduleExtensions</code>，但是并不推荐这么做，具体参阅<a href="https://github.com/webpack/webpack/issues/2986">issues#2986</a></p>
<pre><code class="js">+ resolveLoader: {
+   moduleExtensions: ["-loader"]
+ }</code></pre>
<h2>4.使用options配置loader</h2>
<p>在webpack1.x中可以通过webpack.config.js的自定义属性来配置loader，这在webpack2.x中无法执行</p>
<pre><code class="js">module.exports = { 
  ...
  module: { 
    use: [{ 
      test: /\.tsx?$/,
      loader: 'ts-loader'
    }]
  },
  // does not work with webpack 2
  ts: { transpileOnly: false } 
}
//webpack2 use options
module.exports = { 
  ...
  module: { 
    use: [{ 
      test: /\.tsx?$/,
      loader: 'ts-loader'
      options:  { transpileOnly: false }
    }]
  }
}</code></pre>
<h1>webpack插件的使用</h1>
<h2>webpack-dev-server1.x升级2.x</h2>
<p>1.在CLI使用的时候，--inline默认开启，无需在输入命令时添加</p>
<p>2.删除contentBase用proxy代替</p>
<p>3.减少控制台无用输出，在1.x中，当我们停掉服务器后，控制台会一直输出错误信息，但是在2.x中只会输出<code>[WDS] Disconnected!</code></p>
<h2>extract-text-webpack-plugin</h2>
<p>在使用webpack将vue_spa打包后，并不会出现css，因为css被打包入build.js，如果从vue组件中抽离出css，需要安装插件<strong>extract-text-webpack-plugin</strong>，在使用的时候需要配合v2版本的才可以使用（如果使用了webpack2，则对应的插件版本都需要用v2版本）。具体配置如下：</p>
<pre><code class="js">module:{
  rules:[
    {
      test: /\.vue$/,
      loader: 'vue',
      options: {
        loaders:{
          css: extractTextPlugin.extract({
            loader: 'css-loader',
            fallbackLoader: 'vue-style-loader'
          })
        }
      }
    }
  ]
},
plugins: [
  new webpack.HotModuleReplacementPlugin(),
  new extractTextPlugin({
    filename:'/style.css',
    allChunks:true
  })
],</code></pre>
<p>在options中：</p>
<p>options.loader: string | object | loader[]  (必填项) 这里的 loader(s) 用于将资源转换为css导出模块</p>
<p>options.fallbackLoader: string | object | loader[] 当css没有被导出的时候这里的 loader(s) 会被使用 （即当在plugins模块中设置allChunks:false的时候）</p>
<p>在plugins中：</p>
<p>filename：可以设置被导出的css文件的路径以及名字</p>
<p>allChunks：从所有附加块中提取（默认情况下，它只从初始块中提取）</p>
<h2>html-webpack-plugin</h2>
<pre><code class="js">plugins: [
  new htmlWwebpackPlugin({
    filename: 'assets/admin.html'
  }),
]</code></pre>
<p>title：用于生成文档的document</p>
<p>filename：要注入的html文件，默认为index.html。可以自定义（例如：assets/admin.html）</p>
<p>inject：<br>true | ‘head’ | ‘body’ | false <br>将资源注入所给的template或templateContent，当设置为 true 或者 ‘body’，所有的资源会被注入到body底部。而head则会将js放到headelement</p>
<p>favicon: 在输出的html中添加favicon</p>
<p>hash: true | false 如果为true，则将一个唯一的webpack编译散列附加到所有包含的脚本和CSS文件。这对缓存清除很有用。</p>
<p>cache: true | false 如果为true（默认），尝试仅在更改后才发出文件。</p>
<h2>是否要更换preset？</h2>
<p>webpack2.x默认支持es6的模块，所以在编译时候没有必要将它们先转换为CommonJS模块再处理，所以在github中出现了babel-preset-es2015-webpack，但是这个模块我在使用的时候出现了<code>Cannot remove 'babel-plugin-transform-es2015-modules-commonjs' from the plugin list.</code>的问题，根据babel-preset-es2015-webpack中的叙述以及<a href="https://github.com/gajus/babel-preset-es2015-webpack/issues/14">issues#14</a>可知，babel-preset-es2015已经支持不转换模块中的<code>import</code>和<code>export</code>，只需要设置<code>.babelrc</code></p>
<pre><code class="json">{
    "presets": [
        [
            "es2015",
            {
                "modules": false
            }
        ]
    ]
}</code></pre>
<h1>参考：</h1>
<p><a href="http://www.zcfy.cc/article/migrating-from-v1-to-v2-2378.html">从 webpack v1 迁移到 webpack v2</a><br><a href="https://medium.com/webpack/whats-new-in-webpack-dev-server-2-0-a66848c3679#.b8ftvlujv">What’s new in webpack dev serv