<p>欢迎来我的博客阅读：<a href="http://huang-jerryc.com/2017/02/28/gulp-base/">《Gulp 基础与原理》</a></p></blockquote>
<h1>Gulp 概述</h1>
<p>Gulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。</p>
<p>它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。</p>
<blockquote><p>文件输入 →  Gulp 插件处理 → 文件输出</p></blockquote>
<p>原则上，gulp 可以针对文件做任何有趣、有创造力事情。<br>而自动化构建，只是大家主要比较喜欢使用的方向。</p>
<p>Gulp 的特点：</p>
<ul>
<li><p><strong>自动化</strong> - Gulp 为你的工作流而服务，自动运行那些费事费力任务。</p></li>
<li><p><strong>平台透明</strong> - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。</p></li>
<li><p><strong>强大生态系统</strong> - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。</p></li>
<li><p><strong>简单</strong> - Gulp 只提供几个 API，这可以很快地学习和上手。</p></li>
</ul>
<h1>使用 Gulp</h1>
<h2>安装</h2>
<pre><code>$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具
$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp</code></pre>
<h2>Gulpfile.js</h2>
<p>在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。<br><code>gulpfile.js</code>  文件一般都会放在项目的根目录中。</p>
<p>一个使用 <strong><a href="https://www.npmjs.com/package/gulp-babel2/">gulp-babel</a></strong> 插件来支持 es2015 语法的案例：</p>
<pre><code>const gulp = require('gulp');
const babel = require('gulp-babel');

gulp.task('default', () =&gt; {
    gulp.src('src/app.js')
        .pipe(babel({
            presets: ['es2015']
        }))
        .pipe(gulp.dest('dist'));
});</code></pre>
<h1>基本概念与原理</h1>
<p>了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。</p>
<h2>认识 Glob</h2>
<p>Glob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。<br>这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 <code>.gitignore</code> 文件也是使用这种模式。</p>
<p>各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 <code>Glob</code> 函数，Python 中的 <code>glob</code> 模块。<br>而 NodeJS 的实现是 <strong><a href="https://github.com/isaacs/minimatch">minimatch</a></strong>, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 <strong><a href="https://github.com/isaacs/node-glob">node-glob</a></strong> 模块。<br>Gulp 的 API <code>gulp.watch</code> 和 <code>gulp.src</code> 都有用到 Glob 来匹配对应的路径和文件。<br>下面是部分语法：</p>
<ul><li><p><code>*</code> <br>匹配该路径段中 0 个或多个任意字符，</p></li></ul>
<p>如：<code>js/*.js</code>， 匹配 js 目录下的所有 js 文件</p>
<ul><li><p><code>?</code> <br>  匹配该路径段中 1 个任意字符，</p></li></ul>
<p>如：<code>js/?.js</code>，匹配 js 目录下所有名字只有 1 个字的 js</p>
<ul><li><p><code>[...]</code> <br>  匹配该路径段中在指定范围内字符，</p></li></ul>
<p>如：<code>js/a[0-3].js</code>，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）</p>
<ul><li><p><code>!(pattern|pattern|pattern)</code> <br>  匹配除所给出的模型以外的情况，</p></li></ul>
<p>如：<code>js/!(a|b).js</code>，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.</p>
<ul><li><p><code>?(pattern|pattern|pattern)</code> <br>  匹配所给出的模型中的 0 个或任意 1 个，</p></li></ul>
<p>如：<code>js/?(a|a2|b).js</code>, 匹配 js 目录下 a.js , a2.js , b.js</p>
<ul><li><p><code>+(pattern|pattern|pattern)</code> <br>  匹配所给出的模型中的 1 个或者多个，</p></li></ul>
<p>如：<code>js/+(a|a1|b).js</code>, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js</p>
<ul><li><p><code>*(pattern|pattern|pattern)</code><br>  匹配所给出的模型中的 0 个或多个或任意个的组合.</p></li></ul>
<p>如：<code>js/*(a|a1|b).js</code>，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js</p>
<ul><li><p><code>@(pattern|pat*|pat?erN)</code><br>  匹配所给出的模型中的任意 1 个，</p></li></ul>
<p>如：<code>js/@(a|a1|b)</code>, 匹配 js 目录下的 a.js, a1.js, b.js</p>
<ul><li><p><code>**</code><br>  与 <code>*</code> 一样可以匹配任何内容，但 <code>**</code>不仅匹配路径中的某一段,而且可以匹配 <code>a/b/c</code> 这样带有 <code>/</code> 的内容，所以，它还可以匹配子文件夹下的文件.</p></li></ul>
<p>如：<code>js/**/*.js</code>，匹配 js 目录下及子文件夹中所有的 js 文件。</p>
<p>更多 Glob 的知识和语法，可以参考：<br><a href="https://www.wikiwand.com/en/Glob_(programming">Glob - Wiki</a><br><a href="https://github.com/isaacs/node-glob#glob-primer">Glob Primer</a></p>
<h2>认识 Vinyl</h2>
<p><a href="https://github.com/gulpjs/vinyl">Vinyl</a> 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 <code>vinyl-fs</code></p>
<p><a href="https://github.com/gulpjs/vinyl-fs">Vinyl-fs</a>，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。</p>
<p>在 Gulp 中的 API <code>gulp.src</code>、<code>gulp.watch</code>、<code>gulp.dest</code> 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ <code>vinyl1.pipe(vinyl2)</code> ）的形式来互相传输数据。 </p>
<p>从 Gulp 的 <a href="https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41">源码</a> 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。</p>
<p>再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。</p>
<h2>认识 Orchestrator</h2>
<p><a href="https://github.com/robrich/orchestrator">Orchestartor</a>，为 <code>gulp.task</code> 提供了全部实现，这可以从 <a href="https://github.com/gulpjs/gulp/blob/master/index.js#L14">源码</a> 中看出。<br>它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。</p>
<p>Orchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 <code>gulp.task</code> 时注册的函数列表，以及函数的依赖和名字。<br>通过 <a href="https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57">源码</a> 中，可以看到 tasks 的数据结构：</p>
<pre><code class="javascript">...
this.tasks[name] = {
  fn: fn,   // 任务的函数体
  dep: dep,   // 任务所依赖的其他任务名称
  name: name  // 该任务的名称
};
...</code></pre>
<h1>Gulp 核心 API</h1>
<ul>
<li><p>gulp.src：获取文件</p></li>
<li><p>gulp.dest：写入文件</p></li>
<li><p>gulp.tasks：注册任务</p></li>
<li><p>gulp.watch：监控文件的改动</p></li>
</ul>
<h2>gulp.src</h2>
<p><code>gulp.src( globs [, options] )</code></p>
<p>接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。<br>而 options 有下面的值：</p>
<ul>
<li><p>buffer - Boolean, 控制 <code>file.contents</code> 是返回 buffer 还是 stream。</p></li>
<li><p>read - Boolean，控制是否读取文件，如果 false，则 <code>file.contents</code> 为 <code>null</code></p></li>
<li><p>base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 <code>client/js/**/*.js</code>, base 值就为 <code>client/js/</code>。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。</p></li>
</ul>
<h2>gulp.dest</h2>
<p><code>gulp.dest( path [, options] )</code></p>
<p>接收输出路径，返回一个 Vinyl Stream 实例。<br>而 options 有以下的值：</p>
<ul>
<li><p>cwd - String， 默认值 <code>process.pwd()</code>，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。</p></li>
<li><p>mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。</p></li>
</ul>
<h2>gulp.task</h2>
<p><code>gulp.task( name [, deps ], fn )</code></p>
<p>定义一个使用 Orchestrator 实现的任务（task）。<br>参数的描述如下：</p>
<ul>
<li><p>name - 任务名称</p></li>
<li><p>deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数</p></li>
<li><p>fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</p></li>
</ul>
<h2>gulp.watch</h2>
<p><code>gulp.watch( glob [, opts ], tasks )</code><br>or<br><code>gulp.watch( glob [, opts, cb ] )</code></p>
<p>用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。<br>各参数的描述如下：</p>
<ul>
<li><p>glob - 为要监视的文件 Glob 匹配模式。</p></li>
<li><p>opts - 为一个可选的配置对象。</p></li>
<li><p>tasks - 为文件变化后要执行的任务，为一个数组</p></li>
</ul>
<h1>常用插件</h1>
<ul>
<li><p><a href="https://www.npmjs.com/package/gulp-load-plugins">gulp-load-plugins</a>：自动加载 <code>package.json</code> 中的 gulp 插件</p></li>
<li><p><a href="https://www.npmjs.com/package/gulp-rename">gulp-rename</a>： 重命名</p></li>
<li><p><a href="https://www.npmjs.com/package/gulp-uglify">gulp-uglify</a>：文件压缩</p></li>
<li><p><a href="https://www.npmjs.com/package/gulp-concat">gulp-concat</a>：文件合并</p></li>
<li><p><a href="https://www.npmjs.com/package/gulp-less">gulp-less</a>：编译 less</p></li>
<li><p><a href="https://www.npmjs.com/package/gulp-sass">gulp-sass</a>：编译 sass</p></li>
<li><p><a href="https://github.com/scniro/gulp-clean-css">gulp-clean-css</a>：压缩 CSS 文件</p></li>
<li><p><a href="https://github.com/jonschlinkert/gulp-htmlmin">gulp-htmlmin</a>：压缩 HTML 文件</p></li>
<li><p><a href="https://github.com/babel/gulp-babel">gulp-babel</a>: 使用 babel 编译 JS 文件</p></li>
<li><p><a href="https://www.npmjs.com/package/gulp-jshint">gulp-jshint</a>：jshint 检查</p></li>
<li><p><a href="https://github.com/sindresorhus/gulp-imagemin">gulp-imagemin</a>：压缩jpg、png、gif等图片</p></li>
<li><p><a href="https://github.com/vohof/gulp-livereload">gulp-livereload</a>：当代码变化时，它可以帮我们自动刷新页面</p></li>
</ul>
<p>更多插件，可以搜索<a href="http://gulpjs.com/plugins/">